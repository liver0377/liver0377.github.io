<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[UNP]:Unix域套接字</title>
    <link href="/2022/04/04/UNP-Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2022/04/04/UNP-Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>Unix Domain协议是一个在单主机上执行进程间通信的IPC方法， 使用Unix Domain套接字有以下几个理由:</p><ul><li><p>UNIX域套接字域TCP套接字相比，在同一台主机的传输速度前者是后者的两倍</p><p>UNIX域套接字仅仅复制数据，并不执行协议处理，不需要添加或删除网络报头，无需计算校验和，不产生顺序号，也不需要发送确认报文</p></li><li><p>UNIX域套接字可以在同一台主机上各进程之间传递文件描述符</p></li><li><p>UNIX域套接字使用路径名来表示协议地址</p></li></ul><h3 id="1-Unix-Domain套接字地址结构"><a href="#1-Unix-Domain套接字地址结构" class="headerlink" title="1. Unix Domain套接字地址结构"></a>1. Unix Domain套接字地址结构</h3><ul><li><p>sockaddr_un</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX 108 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span>&#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sun_family;                  <span class="hljs-comment">// AF_LOCAL </span><br>    <span class="hljs-keyword">char</span>           sun_path[UNIX_PATH_MAX];     <span class="hljs-comment">// 路径名，必须以空字符结尾</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>sun_family</p><p>协议族，Unix Domain套接字即是AF_LOCAL</p></li><li><p>sun_path</p><p>路径名，用于标识协议地址</p></li></ul></li></ul><h3 id="2-socketpair"><a href="#2-socketpair" class="headerlink" title="2. socketpair()"></a>2. socketpair()</h3><p>该函数用于创建两个套接字，调用完成后，这两个套接字就会自行<code>connect()</code>, 有点类似于管道, 该函数只适用于Unix Domain套接字</p><ul><li><p>socketpair</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socketpair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol, <span class="hljs-keyword">int</span> sockfd[<span class="hljs-number">2</span>])</span></span>;<br>                                              <span class="hljs-comment">// return : 成功返回0， 失败返回-1</span><br></code></pre></td></tr></table></figure><ul><li><p>family + protocol</p><p>对于Unix Domain套接字来说，family必须置为<strong>AF_LOCOL</strong>, protocol必须置为0</p></li><li><p>type</p><p>套接字的类型，可以是<strong>SOCK_STREAM</strong>或<strong>SOCK_DGRAM</strong>, 通常是SOCK_STREAM</p></li><li><p>sockfd[2]</p><p>类似于管道的返回方式，sockfd[0], sockfd[1]是两个套接字，两个管道之间是全双工的连接</p></li></ul></li></ul><h3 id="3-Unix-Domain套接字限制"><a href="#3-Unix-Domain套接字限制" class="headerlink" title="3. Unix Domain套接字限制"></a>3. Unix Domain套接字限制</h3><p><img src="1.png" alt="1"></p><h3 id="4-客户-服务器程序"><a href="#4-客户-服务器程序" class="headerlink" title="4. 客户/服务器程序"></a>4. 客户/服务器程序</h3><p>在客户/服务器程序中，使用Unix Domain套接字与使用普通的套接字j基本上没什么区别，最大的区别就是多了上面所说的那些限制</p><p>注: <strong>当使用Unix Domain 数据报套接字协议时，必须显式绑定bind一个路径名到套接字</strong></p><h3 id="5-描述符传递"><a href="#5-描述符传递" class="headerlink" title="5. 描述符传递"></a>5. 描述符传递</h3><p>使用Unix Domain套接字进行文件描述符传递的流程如下</p><ul><li><p>两个进程分别创建Unix Domain套接字(通常是SOCK_STREM类型)</p></li><li><p>服务器端依旧是进行常规的套接字操作流程:</p><ul><li>bind()路径名到指定套接字</li></ul></li><li><p>客户端打开一个文件描述符，创建<code>msghdr</code>结构，在其中的辅助数据<code>msg_control</code>字段包含给定的文件描述符</p><p>调用<code>sendmsg()</code>发送给服务器进程，此时该文件描述符处于<strong>in flight</strong></p><p>注： <strong>一旦子进程发送了这个打开的文件描述符，它就可以exit()了，即使这样做会关闭其所有的打开着的文件描述符</strong></p><p><strong>对于接受进程来说，该描述符依旧处于打开状态</strong></p><blockquote><p>发送一个文件描述符会使文件描述符的引用计数 + 1</p></blockquote></li><li><p>接受进程调用<code>recvmsg()</code>接受该描述符</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:高级IO</title>
    <link href="/2022/04/02/UNP-%E9%AB%98%E7%BA%A7IO/"/>
    <url>/2022/04/02/UNP-%E9%AB%98%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<h3 id="1-套接字超时"><a href="#1-套接字超时" class="headerlink" title="1. 套接字超时"></a>1. 套接字超时</h3><p>在涉及套接字的I/O操作上设置超时的方法有三种</p><ul><li>使用<code>alarm()</code></li><li>使用<code>select()</code></li><li>使用套接字选项: <strong>SO_RCVTIMEO</strong>, <strong>SO_SNDTIMEO</strong></li></ul><h4 id="1-alarm"><a href="#1-alarm" class="headerlink" title="1. alarm"></a>1. alarm</h4><p>接下来使用<code>alarm()</code>为<code>connect()</code>设置超时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include connect_timeo */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><span class="hljs-title">connect_alarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">connect_timeo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> SA *saptr, <span class="hljs-keyword">socklen_t</span> salen, <span class="hljs-keyword">int</span> nsec)</span></span><br><span class="hljs-function"></span>&#123;<br>Sigfunc*sigfunc;<br><span class="hljs-keyword">int</span>n;<br><br>sigfunc = Signal(SIGALRM, connect_alarm);<br>    <span class="hljs-comment">/*************************************************/</span><br><span class="hljs-keyword">if</span> (alarm(nsec) != <span class="hljs-number">0</span>)   <span class="hljs-comment">// 设置超时事件为nesec</span><br>err_msg(<span class="hljs-string">&quot;connect_timeo: alarm was already set&quot;</span>);<br>    <span class="hljs-comment">/************************************************/</span><br><span class="hljs-keyword">if</span> ( (n = connect(sockfd, saptr, salen)) &lt; <span class="hljs-number">0</span>) &#123;<br>close(sockfd);<br><span class="hljs-keyword">if</span> (errno == EINTR)<br>errno = ETIMEDOUT;<br>&#125;<br>    <span class="hljs-comment">/************************************************/</span><br>alarm(<span class="hljs-number">0</span>);<span class="hljs-comment">// 超时时间之前connect()调用返回，关闭alarm</span><br>    <span class="hljs-comment">/***********************************************/</span><br>Signal(SIGALRM, sigfunc);<span class="hljs-comment">/* restore previous signal handler */</span><br><br><span class="hljs-keyword">return</span>(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">connect_alarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">/* just interrupt the connect() */</span><br>&#125;<br><span class="hljs-comment">/* end connect_timeo */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">Connect_timeo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> SA *sa, <span class="hljs-keyword">socklen_t</span> salen, <span class="hljs-keyword">int</span> sec)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (connect_timeo(fd, sa, salen, sec) &lt; <span class="hljs-number">0</span>)<br>err_sys(<span class="hljs-string">&quot;connect_timeo error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h4><p>接下来使用<code>select()</code>为<code>recvfrom()</code>设置超时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include readable_timeo */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">readable_timeo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> sec)</span></span><br><span class="hljs-function"></span>&#123;<br>fd_setrset;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span><span class="hljs-title">tv</span>;</span><br><br>FD_ZERO(&amp;rset);<br>FD_SET(fd, &amp;rset);<br><br>tv.tv_sec = sec;<br>tv.tv_usec = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span>(select(fd+<span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;tv));   <span class="hljs-comment">// 使用select()自带的超时参数</span><br><span class="hljs-comment">/* 4&gt; 0 if descriptor is readable */</span><br>&#125;<br><span class="hljs-comment">/* end readable_timeo */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">Readable_timeo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> sec)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>n;<br><br><span class="hljs-keyword">if</span> ( (n = readable_timeo(fd, sec)) &lt; <span class="hljs-number">0</span>)<br>err_sys(<span class="hljs-string">&quot;readable_timeo error&quot;</span>);<br><span class="hljs-keyword">return</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-套接字选项"><a href="#3-套接字选项" class="headerlink" title="3. 套接字选项"></a>3. 套接字选项</h4><p>使用套接字选项<strong>SO_RCVTIMEO</strong>为<code>recvfrom()</code>设置超时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">dg_cli</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> SA *pservaddr, <span class="hljs-keyword">socklen_t</span> servlen)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>n;<br><span class="hljs-keyword">char</span>sendline[MAXLINE], recvline[MAXLINE + <span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span><span class="hljs-title">tv</span>;</span><br><br>tv.tv_sec = <span class="hljs-number">5</span>;<br>tv.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/***********************************************************/</span><br>Setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="hljs-keyword">sizeof</span>(tv));<br>    <span class="hljs-comment">/**********************************************************/</span><br><span class="hljs-keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="hljs-literal">NULL</span>) &#123;<br><br>Sendto(sockfd, sendline, <span class="hljs-built_in">strlen</span>(sendline), <span class="hljs-number">0</span>, pservaddr, servlen);<br><br>n = recvfrom(sockfd, recvline, MAXLINE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (errno == EWOULDBLOCK) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;socket timeoutn&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span><br>err_sys(<span class="hljs-string">&quot;recvfrom error&quot;</span>);<br>&#125;<br><br>recvline[n] = <span class="hljs-number">0</span>;<span class="hljs-comment">/* null terminate */</span><br>Fputs(recvline, <span class="hljs-built_in">stdout</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果I/O操作超时，那么读取操作(recvfrom())将会返回一个<strong>EWOULDBLOCK</strong>错误</p><h3 id="2-recv-send"><a href="#2-recv-send" class="headerlink" title="2. recv(), send()"></a>2. recv(), send()</h3><p>这两个函数类似于<code>read()</code>与<code>write()</code>, 但是支持更多的flag</p><ul><li><p>recv, send</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-comment">/* 返回：成功返回读入写出的字节数，出错返回 -1 */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span>* buff, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* buff, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>指定描述符</p></li><li><p>buff</p><p>读/写缓冲区</p></li><li><p>nbytes</p><p>缓冲区大小</p></li><li><p>flags</p><p>flags可选值如下</p><p><img src="1.png" alt="1"></p><p>对其中的几个参数稍微解释一下</p><ul><li><p>MSG_DONROUTE</p><p>本标志告诉内核目的主机在本地网络上，不需要通过路由表进行查找</p></li><li><p>MSG_WAITALL</p><p>该标志告诉内核不要在尚未读取完请求数目的字节之前就让操作返回</p></li></ul></li></ul></li></ul><h3 id="3-readv-writev"><a href="#3-readv-writev" class="headerlink" title="3. readv(), writev()"></a>3. readv(), writev()</h3><p>这两个函数允许单个I/O调用读出或写入多个缓冲区, 这也被称作<strong>分散读</strong>和<strong>集中写</strong></p><ul><li><p>iovec</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>&#123;</span><br>    <span class="hljs-keyword">void</span> *iov_base;      <span class="hljs-comment">/* buf 的开始地址 */</span><br>    <span class="hljs-keyword">size_t</span> iov_len;      <span class="hljs-comment">/* buf 的大小 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>readv, writev</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/uio.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fileds, <span class="hljs-keyword">const</span> struct iovec* iov, <span class="hljs-keyword">int</span> iovcnt)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">writev</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fields, <span class="hljs-keyword">const</span> struct iovec* iov, <span class="hljs-keyword">int</span> iovcnt)</span></span>;<br><span class="hljs-comment">/* 返回：成功返回读入或写出的字节数，出错返回 -1 */</span><br></code></pre></td></tr></table></figure><ul><li><p>fileds</p><p>描述符(文件描述符/套接字描述符)</p></li><li><p>iov</p><p>读取/写入缓冲区数组</p></li><li><p>iovcnt</p><p>数组长度</p></li></ul></li></ul><h3 id="4-recvmsg-sendmsg"><a href="#4-recvmsg-sendmsg" class="headerlink" title="4. recvmsg(), sendmsg()"></a>4. recvmsg(), sendmsg()</h3><p>这两个函数是最通用的I/O函数，几乎什么都能干</p><ul><li><p>msghdr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* msghdr结构 用来保存大部分参数 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span>&#123;</span><br>    <span class="hljs-keyword">void</span> *msg_name;<br>    <span class="hljs-keyword">socklen_t</span> msg_namelen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">msg_iov</span>;</span><br>    <span class="hljs-keyword">int</span> msg_iovlen;<br>    <span class="hljs-keyword">void</span> *msg_control;<br>    <span class="hljs-keyword">socklen_t</span> msg_controllen;<br>    <span class="hljs-keyword">int</span> msg_flags;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>msg_name</p><p>该字段通常只用于未连接UDP套接字，用于存放套接字地址结构</p><p>对于<code>recvmsg()</code>来说, 该字段用于存储发送者的地址结构</p><p>对于<code>sendmsg()</code>来说，该字段用于存储接受者的地址结构</p><p>当该字段不需要(TCP套接字或已连接UDP套接字)时，该字段应该被置为空</p></li><li><p>msg_namelen</p><p><code>msg_name</code>的长度</p></li><li><p>msg_iov</p><p>缓冲区数组</p></li><li><p>msg_iovlen</p><p>缓冲区数组元素个数</p></li><li><p>msg_control</p><p>辅助数据</p></li><li><p>msg_controllen</p><p><code>msg_control</code>的长度</p></li><li><p>msg_flags</p><p>该字段只用于<code>recvmsg()</code>, 是一个值-结果类型参数</p><p>传入时<code>recvmsg()</code>的<code>flags</code>会被复制到其中</p><p>传出时内核会根据接受到的结果来更新其值</p></li></ul><p>一个典型的<code>msghdr</code>结构看起来就像这样</p><p><img src="2.png" alt="2"></p></li><li><p>recvmsg, sendmsg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr * msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr * msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-comment">// 返回：成功读入或者写出的字节数，出错则为 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>指定套接字描述符</p></li><li><p>msg</p><p>各种参数集合</p></li><li><p>flags</p><p>标志, 下面是它的总结图</p><p><img src="3.png" alt="3"></p><ul><li><p>标志解释</p><p><img src="4.png" alt="4"></p></li></ul></li></ul></li></ul><p><strong>5组I/O函数的比较</strong></p><p><img src="5.png" alt="5"></p><h3 id="5-辅助数据"><a href="#5-辅助数据" class="headerlink" title="5. 辅助数据"></a>5. 辅助数据</h3><p>在<code>struct msghdr</code>结构当中存在辅助数据字段，接下来对其进行介绍</p><ul><li><p><code>cmsghdr</code></p><p>辅助数据由一个或多个<strong>辅助数据对象</strong>构成，每个对象由一个<code>cmsghdr</code>结构开头，用于描述该对象的属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span>&#123;</span><br>    <span class="hljs-keyword">socklen_t</span> cmsg_len;<br>    <span class="hljs-keyword">int</span> cmsg_level;<br>    <span class="hljs-keyword">int</span> cmsg_type;<br>    <span class="hljs-comment">// 后面紧跟着cmsg_data[]</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>cmsg_len</p><p>用于指明辅助数据对象的长度</p></li><li><p>cmsg_level + cmsg_type</p><p>这两个字段组合用于用于指明辅助数据的用途</p><p><img src="6.png" alt="6"></p></li></ul></li><li><p>辅助数据示意图</p><p><img src="7.png" alt="7"></p><blockquote><p>辅助数据有着对其要求，在<code>cmsghdr</code>与辅助数据之间有着填充字节，在辅助对象之间也有着填充字节</p></blockquote></li></ul><p>为了屏蔽填充字节的细节，头文件<code>&lt;sys/socket.h&gt;</code>中定义了以下5个宏，用于简化对辅助数据的处理</p><p><img src="8.png" alt="8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:名称-地址转换函数</title>
    <link href="/2022/04/01/UNP-%E5%90%8D%E7%A7%B0-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/01/UNP-%E5%90%8D%E7%A7%B0-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>下面将介绍名称(主机名，服务名)与地址之间的转换函数</p><h3 id="1-gethostbyname"><a href="#1-gethostbyname" class="headerlink" title="1. gethostbyname()"></a>1. gethostbyname()</h3><p>该函数用于从主机名获取IP地址</p><ul><li><p>struct hostent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>&#123;</span><br>    <span class="hljs-keyword">char</span>    *h_name;        <span class="hljs-comment">/* 主机的官方名称 */</span><br>    <span class="hljs-keyword">char</span>    **h_aliases;    <span class="hljs-comment">/* 主机别名的指针数组 */</span><br>    <span class="hljs-keyword">int</span>     h_addrtype;     <span class="hljs-comment">/* 主机IP地址的类型 */</span><br>    <span class="hljs-keyword">int</span>     h_length;       <span class="hljs-comment">/* IPv4的地址长度 */</span><br>    <span class="hljs-keyword">char</span>**  h_addr_list;    <span class="hljs-comment">/* IPV4地址列表, 以NULL结尾, 注意这里存储的部分点分十进制串，而是网络字节序 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>图例</p><p><img src="1.png" alt="1"></p></li><li><p>gethostbyname</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct hostent * <span class="hljs-title">gethostbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * hostname)</span></span><br><span class="hljs-function">                                  <span class="hljs-comment">// 成功：非空指针, 失败: NULL, h_errno被置为相关错误码</span></span><br></code></pre></td></tr></table></figure><ul><li><p>hostname</p><p>主机名，如baidu.com</p></li></ul></li></ul><p><strong>h_errno</strong><br><code>gethostbyname()</code>的特殊之处在于，当发生错误时，它不设置<code>errno</code>，而是将全局整数变量设置为定义在<code>&lt;netdb.h&gt;</code>中的以下常量之一</p><ul><li>HOST_NOT_FOUND</li><li>TRY_RECOVER</li><li>NO_RECOVERY</li><li>NO_DATA</li></ul><h3 id="2-gethostbyaddr"><a href="#2-gethostbyaddr" class="headerlink" title="2. gethostbyaddr()"></a>2. gethostbyaddr()</h3><p>该函数将一个二进制IP地址转换为主机名</p><ul><li><p>gethostbyaddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-function">struct hostent *<span class="hljs-title">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">socklen_t</span> len, <span class="hljs-keyword">int</span> family)</span></span>;<br>                                       <span class="hljs-comment">// return: 成功返回非空指针，失败返回NULL, 设置h_errno</span><br></code></pre></td></tr></table></figure><ul><li><p>addr</p><p>二进制IP地址，通常传入的就是<code>in_addr</code>类型</p></li><li><p>len</p><p>addr大小</p></li><li><p>family</p><p>协议族</p></li></ul></li></ul><h3 id="3-getservbyname-getservbyport"><a href="#3-getservbyname-getservbyport" class="headerlink" title="3. getservbyname(), getservbyport()"></a>3. getservbyname(), getservbyport()</h3><p>这两个函数用于获取相关服务(ftp, domain等)的信息</p><ul><li><p>struct strvent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> * s_name;               <span class="hljs-comment">// 官方服务名称</span><br>    <span class="hljs-keyword">char</span> ** s_aliases;           <span class="hljs-comment">// 别名列表</span><br>    <span class="hljs-keyword">int</span> s_port;                  <span class="hljs-comment">// 端口号(网络字节序)</span><br>    <span class="hljs-keyword">char</span> * s_proto;              <span class="hljs-comment">// 协议</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getservbyname</p><p>一般使用该函数来获取某个服务的端口号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct servent * <span class="hljs-title">getservbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * servname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * protoname)</span></span>;<br>                               <span class="hljs-comment">// return: 成功返回非空指针，失败返回NULL</span><br></code></pre></td></tr></table></figure><ul><li><p>servname</p><p>服务的名称，可以是<code>domain</code>, <code>ftp</code>等</p></li><li><p>protoname</p><p>协议名，可以是<code>udp</code>, <code>tcp</code>等</p><p>有的服务支持多种协议</p></li></ul></li><li><p>getservbyport</p><p>一般使用该函数来获取服务名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct servent *<span class="hljs-title">getservbyport</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *protoname)</span></span>;<br>                             <span class="hljs-comment">// return: 成功返回非空指针，失败返回NULL</span><br></code></pre></td></tr></table></figure><ul><li><p>port</p><p>服务所在的端口号, 必须得是网络字节序</p><p>通常的使用方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sptr = getservbyport(htons(<span class="hljs-number">21</span>), <span class="hljs-string">&quot;udp&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>protoname</p><p>协议名</p></li></ul></li></ul><h3 id="4-getaddrinfo"><a href="#4-getaddrinfo" class="headerlink" title="4. getaddrinfo()"></a>4. getaddrinfo()</h3><p>该函数能够处理名称到地址以及服务到端口这两种转换</p><ul><li><p>getaddrinfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * hostname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * service, </span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">const</span> struct addrinfo *hints,struct addrinfo **result)</span></span>;<br>                                            <span class="hljs-comment">//return: 成功返回0, 失败返回非0错误值</span><br></code></pre></td></tr></table></figure><ul><li><p>hostname</p><p>主机名</p></li><li><p>service</p><p>服务名, 可以是字符串，也可以是网络字节序的端口号</p></li><li><p>hints</p><ul><li><p>addrinfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>&#123;</span><br><span class="hljs-keyword">int</span> ai_flags;                      <span class="hljs-comment">// 选项</span><br><span class="hljs-keyword">int</span> ai_family;                     <span class="hljs-comment">// 地址族</span><br><span class="hljs-keyword">int</span> ai_socktype;                   <span class="hljs-comment">// 套接字类型</span><br><span class="hljs-keyword">int</span> ai_protocol;                   <span class="hljs-comment">// 协议类型</span><br><span class="hljs-keyword">socklen_t</span> ai_addrlen;              <span class="hljs-comment">// ai_addr链表的大小</span><br><span class="hljs-keyword">char</span> * ai_canonname;               <span class="hljs-comment">// 主机名</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> * <span class="hljs-title">ai_addr</span>;</span>         <span class="hljs-comment">// ptr to socket address structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> * <span class="hljs-title">ai_next</span>;</span>         <span class="hljs-comment">// ptr to next structure in linked list</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>该参数用于对函数的返回值进行<strong>过滤</strong>，如在<code>ai_socktype</code>字段填入SOCK_DGRAM, 那么函数就只会返回数据报套接字的信息</p><p>hints参数中只能对以下字段进行设置</p><table><thead><tr><th align="left"></th><th align="left">可以设置的成员</th></tr></thead><tbody><tr><td align="left"><code>ai_flags</code></td><td align="left">零个或多个在一起的AI_XXX值.</td></tr><tr><td align="left"><code>ai_family</code></td><td align="left">某个AF_XXX</td></tr><tr><td align="left"><code>ai_socktype</code></td><td align="left">某个SOCK_XXX值</td></tr><tr><td align="left"><code>ai_protocol</code></td><td align="left">某个写控制协议</td></tr></tbody></table><p><code>ai_flags</code>可以设置的值如下</p><table><thead><tr><th align="left">ai_flags可能值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>AI_PASSIVE</code></td><td align="left">套接字将用于被动打开。</td></tr><tr><td align="left"><code>AI_CANONNAME</code></td><td align="left">告知 getaddrinfo 函数返回主机的规范名字</td></tr><tr><td align="left"><code>AI_NUMERICHOST</code></td><td align="left">防止任何类型的名字到地址映射， hostname参数必须为一个地址串</td></tr><tr><td align="left"><code>AI_NUMERICSERV</code></td><td align="left">防止任何类型的名字到服务的映射,service 参数必须是一个十进制端口号数串</td></tr><tr><td align="left"><code>AI_V4MAPPED</code></td><td align="left">如果同时指定 ai_family 成员的值为 AF_INET6,那么如果没有可用的AAAA记录，就返回与A记录对应的IPV4映射的IPV6地址</td></tr><tr><td align="left"><code>AI_ALL</code></td><td align="left">如果同时指定 AI_V4MAPPED 标志，那么除了返回与AAAA记录对应的IPV6地址外，还返回与A记录对应的IPV4映射的IPV6地址</td></tr><tr><td align="left"><code>AI_ADDRCONFIG</code></td><td align="left">按照所在主机的配置选择返回地址类型，也就是只查找与所在主机回馈接口以外的网络接口配置的IP地址版本一致的地址</td></tr></tbody></table><ul><li><p>AI_CANONNAME</p><p>如果在<code>hints</code>中设置了该标志，那么返回的<code>result</code>链表的第一个节点的<code>ai_canonname</code>字段将包含所查找主机的规范名</p></li></ul></li><li><p>result</p><p>该参数返回最终的查询结果，是一个链表的首地址, 看起来像这样</p><p><img src="2.png" alt="2"></p></li></ul><blockquote><p>该函数虽然功能很强大，但是有点过于复杂，UNP中也认为其并不好用，故在此不做过多描述</p></blockquote></li></ul><h3 id="5-gai-strerror"><a href="#5-gai-strerror" class="headerlink" title="5. gai_strerror()"></a>5. gai_strerror()</h3><p>该函数用于解析getaddrinfo()返回的非零错误值，将<code>errno</code>转换为字符串</p><ul><li><p>gai_strerror</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error)</span></span>;<br>                                              <span class="hljs-comment">// return：指向错误描述消息字符串的指针</span><br></code></pre></td></tr></table></figure><ul><li><p>error</p><p>错误号</p></li></ul><p>具体的错误消息如下</p><table><thead><tr><th align="left">常数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>EAI_AGAIN</code></td><td align="left">名字解析中临时失败</td></tr><tr><td align="left"><code>EAI_BADFLAGS</code></td><td align="left">ai_flags的值无效</td></tr><tr><td align="left"><code>EAI_FAIL</code></td><td align="left">名字解析中不可恢复地失败</td></tr><tr><td align="left"><code>EAI_FAMILY</code></td><td align="left">不支持 ai_family</td></tr><tr><td align="left"><code>EAI_MEMORY</code></td><td align="left">内存分配失败</td></tr><tr><td align="left"><code>EAI_NONAME</code></td><td align="left">hostname或service未提供，或者不可知</td></tr><tr><td align="left"><code>EAI_OVERFLOW</code></td><td align="left">用户参数缓冲区溢出（仅限 getnameinfo 函数）</td></tr><tr><td align="left"><code>EAI_SERVICE</code></td><td align="left">不支持 ai_socktype 类型的service</td></tr><tr><td align="left"><code>EAI_SOCKTYPE</code></td><td align="left">不支持 ai_socktype</td></tr><tr><td align="left"><code>EAI_SYSTEM</code></td><td align="left">在errno变量中有系统错误返回</td></tr></tbody></table></li></ul><h3 id="6-freeaddrinfo"><a href="#6-freeaddrinfo" class="headerlink" title="6. freeaddrinfo()"></a>6. freeaddrinfo()</h3><p>该函数同样与<code>getaddrinfo()</code>搭配使用, <code>getaddrinfo()</code>中返回的链表结构全部都是动态分配的(malloc), 需要调用<code>freeaddrinfo()</code>来将这些动态分配的结构释放</p><ul><li><p>freeaddrinfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(struct addrinfo *ai)</span></span><br></code></pre></td></tr></table></figure><ul><li><p>ai</p><p>该参数应该指向由<code>getaddrinfo()</code>返回的第一个<code>addrinfo</code>结构</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:套接字选项</title>
    <link href="/2022/04/01/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/"/>
    <url>/2022/04/01/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>有以下几个API可以用于设置套接字选项:</p><ul><li>getsockopt()</li><li>setsockopt()</li><li>fcntl()</li><li>ioctl()</li></ul><p>本文将会这些API以及选项进行介绍</p><p><strong>选项汇总图</strong></p><ul><li>套接字层和IP层</li></ul><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><ul><li>传输层</li></ul><p><img src="3.png" alt="3"></p><h3 id="1-getsockopt-setsockopt"><a href="#1-getsockopt-setsockopt" class="headerlink" title="1. getsockopt(), setsockopt()"></a>1. getsockopt(), setsockopt()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> level, <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">void</span> *optname, <span class="hljs-keyword">void</span> *optval, <span class="hljs-keyword">socklen_t</span> *optlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> level, <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *optval, <span class="hljs-keyword">socklen_t</span> optlen)</span></span>;<br>                                                               <span class="hljs-comment">// return：成功0，出错-1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>打开的套接字描述符</p></li><li><p>level</p><p>用于指定选项是应对通用套接字还是指定特定协议(IPV4, IPV6, SCTP)</p></li><li><p>optname</p><p>选项名，即一些指定的宏</p></li><li><p>optval</p><ul><li><code>setsockopt()</code>通过它获取新值，</li><li><code>getsockopt()</code>把已获取的选项当前值存放到optval所指向的内容</li></ul></li><li><p>optlen</p><p>optval的大小</p></li></ul><p><strong>fcntl(), ioctl()套接字操作图</strong></p><p><img src="4.png" alt="4"></p><h3 id="2-fcntl"><a href="#2-fcntl" class="headerlink" title="2. fcntl()"></a>2. fcntl()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ...<span class="hljs-comment">/* int arg */</span>)</span></span>;<br>                          <span class="hljs-comment">// return: 成功的返回值取决于 cmd, 失败：返回-1</span><br></code></pre></td></tr></table></figure><ul><li><p>fd</p><p>描述符(文件/套接字/路由)</p></li><li><p>cmd</p><p>所做的操作，最重要的操作包含两个</p><ul><li><p><strong>F_SETFL</strong></p><p>设置选项</p></li><li><p><strong>F_GETFL</strong></p><p>获取选项</p></li></ul></li><li><p>arg</p><p>参数列表，与cmd搭配， 两个重要的选项：</p><ul><li><p><strong>O_NONBLOCK</strong></p><p>通过F_SETFL将套接字设置为O_NONBLOCK, 可以将一个套接字设置为非阻塞型</p></li><li><p><strong>O_ASYNC</strong></p><p>通过F_SETFL将套接字设置为O_ASYNC, 可以将一个套接字设置为<strong>一旦其状态发生变化</strong>，内核就产生一个<strong>SIGIO</strong>信号</p></li></ul></li></ul><p><strong>设置选项的典型使用方法</strong></p><ul><li><p>获取选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> flag;<br><span class="hljs-comment">/* Set a socket as nonblocking */</span><br><span class="hljs-keyword">if</span>((flag=fcntl(fd, F_GETFL, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//必须要先获取其他文件标志</span><br>    err_sys(<span class="hljs-string">&quot;F_GETFL, error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">flag |= O_NONBLOCK;                       <span class="hljs-comment">//或运算，打开非阻塞标志</span><br><span class="hljs-keyword">if</span>(fcntl(fd, F_SETFL, flags) &lt;<span class="hljs-number">0</span> )&#123;<br>    err_sys(<span class="hljs-string">&quot;F_SETFL error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取消选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">flag &amp;= ~O_NONBLOCK;                      <span class="hljs-comment">//与运算，关闭非阻塞标志</span><br><span class="hljs-keyword">if</span>(fcntl(fd, F_SETFL, flags) &lt;<span class="hljs-number">0</span> )&#123;<br>    err_sys(<span class="hljs-string">&quot;F_SETFL error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-重要选项说明"><a href="#4-重要选项说明" class="headerlink" title="4.  重要选项说明"></a>4.  重要选项说明</h3><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><p><strong>SO_SNDBUF, SO_RCVBUF</strong></p><ul><li><p>套接字缓冲区</p><p><strong>发送缓冲区</strong></p><ul><li><p>每一个TCP, UDP套接字都有一个发送缓冲区，当应用进程调用<code>write()</code>时，内核会从<strong>应用进程的缓冲区</strong>复制所有数据到所写<strong>套接字的发送缓冲区</strong></p></li><li><p>如果套接字的发送缓冲区容不下进程的所有数据，假设默认情况下套接字阻塞，那么应用进程将被置于<strong>休眠状态</strong>，在上面的情况下内核将不会从应用进程返回，直到<strong>应用进程缓冲区</strong>中的所有数据都复制到<strong>套接字发送缓冲区</strong></p></li><li><p>故写一个套接字的<code>write()</code>调用成功仅意味着数据已经从应用程序缓冲区移动到了套接字缓冲区，并不意味着对端已经接收到了数据</p></li><li><p>仅当套接字接收到来自对端的ACK时，套接字缓冲区中的相应数据才能被丢弃</p></li></ul><p><strong>接受缓冲区</strong></p><ul><li>每一个TCP, UDP套接字同样有一个<strong>接受缓冲区</strong>用于保存接收到的数据，直到由应用进程来读取</li><li>TCP<ul><li>对于TCP来说，接收缓冲区的可用空间大小限定了TCP通告对端的窗口大小</li><li>TCP的接受缓冲区不可能溢出，因为不允许对端发送超过该窗口大小的数据，这就是TCP的流量控制</li><li>如果对端无视了窗口大小而发送了超过该窗口大小的数据，这些数据将会被丢弃</li></ul></li><li>UDP<ul><li>对于UDP来说，当接收到的数据报装不进套接字接受缓冲区时，该数据报就被丢弃</li></ul></li></ul></li></ul><p>这两个选项用于设置发送缓冲区大小和接受缓冲区大小，应该在建立连接之前就应该设置完毕: </p><ul><li>对服务器而言，应该在<code>listen()</code>调用之前设置</li><li>对客户机而言，应该在<code>connect()</code>调用之前设置</li></ul><p><strong>SO_REUSEADDR</strong></p><p>总体来说，该选项的作用就是<strong>地址复用</strong>，具体有以下四个功用:</p><ul><li><p>允许服务器绑定某个端口，即使该端口仍然正被用做本地地址使用</p><p>考虑以下情景:</p><ol><li>启动服务器</li><li>连接请求到达，派生一个子进程来处理该客户</li><li>监听服务器终止，但子进程继续为现有连接上的客户提供服务</li><li>重启监听服务器</li></ol><p>如果在未使用<strong>SO_REUSEADDR</strong>选项的情况下，步骤4中的<code>bind()</code>调用将会失败，因为该端口正在被使用，启动该选项后，即可正常绑定</p></li><li><p>允许在同一个端口上启动同一个服务器的多个实例</p><p><strong>IP别名</strong></p><p>将多个IP地址赋给多个物理接口的能力叫做<strong>IP别名</strong>, 第一个IP地址叫做<strong>别名(alias)<strong>或者</strong>逻辑接口</strong>, 通常别名地址和主IP地址具有相同的子网ID, 但是具有不同的主机ID</p><p>考虑以下情景:</p><ol><li>本地主机的主IP为<em>198.69.10.2</em>, 另外两个别名为<em>198.69.10.128</em>, <em>192.69.10.129</em></li><li>主机启动三个HTTP服务器， 第一个服务器以 **:80* 作为本地地址调用<code>bind()</code></li><li>第二个服务器以<em>198.69.10.128 : 80</em>作为本地地址调用<code>bind()</code></li><li>第三个服务器以<em>192.69.10.129</em>作为本地地址调用<code>bind()</code></li></ol><p>如果在未使用<strong>SO_REUSEADDR</strong>选项的情况下, 步骤3, 4将会失败， 启动该选项之后，即可正常绑定</p></li><li><p>允许单个进程绑定同一个端口到多个套接字(sockfd)之上，只要每次捆绑指定的IP地址不同即可</p></li><li><p>允许完全重复的捆绑，即IP地址与端口号均相同</p><p><strong>该特性仅支持UDP, 不支持TCP</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:基本UDP套接字</title>
    <link href="/2022/04/01/UNP-%E5%9F%BA%E6%9C%ACUDP%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <url>/2022/04/01/UNP-%E5%9F%BA%E6%9C%ACUDP%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<ul><li><p>UDP套接字API事件图</p><p><img src="1.png" alt="1"></p></li></ul><h3 id="1-recvfrom-sendto"><a href="#1-recvfrom-sendto" class="headerlink" title="1. recvfrom(), sendto()"></a>1. recvfrom(), sendto()</h3><p>这两个函数类似于标准的<code>read()</code>和<code>write()</code>函数，不过需要三个额外的参数</p><ul><li><p>recvfrom, sendto</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-comment">/* 接收信息函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvform</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">int</span> flag,</span></span><br><span class="hljs-params"><span class="hljs-function">                      struct sockaddr *from,<span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><span class="hljs-comment">/* 发送信息函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes, </span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">const</span> struct sockaddr *to,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>前三个参数等同于read和write的三个参数</p><p>描述符，<strong>指向读/写入缓冲区的指针</strong>和<strong>读/写字节数</strong></p></li><li><p><code>flag</code></p><p>设置相关参数</p></li><li><p><code>from</code></p><p>当<code>recvfrom()</code>在<code>sockfd</code>接受到数据时，<code>from</code>会存储数据发送者的套接字地址结构</p></li><li><p><code>to</code></p><p>欲发送一方的套接字地址结构</p></li><li><p><code>addrlen</code></p><ul><li><p>recvfrom</p><p>对于<code>recvfrom()</code>, <code>addrlen</code>是值-结果类型参数，传入时指代<code>from</code>的长度，传出时指代接收到数据后<code>from</code>被填充的字节大小</p></li><li><p>sendto</p><p><code>to</code>的长度</p></li></ul></li></ul></li></ul><h3 id="2-connect"><a href="#2-connect" class="headerlink" title="2. connect()"></a>2. connect()</h3><p>UDP中也可以使用<code>connect()</code>, 但是与TCP中使用的<code>connect()</code>效果完全不一样， UDP中的<code>connect()</code>完全是一个本地操作，不会发送任何数据给服务器，在进行基本的错误检查之后，<code>connect()</code>就会立即返回</p><ul><li><p>connect()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *servaddr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br>                                                    <span class="hljs-comment">// 返回：成功 0，失败 -1</span><br></code></pre></td></tr></table></figure><p>这里的<code>connect()</code>与TCP中的<code>connect()</code>是同一个函数</p></li></ul><p>与TCP一样，<code>connect()</code>调用完毕之后，套接字也从<strong>未连接UDP套接字</strong>变为了<strong>已连接UDP套接字</strong></p><p>已连接UDP套接字与未连接UDP套接字相比，发生了三个变化</p><ul><li><p>无法给输出操作指定目的IP地址和端口号:</p><p>具体来说就是API的限制:</p><ul><li>无法在<code>sendto()</code>中指定目的地址，第五个参数必须取空，第六个参数必须为0</li><li>作为<code>sendto()</code>的代替，改用<code>write()</code></li></ul></li><li><p>只能接受<code>connect()</code>指定目的地址的数据</p><p>这里同样不能使用<code>recvfrom()</code>, 只能使用<code>read()</code>, <code>recv()</code>, <code>recvmsg()</code>来代替</p><p>如果有来自其他地址(非<code>connect()</code>指定地址)的数据， 这些数据不会发送到该套接字</p></li><li><p>由已连接UDP套接字引发的异步错误会返回给它们所在的进程，未连接UDP套接字不接受任何异步错误</p></li></ul><p><strong>图例</strong></p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><p><strong>多次调用connect()</strong></p><p>多次调用<code>connect()</code>有两种用途</p><ul><li><p>指定新的IP地址和端口号</p></li><li><p>断开套接字</p><p>调用<code>connect()</code>时将套接字地址结构的地址族设置为<strong>AF_UNSPEC</strong>即可断开已连接(调用<code>connect()</code>)的UDP套接字</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[计算机自顶向下方法]:路由选择协议</title>
    <link href="/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-路由选择算法"><a href="#1-路由选择算法" class="headerlink" title="1.路由选择算法"></a>1.路由选择算法</h3><p>路由选择算法可以根据算法是集中式还是分散式来划分</p><ul><li><p>集中式路由选择算法</p><p>使用该算法时，需要已知所有节点的之间的连通性以及所有链路的开销，比如<strong>链路状态(Link State,LS)算法</strong></p></li><li><p>分散式路由选择算法</p><p>没有链路拥有所有链路开销的完整信息，路由器以迭代，分布式的方法计算出最低开销路径，比如<strong>距离向量(Distance Vector,DV算法</strong></p></li></ul><h4 id="1-链路状态路由选择算法-LS算法"><a href="#1-链路状态路由选择算法-LS算法" class="headerlink" title="1.链路状态路由选择算法(LS算法)"></a>1.链路状态路由选择算法(LS算法)</h4><p>以Dijkstra算法为链路状态算法的代表</p><p><strong>Dijkstra算法</strong></p><p>Dijkstra是一个典型的的贪心算法，通过保留目前为止所找到的每个顶点的最短路径来工作, 属于数据结构中的经典算法</p><p><img src="1.png" alt="1"></p><p>伪代码如下:</p><p><img src="2.png" alt="2"></p><p><strong>振荡问题</strong></p><p>由于各路由器可能同时进行LS算法，导致最短路径的计算结果不断振荡</p><p>例:</p><ul><li><p>节点D产生一个发往A的大小为1的流量，节点B也产生发往节点A的一个大小为1的流量,节点C产生一个大小为e的流量，流量的终点也是A,此时根据LS算法，各流量的方向如图</p><p><img src="3.png" alt="3"></p></li><li><p>LS算法再次运行，此时由于各路径上</p></li><li><p>的负载(开销)产生了变化，计算出不同的路径</p><p><img src="4.png" alt="4"></p></li><li><p>再一次进行LS算法</p><p><img src="5.png" alt="5"></p></li><li><p>再一次</p><p><img src="6.png" alt="6"></p></li></ul><p>这就是LS算法会产生的振荡过程，目前较好的解决方法是<strong>确保并非所有的路由器都同时进行LS算法</strong></p><h4 id="2-距离向量路由选择算法-DV算法"><a href="#2-距离向量路由选择算法-DV算法" class="headerlink" title="2.距离向量路由选择算法(DV算法)"></a>2.距离向量路由选择算法(DV算法)</h4><p>以Bellman-Ford算法为代表</p><p><strong>Bellman-Ford算法</strong></p><ul><li><p>Bellman-Ford方程</p><p>记$d_x(y)$​​是从节点x到节点y的最低开销路径的开销,$c(x,v)$代表x, v之间的开销，$v \in {x的所有邻居}$​​</p><p>==$d_x(y) = min_v {c(x,v)+d_v(y)}$==​</p></li><li><p>基本思想</p><p>记$N$为所有顶点的集合</p><p>每个节点从$D_x(y)$开始，对在$N$中的所有节点y, <strong>估计</strong>从x到y的最低开销路径的开销</p><p>注:DV算法采用的是拟合的思想，所以说是估计</p></li><li><p>具体过程</p><p>设计一个结点x的距离向量，为：<img src="https://private.codecogs.com/gif.latex?D_x=%20%5BD_x(y):%20y%20%5Cin%20N%20%5D" alt="7">。该向量是从x到N中所有其他结点y的费用估计的向量。使用DV算法，对每个结点维护以下路由选择信息：</p><ol><li>对每个邻居结点<code>v</code>，从<code>x</code>到相邻邻居v的费用为<code>c(x, v)</code></li><li>结点x的距离向量<code>Dx</code>，包含了<code>x</code>到<code>N</code>中所有目的地<code>y</code>的费用估计值</li><li>每个邻居的距离向量<code>Dv</code><br>接下来每个结点不时地向它的每个邻居发送它自身的距离向量副本</li></ol></li><li><p>当结点<code>x</code>从其它每一个邻居<code>v</code>接收到一个新距离向量的时候，它将保存<code>v</code>的距离向量，然后使用方程来更新自身的距离向量</p></li></ul><ul><li>如果自身的距离向量确实得到更新，更新完毕后，接下来将对每个邻居发送它的距离向量副本</li></ul><ul><li>最后当整个网络无更新报文发送，进入到静止状态时，收敛到最小路径</li></ul><p><img src="7.png" alt="7"></p><p><strong>无穷计数问题</strong></p><p>例如，存在这样一个网络：</p><p><img src="8.png" alt="8"></p><ul><li>某一时刻，Y检测到它到X的链路费用由4减少为1，于是它更新了自己的距离向量，并通知了Z</li><li>Z在收到Y的更新报文后，也更新了自己的距离向量（由5减为2），并向邻居们发送更新报文</li><li>而后，Y又收到了Z的更新报文，但它发现并没有改变自己的最低费用，于是保持不变</li><li>这样，仅仅经过了两次迭代网络就达到了静止。好消息通过网络得到了迅速传播</li></ul><p>但是，当链路费用增加（甚至断开）时，就不会这么简单了</p><p>我们看下面这个例子：</p><p><img src="9.png" alt="9"></p><ul><li>Y检测到它到X的路径费用由4增加到了60, 此时节点Z的距离向量为：d(X) = 5, d(Y) = 1, d(Z) = 0</li><li>由于Y保存了Z的距离向量副本，Y的距离向量更新为：d(x) = 5 + 1 = 6, d(Y) = 0, d(z) = 1，这个逻辑显然是错误的，因为Z到X的距离为5的前提是要经过Y，但Y更新后的路径又要经过Z，这就形成了一个<strong>选路环路（routing-loop）问题</strong></li><li>因为Y的距离向量更新了（虽然是错误的），但它还是向Z发送了更新报文</li><li>Z收到更新报文后，比较了下邻居们到X的距离，发现经过Y的路径距离为1 + 6 = 7，小于直接到X的距离，于是Z也更新的自己的距离向量为: d(x) = 7, d(y) = 1, d(z) = 0, 到<code>x</code>的距离的值相对于之前只上升了1, 然后又将更新后的距离向量发给Y</li><li>Y收到后又更新向量为8，然后再发给Z。。。</li><li>这样循环往复，更新报文在Y和Z之间传来传去，直到第44次迭代后，Z算出它经由Y的路径费用大于50为止。此时，Z最终确定到X的最短路径费用是直接到达X的费用50，而Y也得到了最短路径是经Z到X的费用51。</li></ul><p>可以看出，虽然最后还是得到了正确的信息（最后的50和51是正确的！），但坏消息的传播与好消息相比实在是慢太多了！而且，如果X和Y之间的费用为10000，Z和X的费用是9999时，就会出现<strong>无穷计数（count-to-infinity）问题</strong></p><h5 id="3-LS与DV算法的比较"><a href="#3-LS与DV算法的比较" class="headerlink" title="3.LS与DV算法的比较"></a>3.LS与DV算法的比较</h5><ul><li>DV 算法中，每个节点只需要维护自身的距离向量，且只需要与自己相连的链路的状态；而 LS 算法中每个节点都需要知道所有链路的状态；</li><li>DV 算法中每个节点只需要把自己的信息传给相邻节点；而 LS 算法中每个节点都需要在网络中广播自己的信息，以实现网络中每个节点都保存有整个网络完整的拓扑信息；</li><li>DV 算法可以是异步的，也即不要求节点之前同步，当邻居节点信息有变时完全可以再执行以此迭代，即可更新信息；而 LS 则要求全局信息已知，也就要求所有节点的信息都是正确的；</li></ul><h3 id="2-AS"><a href="#2-AS" class="headerlink" title="2. AS"></a>2. AS</h3><p><strong>什么是AS</strong></p><ul><li>AS，**(Autonomous System,自治系统)<strong>,是指统一使用内部路由协议(OSPF, RIP)的</strong>一组网络**</li><li>一个自治系统由全球唯一的AS号(ASN)进行标识,由ICANN区域注册所分配</li></ul><h3 id="3-AS内部路由选择"><a href="#3-AS内部路由选择" class="headerlink" title="3. AS内部路由选择"></a>3. AS内部路由选择</h3><p>AS内部的路由选择协议这里介绍两种</p><h4 id="1-RIP"><a href="#1-RIP" class="headerlink" title="1. RIP"></a>1. RIP</h4><p>RIP 协议是分布式的<strong>基于 DV 算法</strong>的路由选择协议，下面我们分析一下 RIP 协议在 DV 算法的基础上提出怎样的封装</p><ul><li><p>距离</p><p> RIP 协议中的距离得到了定义，从一路由器到直接连接的网络的距离定义为 1，到非直接连接的网络距离定义为所经过的路由器数量加 1。由于这个定义，RIP 协议的“距离”也称之为“<strong>跳数</strong>”。</p></li></ul><p><strong>最大度量</strong></p><p>对于<strong>无穷计数问题</strong>，RIP 协议提供了解法——<strong>定义最大度量</strong></p><p>RIP 协议允许一条路径最多只能包含 15 个服务器，若距离等于或大于 16 时将直接不可达。出现无穷计数时，路由器之间相互传播错误的信息会使最短距离增长到 16，这就到达了最大度量，就可以规避故障链路了。<br>但是这也引发了新的问题，要是 2 个路由器之间的距离本身就超过 16 呢？这没有办法，也会被认为是不可达的，<strong>因此 RIP 协议无法适用于较大的互联网</strong></p><p><strong>周期性广播</strong></p><p>路由器之间将<strong>按照固定的时间间隔</strong>交换路由信息，同时当网络拓扑发生变化时也会及时通告拓扑变化之后的路由信息</p><p><strong>报文头</strong></p><p><img src="10.png" alt="10"></p><h4 id="2-OSPF"><a href="#2-OSPF" class="headerlink" title="2. OSPF"></a>2. OSPF</h4><p><strong>开放最短路径优先(OSPF)</strong> 协议被广泛用于因特网 AS 内部路由选择，开放指的是路由选择协议规范是公众可用的，而并非属于某一厂家OSPF 协议是一种<strong>链路状态协议</strong>，它使用洪泛链路状态信息和 Dijkstra 算法实现，下面看一些 OSPF 协议的具体实现方式：</p><p><strong>链路状态数据库</strong></p><p>运载 OSPF 协议的所有路由器最终会建立一个<strong>链路状态数据库</strong>，这个数据库包含 3 张表来协同工作：</p><ol><li>邻居表：邻居表之间通过问候报文联系，确认相邻拓扑是否正常；</li><li>链路状态表：通过交换邻居表，形成完整的网络拓扑图，该表在 AS 内的所有路由器是一致的；</li><li>计算路由表：运载 Dijkstra 算法，获得最佳路径。</li></ol><p>接下来我们来看一下路由器和邻居之间，是怎么通过这 3 张表进行工作的。<br><img src="11.png" alt="11"></p><p><strong>泛洪法</strong></p><p>由于需要让所有的路由器得到自己的路由信息，因此需要向 AS 内的所有相邻路由器发送信息。实现这个功能的是<strong>洪泛法</strong>，路由器通过所有输出端口向相邻路由器发送信息，而每一个相邻路由器再把信息发送给相邻的路由器，最终 AS 内的所有路由器都会得到这个路由信息。<br>同时 OSPF 协议的洪泛法是可靠的，因为对于任何路由器，收到其他路由器发来的分组之后需要发送 <strong>ACK</strong>，这就可以保证路由信息的传递正确。<br><img src="12.png" alt="12"></p><p><strong>触发式更新</strong></p><p>路由表的更新并非是周期性的，而是当<strong>链路状态发生变化</strong>时，路由器才向所有的路由器使用洪泛法发送信息。由于这种方式，使得链路状态表更新很快，使得最低开销路径的收敛速度加快，同时也可以保证 AS 内的所有路由器的链路状态表一致</p><p><strong>报文段</strong></p><p><img src="13.png" alt="13"></p><ol><li>Hello：发现、维持邻居路由器的可达性；</li><li>数据库描述：向邻居给出自己的链路状态数据库中，所有链路状态项目的摘要信息；</li><li>链路状态请求：向邻居请求发送某些链路状态的详细信息；</li><li>链路状态更新：使用洪泛法对全网更新链路状态；</li><li>ACK：对更新分组的确认。</li></ol><p><strong>运输层协议</strong></p><p>OSPF 报文由 IP 协议承载，而不是使用 UDP 协议，此时的 IP 数据报的协议字段为 89。OSPF 报文的篇幅很小，这就可以加快数据报的传输速度</p><h3 id="4-AS间路由选择"><a href="#4-AS间路由选择" class="headerlink" title="4. AS间路由选择"></a>4. AS间路由选择</h3><p><strong>BGP 的作用</strong></p><p>BGP的主要目标是为处于不同AS中的路由器之间进行路由信息通信提供保障<br>对于一个 AS 和 AS 内的某一个路由器，在路由器中有一个转发表，用于选择和确定分组在路由器的输出链路。对于分组需要发送到 AS 之外时，BGP 提供的并不是特定的目的地址，而是提供了一个通过 CIDR 得到的<strong>网络前缀</strong>，这个网络前缀能够标志一个子网或一个子网的集合</p><p>概括起来，BGP 的作用是：<strong>容许子网向路由器其余部分通告它的存在</strong></p><p><strong>BGP 的任务</strong></p><p>BGP 对于每一台路由器来说，需要完成 2 个任务：</p><ol><li>从临近的 AS 获得前缀可达性信息：BGP 允许每个子网向因特网的其他部分告知自己的存在，同时 BGP 确保在因特网中所有的 AS 都知道该子网；</li><li>确定到达子网的最佳路由：路由器将在本地允许 BGP 路由选择过程，此时 BGP 协议需要基于网络前缀的可达性信息，向路由器提供最佳路由</li></ol><p><strong>BGP 路由信息</strong></p><ul><li><p>AS间通信</p><p>首先考虑简单的情况，将整个 AS 看做一个整体，假设现在需要向所有路由器通告 3d 的可达性信息。首先 AS3 向 AS2 发送 BGP 报文，告知 3d 为与 AS3 中，接着 AS2 向 AS1 发送 BGP 报文告知 AS1 可以通过 AS2 访问 3d。通过这种我们熟悉的交互方式，就可以使所有 AS 知晓 3d 的存在并得到路径</p><p><img src="14.png" alt="14"></p></li><li><p>实现</p><ul><li><p>IBGP与EBGP</p><p><strong>内部路由器与网关路由器</strong></p><p>对于每个 AS，每台路由器只有 2 种情况，即<strong>内部路由器</strong>或<strong>网关路由器</strong>，其中内部路由器仅链接在 AS 中的主机和路由器, 网关路由器位于 AS 边缘，通过链路连接其他的 AS 的网关路由器</p><p>在 BGP 中，每对路由器都是使用 179 端口的 TCP 连接交换路由信息，每条连接及其通过连接的报文被称之为 <strong>BGP 连接</strong>。由于 BGP 连接可能是 AS 内的，也可能存在于 AS 间，因此我们把跨越 2 个 AS 的 BGP 连接称之为**外部 BGP(eBGP)<strong>，相同 AS 中的两台路由器间的 BGP 连接称之为</strong>内部 BGP(iBGP)**连接</p><p>如图就给出了网关路由器、eBGP 和 iBGP 的示意，注意 iBGP 连接并不一定要与物理链路对应。<br><img src="15.png" alt="15"></p></li></ul></li></ul><p><strong>BGP 属性</strong></p><p>BGP 连接通告前缀时，前缀及其属性被称之为路由，前缀中包含一些称之为“属性”的信息。我们着重关注 2 个重要的属性：</p><ol><li><strong>AS-PATH</strong>：包含前缀通告所经过的 AS 序列，例如在上文中的 “AS2 AS3”。同时这个属性还可以用于检测和防止通告环路，尤其是路由器在该属性中发现包含了自己所在的 AS，这种通告会被直接拒绝；</li><li><strong>NEXT-HOP</strong>：即下一跳，这个属性表示的是 AS-PATH 起始路由器接口的 IP 地址。</li></ol><p>有了这 2 个属性，对于一条 BGP 路由就包含了 3 个重要的组件：AS-PATH、NEXT-HOP 和目的前缀</p><p><strong>热土豆路由选择</strong></p><p>BGP 路由选择的原理是<strong>热土豆路由选择</strong>，即从所有路由中选择到开始该路由的 NEXT-HOP 路由器具有的最小开销作为学习的信息。通过热土豆路由选择添加 AS 外前缀的步骤如图所示，当 路由表学习可达性信息时，<strong>BGP 协议和 AS 内路由选择协议(OSPF 协议)需要协同工作</strong>。<br><img src="16.png" alt="16"><br>热土豆路由选择的思想是：<strong>将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS</strong></p><p>之所以称之为热土豆，就是当分组被类比为“热土豆”时，由于烫手，所以我们要尽可能快地把“热土豆”扔给下一个人。因此热土豆路由选择是一种自私的算法，它只考虑到减小自己 AS 内传输分组的开销，但是忽略了 AS 外端到端的其他开销<br><img src="17.png" alt="17"></p><p><strong>路由选择算法</strong></p><p>BGP 路由选择的原理是热土豆路由选择，下面就看一下 BGP 实际使用的路由选择算法。首先如果只有一条路由，则 BGP 只能选择这条路由进行传输。当存在多条路由时，按照下面的消除规则，直到剩下一条路由：</p><ol><li>比较<strong>本地偏好</strong>：路由会拥有一个本地偏好属性，该属性的值是一种策略性决定，它取决于 AS 的网络管理员。本地偏好信息可能从该路由器设置，或者相同 AS 中的其他路由器学习到，拥有较高本地偏好的路由会被选择；</li><li>选择最短 <strong>AS-PATH</strong>：值得一提的是若 BGP 只使用这个规则来选择路由的话， BGP 会使用 DV 算法来决定路径，此时度量路径的是 AS 的跳数；</li><li>使用<strong>热土豆路由选择</strong>：选择具有最靠近 NEXT-HOP 路由器的路由；</li><li>如果仍然剩下多条路由，参考 BGP 标识符选择。</li></ol><p>通过这种算法，BGP 的路由选择可以考虑到尽可能低的开销，而不是自私的路由选择</p><ul><li>参考: <a href="https://www.cnblogs.com/linfangnan/p/13031627.html">https://www.cnblogs.com/linfangnan/p/13031627.html</a></li><li>参考: <a href="https://www.cnblogs.com/linfangnan/p/13036026.html">https://www.cnblogs.com/linfangnan/p/13036026.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:TCP客户服务器_IO复用</title>
    <link href="/2022/03/30/UNP-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8-IO%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/03/30/UNP-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8-IO%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-select版本"><a href="#1-select版本" class="headerlink" title="1. select版本"></a>1. select版本</h3><ul><li><p>服务器端IO复用</p><p>服务器端IO复用的基本思想就是使用一个数据结构来维护客户于套接字描述符的映射关系，每当有一个客户建立连接时，就通过<code>accept()</code>为其分配一个以连接文件描述符，在本地数据结构中添加一个映射条目，每当断开一个客户连接时，就回收该文件描述符，在本地的数据结构中移除该条目</p><p>UNP中采用了一个数据<code>client[]</code>和一个集合<code>rest</code>来表示这样的映射关系, <code>client[n]</code>表示客户n对应的套接字描述符</p><p><img src="1.png" alt="1"></p></li><li><p>str_cli()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">str_cli</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>maxfdp1, stdineof;<br>fd_setrset;<br><span class="hljs-keyword">char</span>buf[MAXLINE];<br><span class="hljs-keyword">int</span>    n;<br><br>stdineof = <span class="hljs-number">0</span>;<br>FD_ZERO(&amp;rset);<br><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br><span class="hljs-keyword">if</span> (stdineof == <span class="hljs-number">0</span>)<br>FD_SET(fileno(fp), &amp;rset);<br>FD_SET(sockfd, &amp;rset);<br>maxfdp1 = max(fileno(fp), sockfd) + <span class="hljs-number">1</span>;<br>Select(maxfdp1, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);             <span class="hljs-comment">// 用户监听STDIN, sockfd两个描述符</span><br><br><span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;       <span class="hljs-comment">// Socket 描述符可读</span><br><span class="hljs-keyword">if</span> ( (n = Read(sockfd, buf, MAXLINE)) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (stdineof == <span class="hljs-number">1</span>)                    <span class="hljs-comment">// 表明用户主动关闭</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span>                                          <span class="hljs-comment">// 异常关闭</span><br>err_quit(<span class="hljs-string">&quot;str_cli: server terminated prematurely&quot;</span>);<br>&#125;<br><br>Write(fileno(<span class="hljs-built_in">stdout</span>), buf, n);                    <span class="hljs-comment">// 回显在终端上</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;                    <span class="hljs-comment">// STDIN可读</span><br><span class="hljs-keyword">if</span> ( (n = Read(fileno(fp), buf, MAXLINE)) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 读取到EOF</span><br>stdineof = <span class="hljs-number">1</span>;<br>Shutdown(sockfd, SHUT_WR);                  <span class="hljs-comment">// 发送FIN</span><br>FD_CLR(fileno(fp), &amp;rset);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>Writen(sockfd, buf, n);                           <span class="hljs-comment">// 向服务端发送</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端主函数代码与迭代版本一样， 只是更改了<code>str_cli()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> sockfd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br>        <br>        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>            err_quit(<span class="hljs-string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);<br>        <br>        sockfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>        <br>        bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;<br>        servaddr.sin_port = htons(SERV_PORT);<br>        Inet_pton(AF_INET, argv[<span class="hljs-number">1</span>], &amp;servaddr.sin_addr);<br>        <br>        Connect(sockfd, (SA *) &amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>        <br>        str_cli(<span class="hljs-built_in">stdin</span>, sockfd); <span class="hljs-comment">/*do it all*/</span><br>        <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include fig01 */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>i, maxi, maxfd, listenfd, connfd, sockfd;<br><span class="hljs-keyword">int</span>nready, client[FD_SETSIZE];<br><span class="hljs-keyword">ssize_t</span>n;<br>fd_setrset, allset;<br><span class="hljs-keyword">char</span>buf[MAXLINE];<br><span class="hljs-keyword">socklen_t</span>clilen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span><span class="hljs-title">cliaddr</span>, <span class="hljs-title">servaddr</span>;</span><br><br>listenfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>servaddr.sin_family      = AF_INET;<br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<br>servaddr.sin_port        = htons(SERV_PORT);<br><br>Bind(listenfd, (SA *) &amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br><br>Listen(listenfd, LISTENQ);<br><br>maxfd = listenfd;<span class="hljs-comment">/* initialize */</span><br>maxi = <span class="hljs-number">-1</span>;<span class="hljs-comment">/* index into client[] array */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++)<br>client[i] = <span class="hljs-number">-1</span>;<span class="hljs-comment">/* -1 indicates available entry */</span><br>FD_ZERO(&amp;allset);<br>FD_SET(listenfd, &amp;allset);<br><span class="hljs-comment">/* end fig01 */</span><br><br><span class="hljs-comment">/* include fig02 */</span><br><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>rset = allset;<span class="hljs-comment">/* structure assignment */</span><br>nready = Select(maxfd+<span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;<span class="hljs-comment">/* new client connection */</span><br>clilen = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span>NOTDEF</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client: %s, port %dn&quot;</span>,<br>Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, <span class="hljs-number">4</span>, <span class="hljs-literal">NULL</span>),<br>ntohs(cliaddr.sin_port));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++)<br><span class="hljs-keyword">if</span> (client[i] &lt; <span class="hljs-number">0</span>) &#123;<br>client[i] = connfd;<span class="hljs-comment">/* save descriptor */</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i == FD_SETSIZE)<br>err_quit(<span class="hljs-string">&quot;too many clients&quot;</span>);<br><br>FD_SET(connfd, &amp;allset);<span class="hljs-comment">/* add new descriptor to set */</span><br><span class="hljs-keyword">if</span> (connfd &gt; maxfd)<br>maxfd = connfd;<span class="hljs-comment">/* for select */</span><br><span class="hljs-keyword">if</span> (i &gt; maxi)<br>maxi = i;<span class="hljs-comment">/* max index in client[] array */</span><br><br><span class="hljs-keyword">if</span> (--nready &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* no more readable descriptors */</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= maxi; i++) &#123;<span class="hljs-comment">/* check all clients for data */</span><br><span class="hljs-keyword">if</span> ( (sockfd = client[i]) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;<br><span class="hljs-keyword">if</span> ( (n = Read(sockfd, buf, MAXLINE)) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/*connection closed by client */</span><br>Close(sockfd);<br>FD_CLR(sockfd, &amp;allset);<br>client[i] = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-keyword">else</span><br>Writen(sockfd, buf, n);<br><br><span class="hljs-keyword">if</span> (--nready &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">/* no more readable descriptors */</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* end fig02 */</span><br></code></pre></td></tr></table></figure><h3 id="2-poll版本"><a href="#2-poll版本" class="headerlink" title="2. poll版本"></a>2. poll版本</h3><p><code>poll()</code>版本则不需要维护复杂的数据结构，只需要分配一个<code>pollfd</code>数组即可</p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include fig01 */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;</span> <span class="hljs-comment">/* for OPEN_MAX */</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i, maxi, listenfd, connfd, sockfd;<br>  <span class="hljs-keyword">int</span> nready;<br>  <span class="hljs-keyword">ssize_t</span> n;<br>  <span class="hljs-keyword">char</span> buf[MAXLINE];<br>  <span class="hljs-keyword">socklen_t</span> clilen;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">client</span>[<span class="hljs-title">FOPEN_MAX</span>];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>, <span class="hljs-title">servaddr</span>;</span><br><br>  listenfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>  bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>  servaddr.sin_family = AF_INET;<br>  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<br>  servaddr.sin_port = htons(SERV_PORT);<br><br>  Bind(listenfd, (SA *)&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br><br>  Listen(listenfd, LISTENQ);<br><br>  client[<span class="hljs-number">0</span>].fd = listenfd;<br>  client[<span class="hljs-number">0</span>].events = POLLRDNORM;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; FOPEN_MAX; i++)<br>    client[i].fd = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* -1 indicates available entry */</span><br>  maxi = <span class="hljs-number">0</span>;            <span class="hljs-comment">/* max index into client[] array */</span><br>                       <span class="hljs-comment">/* end fig01 */</span><br><br>  <span class="hljs-comment">/* include fig02 */</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    nready = Poll(client, maxi + <span class="hljs-number">1</span>, INFTIM);<br><br>    <span class="hljs-keyword">if</span> (client[<span class="hljs-number">0</span>].revents &amp; POLLRDNORM) &#123; <span class="hljs-comment">/* new client connection */</span><br>      clilen = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>      connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NOTDEF</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new client: %sn&quot;</span>, Sock_ntop((SA *)&amp;cliaddr, clilen));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; FOPEN_MAX; i++)<br>        <span class="hljs-keyword">if</span> (client[i].fd &lt; <span class="hljs-number">0</span>) &#123;<br>          client[i].fd = connfd; <span class="hljs-comment">/* save descriptor */</span><br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">if</span> (i == FOPEN_MAX)<br>        err_quit(<span class="hljs-string">&quot;too many clients&quot;</span>);<br><br>      client[i].events = POLLRDNORM;<br>      <span class="hljs-keyword">if</span> (i &gt; maxi)<br>        maxi = i; <span class="hljs-comment">/* max index in client[] array */</span><br><br>      <span class="hljs-keyword">if</span> (--nready &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* no more readable descriptors */</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= maxi; i++) &#123; <span class="hljs-comment">/* check all clients for data */</span><br>      <span class="hljs-keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;<br>        <span class="hljs-keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (errno == ECONNRESET) &#123;<br>            <span class="hljs-comment">/*4connection reset by client */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NOTDEF</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] aborted connectionn&quot;</span>, i);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            Close(sockfd);<br>            client[i].fd = <span class="hljs-number">-1</span>;<br>          &#125; <span class="hljs-keyword">else</span><br>            err_sys(<span class="hljs-string">&quot;read error&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">/*4connection closed by client */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NOTDEF</span><br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] closed connectionn&quot;</span>, i);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>          Close(sockfd);<br>          client[i].fd = <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>          Writen(sockfd, buf, n);<br><br>        <span class="hljs-keyword">if</span> (--nready &lt;= <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* no more readable descriptors */</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* end fig02 */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:IO复用_select_poll</title>
    <link href="/2022/03/30/UNP-IO%E5%A4%8D%E7%94%A8-select-poll/"/>
    <url>/2022/03/30/UNP-IO%E5%A4%8D%E7%94%A8-select-poll/</url>
    
    <content type="html"><![CDATA[<ul><li><p>为什么使用IO复用</p><p>在之前的服务器关闭场景中，如果服务器主动关闭，会导致服务器发送<code>FIN</code>报文段给客户端，但是如果客户此时正阻塞于</p><p><code>Fgets()</code>, 即客户正尝试从标准输入中读取数据，那么客户将忽略该<code>FIN</code>报文段，直到其解除阻塞，读取<code>sockfd</code>为止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">`<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">str_cli</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>    sendline[MAXLINE], recvline[MAXLINE];<br>    <br>    <span class="hljs-keyword">while</span>(Fgets(sendline, NAXLINE, fp) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Writen(sockfd, sendline, <span class="hljs-built_in">strlen</span>(sendline));<br>        <br>        <span class="hljs-keyword">if</span>(Readline(sockfd, recvline, MALINE) == <span class="hljs-number">0</span>)<br>            err_quit(<span class="hljs-string">&quot;str_cli: server terminated prematurely&quot;</span>);<br>        Fputs(recvline, <span class="hljs-built_in">stdout</span>);<br>        <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在某些情况下，这是无法忍受的, IO多路复用提供了这样一种能力: </p><p><strong>可以提前给进程指定多个I/O条件，当这些条件都不满足时，进程阻塞, 当这些条件中的某一个满足时，进程从阻塞中返回</strong></p></li></ul><h3 id="1-select"><a href="#1-select" class="headerlink" title="1. select()"></a>1. select()</h3><p><code>select()</code>函数可以在一段指定的时间内，监听用户感兴趣的文件描述符的可读、可写及异常事件，如果没有条件满足，进程将会阻塞在</p><p><code>select()</code>函数</p><ul><li><p>select()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, </span></span><br><span class="hljs-params"><span class="hljs-function">                  fd_set *exceptset,<span class="hljs-keyword">const</span> struct timeval *timeout)</span></span><br><span class="hljs-function">                    <span class="hljs-comment">// 返回值：就绪描述符的数目，超时返回0，出错返回-1</span></span><br></code></pre></td></tr></table></figure><ul><li><p>timeout</p><p>告知内核可以等待的最长时间, <code>timeval</code>的结构如下:</p><ul><li><p>timeval</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><br>    <span class="hljs-keyword">long</span> tv_sec;    <span class="hljs-comment">// 秒</span><br>    <span class="hljs-keyword">long</span> tv_usec;   <span class="hljs-comment">// 微秒</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>timeout</code>的取值有三种可能:</p><ol><li><p>NULL</p><p>此时如果没有条件满足，进程将用于阻塞下去</p></li><li><p><code>timeout.tv_sec != 0 || timeout.tv_sec != 0</code></p><p>此时进程会等待一个固定时间，如果到了时间还没有任何条件满足，那么将会返回0</p></li><li><p><code>timeout.tv_sec == 0 &amp;&amp; timeout.tv_usec == 0</code></p><p>此时<code>select()</code>调用会直接返回，不阻塞，这被称为<strong>轮询(poiling)</strong></p></li></ol></li><li><p>readset</p><p>读描述符集合，当集合中的任意一个描述符满足读条件时，就返回</p></li><li><p>writeset</p><p>写描述符集合，当集合中的任意一个描述符满足写条件时，就返回</p></li><li><p>exceptset</p><p>异常描述符集合，当集合中的任意一个描述符有异常条件待处理时，就返回</p></li></ul><blockquote><p> 描述符集合的数据结构是<code>fd_set</code>,  UNP中没有给出其具体结构，但是给出了其中的一种可能实现:<br> <code>fd_set</code>是一个整数数组，每一位代表了一个描述符, 假设第一个元素有8位，那么其就可以表示描述符<code>0~7</code></p><p> 使用以下宏可以对<code>fd_set</code>结构进行操作:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *fdset)</span></span>;             <span class="hljs-comment">//清除set的所有位  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, fd_set *fdset)</span></span>;      <span class="hljs-comment">//设置set的第fd位  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, fd_set *fdset)</span></span>;      <span class="hljs-comment">//清除set的第fd位  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, fd_set *fdset)</span></span>;    <span class="hljs-comment">//测试set的第fd为是否被设置 </span><br></code></pre></td></tr></table></figure></blockquote><p><strong>这三个参数都是值-结果类型参数</strong>，当传入时，表示<code>select</code>函数会检查哪些描述符，当传出是，<code>fd_set</code>是这样一种结构:</p><p>若其中的某一位为1，表示该位锁代表的描述符准备就绪，其余为准备就绪的位都会被置为0</p><ul><li><p>maxfdp1</p><p>表示待测试的描述符的个数，通常就是传入的<code>最大描述符 + 1</code></p></li></ul></li></ul><p><strong>描述符就绪条件</strong></p><p><img src="1.png" alt="1"></p><h3 id="2-shutdown"><a href="#2-shutdown" class="headerlink" title="2. shutdown()"></a>2. shutdown()</h3><p><code>shutdown()</code>函数与<code>close()</code>相似，都是用于关闭网络连接，不过它们之间有着较大差异:</p><ol><li><code>shutdown()</code>可以单向关闭，<code>close()</code>只能双向关闭</li><li><code>shutdown()</code>会立即发送<code>FIN</code>, <code>close()</code>只会减少套接字引用计数，等到引用计数为0时才会发送<code>FIN</code></li></ol><ul><li><p>shutdown()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> howto)</span></span>;<br>                       <span class="hljs-comment">// 返回：成功 0，失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>待关闭套接字</p></li><li><p>howto</p><p>指定关闭的方式，有三种取值</p><ul><li><p>SHUT_RD</p><p>关闭读取通道，套接字接受缓冲区中的数据都将被丢弃，此后进程不能够再对该套接字调用读函数</p></li><li><p>SHUT_WR</p><p>关闭写入通道，这被称为<strong>半关闭</strong>，发送缓冲区的数据将被全部发送，紧接着发送<strong>FIN</strong>报文，进程不能够再对该套接字调用任何写函数</p></li><li><p>SHUT_RDWR</p><p>相当于调用一次SHUT_RD然后调用一次SHUT_WR</p></li></ul></li></ul></li></ul><h3 id="3-pselect"><a href="#3-pselect" class="headerlink" title="3. pselect()"></a>3. pselect()</h3><p><code>pselect()</code>实现的功能为：在被调用时，先以给定信号集合作为当前的信号掩码，在调用完成时，再将信号掩码恢复</p><ul><li><p>pselect()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pselect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset,</span></span><br><span class="hljs-params"><span class="hljs-function">               fd_set *execptset, <span class="hljs-keyword">const</span> struct timespec *timeout,<span class="hljs-keyword">const</span> <span class="hljs-keyword">sigset_t</span> *sigmask)</span></span><br><span class="hljs-function">                                                    <span class="hljs-comment">// 返回值：就绪描述符的数目，超时返回0，出错返回-1</span></span><br></code></pre></td></tr></table></figure><ul><li><p>maxfdp1</p><p>最大描述符 + 1</p></li><li><p>readset, writeset, execptset</p><p>读，写，异常描述符集合</p></li><li><p>timeout</p><p>超时事件</p></li><li><p>sigmask</p><p>调用<code>pselect()</code>时设置的的掩码</p></li></ul></li></ul><h3 id="4-poll"><a href="#4-poll" class="headerlink" title="4. poll()"></a>4. poll()</h3><p><code>poll()</code>提供的功能与<code>select()</code>类似，但是在处理流设备时，能够提供额外的信息</p><ul><li><p>poll</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(struct pollfd *fdarray, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br>                                                           <span class="hljs-comment">// 返回值：就绪描述符的数目，超时返回0，出错返回-1</span><br></code></pre></td></tr></table></figure><ul><li><p>fdarray</p><p>描述符数组，每一个条目都是一个<code>pollfd</code>结构</p><ul><li><p>pollfd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span>&#123;</span><br>    <span class="hljs-keyword">int</span> fd;           <span class="hljs-comment">/* 确认描述符 */</span><br>    <span class="hljs-keyword">short</span> events      <span class="hljs-comment">/* 测试条件 */</span><br>    <span class="hljs-keyword">short</span> revents     <span class="hljs-comment">/* 返回状态 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>events</code>与<code>revents</code>分别是测试条件与返回的状态</p><ul><li>在<code>select()</code>当中，使用<strong>读，写，异常</strong>将描述符集合分类，如果描述符满足了相应条件，就将<code>set</code>当中指定的位数置为1</li><li>而在<code>poll()</code>当中，则是给每个描述符一个测试条件，用于表示<strong>读，写，异常</strong>这些类型，当从<code>poll()</code>调用中返回时，从<code>revents</code>的值可以看出这些描述符的返回状态</li></ul></li><li><p>events与revents取值表</p><p><img src="2.png" alt="2"></p><blockquote><p>poll()为流设备提供了额外信息，体现在上面的数据类型上，poll()可以识别三类数据:</p><ol><li>普通</li><li>优先级带</li><li>高优先级</li></ol></blockquote></li></ul></li><li><p>timeout</p><p>超时时间， 可取值如下</p><p><img src="3.png" alt="3"></p></li></ul></li></ul><p>注: <code>poll()</code>函数会忽略<code>fd &lt; 0</code>的描述符</p>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:TCP客户服务器_迭代式</title>
    <link href="/2022/03/30/UNP-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%BC%8F/"/>
    <url>/2022/03/30/UNP-TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>编写一个完整的 TCP 客户端/服务器程序：</p><ol><li>客户从标准输入读入一行文本，并写给服务器</li><li>服务器从网络输入读入这行文本，并回射给客户</li><li>客户从网络输入读入这行回射文本，并显示在标准输出上</li></ol><h3 id="1-函数准备"><a href="#1-函数准备" class="headerlink" title="1. 函数准备"></a>1. 函数准备</h3><h4 id="1-TCP-回射服务器程序"><a href="#1-TCP-回射服务器程序" class="headerlink" title="1. TCP 回射服务器程序"></a>1. TCP 回射服务器程序</h4><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> “unp.h”</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">str_echo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> n;<br>    <span class="hljs-keyword">char</span>    buf[MAXLINE];<br>    <br>again:<br>    <span class="hljs-keyword">while</span>((n = read(sockfd, buf, MAXLINE)) &gt; <span class="hljs-number">0</span>)<br>        Writen(sockfd, buf, n);<br>    <br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR) <span class="hljs-comment">// 被中断后继续执行</span><br>        <span class="hljs-keyword">goto</span> again;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)<br>        err_sys(<span class="hljs-string">&quot;str_echo: read error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-TCP-回射客户端程序"><a href="#2-TCP-回射客户端程序" class="headerlink" title="2. TCP 回射客户端程序"></a>2. TCP 回射客户端程序</h4><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">str_cli</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">int</span> sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>    sendline[MAXLINE], recvline[MAXLINE];<br>    <br>    <span class="hljs-keyword">while</span>(Fgets(sendline, NAXLINE, fp) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        Writen(sockfd, sendline, <span class="hljs-built_in">strlen</span>(sendline));<br>        <br>        <span class="hljs-keyword">if</span>(Readline(sockfd, recvline, MALINE) == <span class="hljs-number">0</span>)<br>            err_quit(<span class="hljs-string">&quot;str_cli: server terminated prematurely&quot;</span>);<br>        Fputs(recvline, <span class="hljs-built_in">stdout</span>);<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="1-TCP客户端"><a href="#1-TCP客户端" class="headerlink" title="1. TCP客户端"></a>1. <strong>TCP客户端</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> sockfd;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br>        <br>        <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>            err_quit(<span class="hljs-string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);<br>        <br>        sockfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>        <br>        bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;<br>        servaddr.sin_port = htons(SERV_PORT);<br>        Inet_pton(AF_INET, argv[<span class="hljs-number">1</span>], &amp;servaddr.sin_addr);<br>        <br>        Connect(sockfd, (SA *) &amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>        <br>        str_cli(<span class="hljs-built_in">stdin</span>, sockfd); <span class="hljs-comment">/*do it all*/</span><br>        <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-TCP服务端"><a href="#2-TCP服务端" class="headerlink" title="2. TCP服务端"></a>2. <strong>TCP服务端</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> listenfd, connfd;<br>    <span class="hljs-keyword">pid_t</span> childpid;<br>    <span class="hljs-keyword">socklen_t</span> clilen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>, <span class="hljs-title">servaddr</span>;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_chld</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>    <br>    listenfd = Socket(AF_INET, SOCK_STREAN, <span class="hljs-number">0</span>);<br>    <br>    bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    servaddr.sin_port = htons(SERV_PORT);<br>    <br>    Bind(listenfd, (SA *)&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>    <br>    Listen(listenfd, LISTENQ);<br>    <br>    Signal(SIGCHLD, sig_chld);  <span class="hljs-comment">/*必须调用 waitpid() 回收僵尸进程*/</span><br>    <br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        chilen = <span class="hljs-keyword">sizeof</span>(chiaddr);<br>        <span class="hljs-keyword">if</span>((connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(errno == EINTR)  <span class="hljs-comment">// 被中断重新调用</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                err_sys(<span class="hljs-string">&quot;accept error&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>((childpid = Fork()) == <span class="hljs-number">0</span>)<span class="hljs-comment">/* 子进程*/</span><br>        &#123;<br>            Close(lisenfd); <span class="hljs-comment">/*关闭监听套接字*/</span> <span class="hljs-comment">// 关闭后面没用的套接字</span><br>            str_echo(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        Close(connfd);  <span class="hljs-comment">/*必须关闭 不然一直占用描述符*/</span><br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">/**********************************************************************************/</span><br><span class="hljs-comment">// 回收子进程 避免产生僵尸进程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_chld</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> stat;<br>    <br>    <span class="hljs-keyword">while</span>( (pid = waitpid(<span class="hljs-number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// WNOHANG 不阻塞</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated\n&quot;</span>, pid);<br>        <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3. 问题分析"></a>3. <strong>问题分析</strong></h3><p><strong>僵尸进程与处理</strong></p><ol><li><p>产生：</p><ul><li>子进程终止时发送给父进程一个 <strong>SIGCHLD</strong> 信号，若父进程没有捕获改信号处理，则子进程变为僵尸进程。</li></ul></li><li><p>POSIX 信号处理知识：</p><ol><li><p>父进程通过调用 <code>sigaction()</code> 函数捕获信号，捕获到信号有三种处理方式：</p><ul><li><p>提供一个函数，只要特定信号发生，就调用该函数。<strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 不能被捕获</p><p>信号处理函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span></span>;<span class="hljs-comment">// 无返回值， 形参为 信号</span><br></code></pre></td></tr></table></figure></li><li><p>把信号的处置设置为 <strong>SIG_NGN</strong> 忽略信号。<strong>SIGKILL</strong> 和 <strong>SIGSTOP</strong> 不能忽略</p></li><li><p>把信号处置设置为 <strong>SIG_DEF</strong> 启动默认处置</p></li></ul></li><li><p>POSIX 信号处理总结</p><ul><li>一旦安装了信号处理函数，便一直有效</li><li><strong>在一个信号处理函数运行期间，正被递交的函数是阻塞的</strong></li><li>如果一个信号在被阻塞期间产生了一次或多次，那么该信号被解除阻塞后只递交一次，<strong>Unix 信号默认是不排队的</strong></li></ul></li></ol></li><li><p><strong>使用 waitpid() 函数代替 wait() 函数</strong>，因为 <code>Unix </code>信号是不排队的，当同时出现多个子进程的 <strong>SIGCHLD</strong> 信号时，<code>wait()</code> 可能不能全部处理所有信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span> </span>&#123;<br><span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span>   stat;<br>    <br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated\n&quot;</span>, pid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>accept()</code> 中必须处理中断</p><ul><li>当 <strong>SIGCHLD</strong> 信号递交时，父进程阻塞于 <code>accept()</code> 系统调用，内核会使 <code>accept()</code> 返回一个 <strong>EINTR</strong> 错误( 被中断的系统调用 )，<strong>所以必须在程序 accept() 中处理该错误</strong>，重新启动 <code>accept() </code>系统调用</li><li>对于 <code>accept()</code> 以及诸如<code>read()</code>、<code>write()</code>、<code>select()</code> 和<code>open()</code> 之类的函数来说，<strong>重启</strong>被中断的系统调用时合适的，<strong>但是 connect() 除外</strong>，重启 <code>connect()</code> 将返回错误，因为原来的套接字已经无效</li></ul></li></ol><ul><li>总结</li></ul><p>网络编程时可能会遇到的三种情况：</p><ol><li><strong>当 fork 子进程时，必须捕获 SIGCHLD 信号</strong>；</li><li><strong>当捕获信号时，必须处理被中断的系统调用</strong>；</li><li><strong>SIGCHLD 的信号处理函数必须正确编写，应使用 waitpid 函数以免留下僵尸进程</strong></li></ol><p><strong>服务器进程终止</strong></p><ol><li><p>服务器进程终止，发送<code>FIN</code> 给客户端</p></li><li><p><strong>客户端阻塞在 <code>fget()</code> 上不能立即响应该 FIN</strong></p><blockquote><p>这就是引入 <code>select()</code> 和 <code>poll()</code> 的原因之一，客户端不能单纯阻塞在某个特定套接字描述符上，而应该阻塞在任意输入套接字描述</p></blockquote></li><li><p>等待用户输入文本后， <code>str_cli()</code> 函数调用 <code>writen()</code> 把数据发送给服务器</p></li><li><p>服务器接收到数据，响应 <code>RST</code></p></li><li><p><strong>客户端此时阻塞在 <code>readline()</code> 上，看不到这个 RST</strong>，并且由于第 1 步中的 <code>FIN</code> ，<code>readline()</code> 立即返回 0 ，所以 <code>str_cli()</code> 第 9 行，打印 <strong>“str_cli：server terminated prematurely”</strong></p></li><li><p>客户端终止，关闭所有打开的描述符</p></li></ol><p><strong>SIGPIPE 信号</strong></p><ol><li>产生：<br>如上第 5 步，客户端内核收到 <code>RST</code> ，而客户端进程并未及时处理，假如此时进程继续向对端服务器发送数据时(调用 <code>write()</code> ), 函数客户端内核将向该进程发送 <code>SIGPIPE</code> 信号</li><li>处理<br><code>SIGPIPE</code> 信号默认行为是终止进程，因此进程必须捕获它以免不情愿的被终止</li><li>无论进程有没有捕获<code>SIGPIPE</code>信号，<code>write()</code>返回 <code>EPIPE</code> 错误<ol><li>写一个接收了 <code>FIN</code> 的套接字正确(<code> CLOSE_WAIT</code> 状态)；</li><li>写一个接收了 <code>RST</code> 的套接字 <code>EPIPE</code> 错误</li></ol></li></ol><p><strong>服务器主机崩溃</strong></p><ol><li>过程<ol><li>服务器崩溃时，客户端不会收到任何通知</li><li>客户端调用 <code>wtrten()</code> 时，客户端 <code>TCP</code> 持续重传数据，试图从服务器接收 <code>ACK</code></li><li>重传过程结束还是没收到服务器 <code>ACK</code> ，此时客户端阻塞在<code>readline()</code>上，返回错误 <strong>ETIMEDOUT</strong></li></ol></li><li>处理<ol><li>对 <code>readline()</code> 调用设置超时，提前得知服务器崩溃信息，不必等待重传机制完成</li><li>设置 <strong>SO_KEEPALIVE</strong> 心跳保活选项</li></ol></li></ol><p><strong>服务器主机崩溃后重启</strong></p><ol><li>服务器崩溃重启后丢失之前的所有 <code>TCP </code>连接，因此服务器收到客户端的消息直接返回 <code>RST</code></li><li>客户端收到<code> RST</code> 返回 <strong>ECONNRESET</strong> 错误</li></ol><p><strong>服务器主机关机</strong></p><ol><li><code>Unix</code> 系统关机时，<code>init</code>进程给所有进程发送 <strong>SIGTERM</strong> 信号</li><li>内核等待(5-20 秒)，留给程序小段时间来清除和终止，然后给所有仍在运行的进程发送 <strong>SIGKILL</strong> 杀死进程</li><li>若进程不捕获 <strong>SIGTERM</strong> ，服务器进程由 <strong>SIGKILL</strong> 终止，随后发生的步骤如上: &lt;服务器进程终止&gt;</li></ol><ul><li><p>总结</p><p><strong>必须在客户端程序中使用 select 或 poll 函数，使服务器进程终止一经发生，立刻检测到</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:套接字编程基本API</title>
    <link href="/2022/03/29/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%ACAPI/"/>
    <url>/2022/03/29/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%ACAPI/</url>
    
    <content type="html"><![CDATA[<ul><li><p>套接字函数事件表</p><p><img src="1.png" alt="1"></p></li></ul><h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1. socket()"></a>1. socket()</h3><p><code>socket()</code>用于创建新的套接字</p><ul><li><p>socket()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span>;<br>                                    <span class="hljs-comment">// 返回：成功返回套接字描述符，失败-1</span><br></code></pre></td></tr></table></figure><ul><li><p>family</p><p>family为地址族，可选值如下</p><table><thead><tr><th>family</th><th>说明</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4协议</td></tr><tr><td>AF_INT6</td><td>IPv6协议</td></tr><tr><td>AF_LOCAL</td><td>Unix域协议</td></tr><tr><td>AF_ROUTE</td><td>路由套接字</td></tr><tr><td>AF_KEY</td><td>秘钥套接字</td></tr></tbody></table></li><li><p>type</p><p>指明套接字的类型，可选值如下</p><table><thead><tr><th>type</th><th>说明</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>字节流套接字</td></tr><tr><td>SOCK_DGRAM</td><td>数据报套接字</td></tr><tr><td>SOCK_SEQPACKET</td><td>有序分组套接字</td></tr><tr><td>SOCK_RAM</td><td>原始套接字</td></tr></tbody></table></li><li><p>protocol</p><p><code>protocol</code>参数可以设置为0，以表示<code>family</code>, <code>type</code>经过组合产生产生的默认值, <code>family</code>与<code>type</code>组合产生的<code>protocol</code>默认值如下</p><p><img src="2.png" alt="2"></p><blockquote><p>“是”表明这样搭配也是有效的，但是没有合适的缩略语</p></blockquote><p>也可以手动设置</p><table><thead><tr><th>protocol</th><th>说明</th></tr></thead><tbody><tr><td>IPPROTO_TCP</td><td>TCP传输协议</td></tr><tr><td>IPPROTO_UDP</td><td>UDP传输协议</td></tr><tr><td>IPPROTO_SCTP</td><td>SCTP传输协议</td></tr></tbody></table></li></ul></li></ul><h3 id="2-connect"><a href="#2-connect" class="headerlink" title="2. connect()"></a>2. connect()</h3><p><code>connect()</code>函数用于建立与服务器的连接</p><ul><li><p>connect()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *servaddr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br>                                                    <span class="hljs-comment">// 返回：成功 0，失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>本地套接字描述符</p></li><li><p>servaddr</p><p>服务器套接字结构</p></li><li><p>addrlen</p><p>调节子结构大小</p></li></ul></li><li><p>注意点</p><ul><li>调用connect函数触发三路握手，仅在连接建立成功或出错时才返回，出错返回有以下情况：<ol><li>TCP客户端没有收到SYN分节的<strong>响应</strong>，返回 <strong>ETIMEDOUT</strong> 错误(在多次尝试失败后)；</li><li>TCP客户端收到的 SYN 响应是 RST，立即返回 <strong>ETIMEDOUT</strong> 错误(<strong>硬错误</strong>，表明服务器主机在指定的端口上没有进程等待连接)</li><li>TCP客户端发出的 SYN 在中间的路由上引发 “destination unreachable” ICMP错误(<strong>软错误</strong>)，客户机会将 ICMP 错误信息保存在本地，继续尝试重发，若一段时间之后人体没有收到响应，那么就把保存的错误信息作为<strong>EHOSTTUNREACH</strong>或者<strong>ENETUNREACH</strong> 错误返回给进程</li><li>产生 RST 错误分节的条件:<ol><li>SYN 到达目的，但指定的端口没有进程</li><li>TCP 取消一个已有连接</li><li>TCP 接收到一个不存在的连接的分节</li></ol></li></ol></li><li><strong>若 connect 失败，则该套接字不能用，必须 close，再重新调用 socket 创建新的套接字</strong></li></ul></li></ul><h3 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. bind()</h3><p><code>bind()</code>将一个本地协议地址({IP地址, 端口号})与一个通过<code>socket()</code>产生的套接字绑定</p><ul><li><p>bind()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr *myaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br>                                                <span class="hljs-comment">// 返回：成功0 失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>本地套接字</p></li><li><p>myaddr</p><p>本地套接字结构</p></li><li><p>addrlen</p><p>套接字结构大小</p></li></ul></li><li><p>注意点</p><ul><li><p>端口号</p><p><code>bind()</code>基本上只由服务器调用，服务器在启动时需要绑定他们众所周知的端口，如果没有调用<code>bind()</code>的话，当调用<code>connect()</code>(客户机)或<code>listen()</code>(服务器)时，系统就会为套接字分配一个临时的端口号</p><p>对于客户端来说，分配临时端口号没有什么问题，所以客户端基本不调用<code>bind()</code>, 而服务器是通过众所周知的端口号被认识的，必须调用<code>bind()</code></p></li><li><p>IP地址</p><ul><li>对于服务器而言，使用<code>bind()</code>将套接字与指定IP绑定之后，意味着该套接字只接受目的地址为该IP地址的分节</li><li>当发送分节的时候，内核会根据分节到达服务器的路径来自动选择IP地址</li><li>如果TCP服务器没有使用<code>bind()</code>将套接字与指定IP绑定，那么服务器就会将客户发送的SYN的目的地址作为服务器的源IP地址</li></ul></li><li><p>默认套接字</p><p><img src="3.png" alt="3"></p><p>如果指定端口号为0, 那么<code>bind()</code>时选择的仍然是一个临时端口号，如果IP地址为通配地址<strong>INADDR_ANT</strong>, 那么同样有内核对IP地址进行选择</p></li></ul></li></ul><h3 id="4-listen"><a href="#4-listen" class="headerlink" title="4. listen()"></a>4. listen()</h3><p><code>listen()</code>函数用于监听指定套接字</p><p><strong>主动套接字与被动套接字</strong></p><ul><li>当socket创建一个套接字的时候，它被假定为一个<strong>主动套接字</strong>，即系统认为它即将调用<code>connect()</code>与其它主机建立连接</li><li><code>listen()</code>函数会将其转变为<strong>被动套接字</strong>，指示内核应该接受指向该套接字的连接请求</li></ul><ul><li><p>listen()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br>            <span class="hljs-comment">// 返回：成功 0 失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>指定套接字</p></li><li><p>backlog</p><p>内核应该为相应套接字排队的最大连接个数</p></li></ul></li><li><p>backlog参数解释</p><p>内核为任意一个监听套接字维护两个队列</p><ul><li><p>未完成连接队列</p><p>当套接字接受到一个SYN, 并且发出[SYN +ACK] 报文之后，内核就会将该连接加入未完成连接队列，此时套接字位于<strong>SYN_RCVD</strong>状态</p></li><li><p>已完成连接队列</p><p>对于每个已经完成了TCP三路握手的连接，内核会将他们加入以完成连接队列，此时套接字处于<strong>ESTABLISHED</strong>状态</p></li></ul><p><strong>图例</strong></p><p><img src="4.png" alt="4"></p><p>如上图所示，**<code>backlog</code>参数就是用来限定这两个队列套接字的总和**</p></li></ul><blockquote><p>实际上，上述解释也不一定对，因为各家实现是不同的</p></blockquote><h3 id="5-accept"><a href="#5-accept" class="headerlink" title="5. accept()"></a>5. accept()</h3><p><code>accept()</code>调用会从已完成连接队头返回下一个已完成连接，如果已完成队列为空，那么进程会被置为睡眠状态(或阻塞)</p><ul><li><p>accpet()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br>                                       <span class="hljs-comment">// 返回：成功 返回已连接套接字， 出错 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>监听套接字，<code>accept()</code>会从该套接字对应的已完成队列中获取连接</p></li><li><p>childaddr</p><p>返回已连接的客户的协议地址</p></li><li><p>addrlen</p><p>是一个值-结果类型参数，传入时代表childaddr的大小，传出时代表写入的字节大小</p></li></ul></li></ul><p><strong>监听套接字与已连接套接字</strong></p><ul><li>当使用<code>listen()</code>监听一个套接字之后，该套接字就被称为<strong>监听套接字</strong>(被动套接字),  一个监听套接字在服务器声明周期内一直存在</li><li><code>accept()</code>返回的是一个新的套接字，被称为<strong>已连接套接字</strong>，当服务器完成与某个客户的连接之后，相应的已连接套接字就被关闭</li></ul><p><strong>accept()的返回时机</strong></p><p><img src="5.png" alt="5"></p><ul><li>当连接建立完成，即服务器接收到最后一个ACK时，accept()从睡眠(阻塞)中返回</li></ul><h3 id="6-close"><a href="#6-close" class="headerlink" title="6. close()"></a>6. close()</h3><p><code>close()</code>用于关闭一个套接字, 就和关闭一个普通文件一样</p><ul><li><p>close()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span>;<br>            <span class="hljs-comment">// 返回： 成功 0，失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>指定套接字</p></li></ul></li><li><p>注意点</p><ul><li>调用close <strong>套接字描述符引用计数减 1</strong>，若减 1 后引用计数为 0 ，发送 FIN 开启 TCP 连接终止过程</li><li>立即结束 TCP 连接，使用 shutdown 函数</li><li>并发服务器编程时，<strong>父进程必须关闭已连接描述符</strong>，否则导致套接字描述符总是大于 1， <strong>连接不会被真正终</strong>止，并可能<strong>耗尽可用描述符</strong></li></ul></li></ul><h3 id="7-getsockname-getpeername"><a href="#7-getsockname-getpeername" class="headerlink" title="7. getsockname(), getpeername()"></a>7. getsockname(), getpeername()</h3><p><code>getsockname()</code> 返回与该套接字关联的<strong>本地协议地址</strong><br><code>getpeername()</code> 返回与该套接字关联的<strong>外地协议地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockname</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpeername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br>                                                    <span class="hljs-comment">// 返回：成功 0，失败 -1</span><br></code></pre></td></tr></table></figure><ul><li><p>sockfd</p><p>给定套接字，已连接套接字或者监听套接字都可以</p></li><li><p>addr</p><p>返回结果</p></li><li><p>addrlen</p><p>值-结果类型参数，传入指明addr大小，传出指明写入大小</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:字节-地址转换函数</title>
    <link href="/2022/03/29/UNP-%E5%AD%97%E8%8A%82-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <url>/2022/03/29/UNP-%E5%AD%97%E8%8A%82-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-值-结果参数"><a href="#1-值-结果参数" class="headerlink" title="1. 值-结果参数"></a>1. 值-结果参数</h3><p>值-结果类型参数通常与套接字结构一起使用，是指这样一种参数:</p><p>其通常是某个整型变量的指针，当其被传递给函数时，函数需要用到它的值，通常用于标识套接字结构的大小，</p><p>当函数执行完毕，指针指向的值可能会发生改变，其内容通常为函数在套接字结构中写入的字节大小</p><ul><li><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sodkaddr_un</span> <span class="hljs-title">cli</span>;</span><br><span class="hljs-keyword">socklen_t</span> len;<br>len = <span class="hljs-keyword">sizeof</span>(cli);<br><br>getpeername(unixfd, (SA *) &amp;cil, &amp;len);  <span class="hljs-comment">// len为值-结果类型参数</span><br></code></pre></td></tr></table></figure><p><code>len</code>作为传入参数，表明了<code>cli</code>的大小，当函数执行完毕之后，表明该结构中有多少字节被写入</p><blockquote><p>对于固定长度的套接字结构来说，值-结果参数的传入与传出值总是一样的</p><p>而对于可变长度的套接字结构(如sockaddr_un)来说，传出值可能会小于传入值</p></blockquote></li></ul><h3 id="2-字节排序函数"><a href="#2-字节排序函数" class="headerlink" title="2. 字节排序函数"></a>2. 字节排序函数</h3><p><strong>大端与小端</strong></p><ul><li>大端： 高序字节在地址低处，低序字节在地址高处</li><li>小端： 高序字节在地址高处，低序字节在地址低处</li></ul><p><img src="1.png" alt="1"></p><p><strong>主机字节序与网络字节序</strong></p><p>不同的主机之间，可能会有着不同的字节序，但是在网络当中，统一使用<strong>大端</strong>字节序来传送字节，这也被称为<strong>网络字节序</strong></p><p><strong>字节序转换函数</strong></p><p>在进行网络编程时，需要在主机字节序与网络字节序之间相互转换，POSIX提供了以下函数提供此功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">htons</span> <span class="hljs-params">(uint16t host16bitvalue)</span>: <span class="hljs-comment">//h:host 主机字节序</span></span><br><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">htonl</span> <span class="hljs-params">(uint32t host32bitvalue)</span></span>; <span class="hljs-comment">//n:network 网络字节序</span><br>                    <span class="hljs-comment">// return: 网络字节序</span><br><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">ntohs</span> <span class="hljs-params">(uint16t net16bitvalue)</span></span>;  <span class="hljs-comment">//s:short</span><br><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">ntohl</span> <span class="hljs-params">(uint32t net32bitvalue)</span></span>;  <span class="hljs-comment">//l:long</span><br>                    <span class="hljs-comment">// return: 主机字节序</span><br></code></pre></td></tr></table></figure><ul><li><p>各个字母含义</p><p>h: host , 主机</p><p>n: network, 网络</p><p>s: short, 16位</p><p>l: long, 32位</p></li></ul><p>在那些主机字节序为大端的主机上，这些函数通常被定义为<strong>空宏</strong></p><h3 id="3-字节操纵函数"><a href="#3-字节操纵函数" class="headerlink" title="3. 字节操纵函数"></a>3. 字节操纵函数</h3><p>有两套API用于对字节进行操纵:</p><ul><li><p>BSD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;strings.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;               <span class="hljs-comment">//!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bcopy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptrl, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr2, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;  <br>                                                     <span class="hljs-comment">// return: 相等返回0， 否则非0</span><br></code></pre></td></tr></table></figure></li><li><p>ANSIC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">size_t</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;  <span class="hljs-comment">//!</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptrl, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr2, <span class="hljs-keyword">sise_t</span> nbytes)</span></span>;  <span class="hljs-comment">//!</span><br>                                                      <span class="hljs-comment">// return: 相等返回0，ptr1 &gt; ptr2 返回正值，否则负值</span><br></code></pre></td></tr></table></figure><blockquote><p>在UNP中常用的API均以!标识</p></blockquote></li></ul><h3 id="4-地址转换函数"><a href="#4-地址转换函数" class="headerlink" title="4. 地址转换函数"></a>4. 地址转换函数</h3><p>下面会介绍一些函数，在字符串(点分十进制) 与 网络字节序(<code>struct in_addr, in_addr_t</code>) 之间进行转换</p><ul><li><p>IPV4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 例：“206.168.112.96” -&gt; struct in_addr（32bit IPv地址）</span><br><span class="hljs-function">nt <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;<br>                                          <span class="hljs-comment">// 返回：字符串有效为 1，否则为 0</span><br><br>/ 例：<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>（32<span class="hljs-title">bit</span> <span class="hljs-title">IPv</span>地址）-&gt;</span> “<span class="hljs-number">206.168</span><span class="hljs-number">.112</span><span class="hljs-number">.96</span>” <br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">inet_ntoa</span><span class="hljs-params">(struct in_addr inaddr)</span></span>;<br>                                          <span class="hljs-comment">// 点分十进制字符串</span><br></code></pre></td></tr></table></figure><blockquote><p>a: address, 字符串地址</p><p>n: numeric, 字节序数值</p></blockquote></li><li><p>IPV4/IPV6</p><p>与上面的API对应，只不过多了一个参数<code>family</code>表示协议族</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strptr, <span class="hljs-keyword">void</span>*addrptr)</span></span>;<br>                                          <span class="hljs-comment">// 返回：字符串有效为 1，否则为 0</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addrptr, <span class="hljs-keyword">char</span> *strptr, <span class="hljs-keyword">size_t</span> len)</span></span>;<br>                                          <span class="hljs-comment">// 点分十进制字符串</span><br></code></pre></td></tr></table></figure><blockquote><p>p: presentation, 字符串表达</p><p>n: numeric, 字节序数值</p></blockquote><p>关于<code>len</code>参数的取值，在<code>&lt;arpa/inet.h&gt;</code>中定义了宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET_ADDRSTRLEN 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure><ul><li><p>示意图</p><p><img src="2.png" alt="2"></p></li></ul></li></ul><blockquote><p>为了简化参数的传递，unp自定义了一些函数进行封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">sock_ntop</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sockaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br>                                 <span class="hljs-comment">// 将网络字节序转变为字符串，不过此时直接传递套接字结构即可</span><br>                                 <span class="hljs-comment">// return: 成功返回转换后的字符串，否则NULL</span><br></code></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p></blockquote><h3 id="5-字节流函数"><a href="#5-字节流函数" class="headerlink" title="5. 字节流函数"></a>5. 字节流函数</h3><p>下面依旧是一些UNP自己封装的函数, 用于字节流操纵，封装的原因是：套接字的缓存有限，此时读取的字节数经常小于给定的读取长度，一般的解决方案就是再次读取即可，这里UNP做了封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">written</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> filedes, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> maxlen)</span></span>;<br>                                <span class="hljs-comment">// 返回：读或写的字节数，若出错则为-1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:套接字地址结构</title>
    <link href="/2022/03/29/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/29/UNP-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>本文将会重点介绍IPV4相关内容，IPV6的内容将不予涉及, 以下涉及到的函数以及结构默认都是IPV4， POSIX规范</p><h3 id="1-套接字地址结构"><a href="#1-套接字地址结构" class="headerlink" title="1. 套接字地址结构"></a>1. 套接字地址结构</h3><p>该结构定义在<code>&lt;netinet/in.h&gt;</code>中</p><ul><li><p>sockaddr_in</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// IPv4套接字地址结构：sockaddr_in</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span> </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">in_addr_t</span>       s_addr;         <span class="hljs-comment">/* 32bit IPv4 address. */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">uint8_t</span>         sin_len;        <span class="hljs-comment">/* length of structure (16) */</span><br>    <span class="hljs-keyword">sa_family_t</span>     sin_family;     <span class="hljs-comment">/* AF_INET */</span>                             <span class="hljs-comment">// 协议族</span><br>    <span class="hljs-keyword">in_port_t</span>       sin_port;       <span class="hljs-comment">/* 16bit TCP/UDP port number */</span>           <span class="hljs-comment">// 端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>       <span class="hljs-comment">/* 32bit IPv4 address */</span>                  <span class="hljs-comment">// IPV4地址</span><br>    <span class="hljs-keyword">char</span>            sin_zero[<span class="hljs-number">8</span>];    <span class="hljs-comment">/* unused */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>对于POSIX规范，只需要给定三个字段即可: <code>sin_family</code>, <code>sin_addr</code>, <code>sin_port</code></p><p>在初始化时，会将这些字段都置为0</p></li><li><p>数据类型</p><p><img src="1.png" alt="1"></p></li></ul><h3 id="2-通用套接字地址结构"><a href="#2-通用套接字地址结构" class="headerlink" title="2. 通用套接字地址结构"></a>2. 通用套接字地址结构</h3><p>当一个套接字函数接受一个套接字地址结构时，通常要使用<strong>通用套接字地址结构</strong>来进行类型强转，这样它们才能够接受来自不同协议的套接字地址结构</p><p>该结构定义在头文件<code>&lt;sys/socket.h&gt;</code>中</p><ul><li><p>sockaddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 通用套接字地址结构：sockaddr</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span> struct sockaddr &#123;</span><br><span class="hljs-keyword">uint8_t</span>         sa_len;         <span class="hljs-comment">/* length of structure */</span><br><span class="hljs-keyword">sa_family_t</span>     sa_family;      <span class="hljs-comment">/* address family: AF_XXXX value */</span><br><span class="hljs-keyword">char</span>            sa_data[<span class="hljs-number">14</span>];    <span class="hljs-comment">/* protocol-specific address */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>常见用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bind(sockfd, (struct sockaddr*) &amp;serv, sizeif(serv));<br></code></pre></td></tr></table></figure><p>可以看出，该结构<strong>唯一</strong>的作用就是类型强转</p></li></ul></li></ul><p><strong>新通用套接字地址结构</strong></p><p>上面的通用地址结构出现的比较早，后面IPV6相关API中包含了新的通用套接字地址结构</p><ul><li><p>sockaddr_storage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 通用套接字地址结构：sockaddr</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span> struct sockaddr &#123;</span><br><span class="hljs-keyword">uint8_t</span>         sa_len;         <span class="hljs-comment">/* length of structure */</span><br><span class="hljs-keyword">sa_family_t</span>     sa_family;      <span class="hljs-comment">/* address family: AF_XXXX value */</span><br>...                             <span class="hljs-comment">/* 一些协议相关字段 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构相对于旧结构，有以下优点:</p><ul><li>满足任何套接字地址结构对齐要求</li><li>足够大，可以容纳任何套接字地址结构</li></ul><blockquote><p>后面的协议相关字段不能通过结构体成员进行访问，只能通过获取相对应的字节偏移量进行访问</p></blockquote></li></ul><h3 id="3-地址结构比较"><a href="#3-地址结构比较" class="headerlink" title="3. 地址结构比较"></a>3. 地址结构比较</h3><p><img src="2.png" alt="2"></p>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UNP]:端口与并发服务器</title>
    <link href="/2022/03/29/UNP-%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/03/29/UNP-%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1. 端口号"></a>1. 端口号</h3><p>**IANA(theInternet Assigned Numbers Authority)**维护着一份端口号清单，最后一份文档作为RFC[1700]发出</p><p>其将端口号划分为3段:</p><ul><li><p>众所周知的端口号（0~1023）</p><p>服务器通常需要使用到这些众所周知的端口号，它们专用于某些特定的服务，如端口号80就专用于Web服务</p><p><img src="1.png" alt="1"></p></li><li><p>已登记的端口（1024~49151）</p><p>IANA不对这些端口号加以控制，许多服务可以绑定到这些端口</p></li><li><p>临时端口(49152~65535)</p><p>也被称为<strong>动态端口</strong>，<strong>私有端口</strong>，经常用于客户的临时分配</p></li></ul><p>示意图</p><p><img src="2.png" alt="2"></p><h3 id="2-并发服务器"><a href="#2-并发服务器" class="headerlink" title="2. 并发服务器"></a>2. 并发服务器</h3><p>并发服务器中通常会有一个主循环，每当有一个新的连接到达时，就会<code>fork()</code>一个子进程来处理新的连接</p><p>下面给出一个服务器连接流程示意:</p><ul><li><p>假设有一台多宿主机用于服务器，其IP地址为12.106.32.254和192.168.42.1, 其在端口21上执行监听</p><p><img src="3.png" alt="3"></p><blockquote><p>这里的*是通配符</p><p>第一个*表示服务器在任意本地接口的端口21上等待连接请求</p><p>后面的*表示，等待任意IP地址的主机的任意端口上的连接请求</p></blockquote></li><li><p>有一台IP地址为206.168.112.219的主机，它与服务器建立连接，使用的临时端口为1500</p><p><img src="4.png" alt="4"></p></li><li><p>当服务器接收到连接时，其<code>fork()</code>出一个副本，让子进程来处理客户的请求</p><p><img src="5.png" alt="5"></p><p>从上图中我们可以得出很多信息:</p><ul><li>服务器有两种套接字: <strong>监听套接字</strong>与<strong>已连接套接字</strong>，他们使用的是相同的本地端口(21)</li><li>当连接建立完成，已连接套接字的套接字对就被填充完成</li></ul></li><li><p>同一个客户机的另一个客户请求连接到同一个服务器，客户主机为其分配一个临时端口</p><p><img src="6.png" alt="6"></p></li></ul><p>最终的效果如上图所示，可以发现，服务器上的不同子进程使用的本地IP地址与端口号可以是相同的，因此，当一个报文到达时，必须结合发送方的IP地址与端口号，才能够判断由哪个进程接受该报文</p>]]></content>
    
    
    
    <tags>
      
      <tag>unp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:文件系统</title>
    <link href="/2022/03/29/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/03/29/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<ul><li><ol><li>总览</li></ol><p>xv6的文件系统是一个类Linux文件系统，具体分为7个层次，下面是xv6的文件系统层次图</p><ul><li>文件系统层次图<br><img src="1.png" alt="1"></li></ul><p>磁盘结构方面，同样是Linux的简化版本，分为了6个区块</p><ul><li><p>磁盘结构图</p><p><img src="2.png" alt="2"></p><ul><li><p>boot </p><p>存放boot sector, 即启动引导程序, 具体就是mkfs(mkfs.c)</p></li><li><p>super block</p><p>包含了文件系统的元数据,  包括文件系统大小，数据块大小，日志区域大小，inode数量</p><ul><li><p>实际结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">superblock</span> &#123;</span><br>  uint magic;        <span class="hljs-comment">// Must be FSMAGIC</span><br>  uint size;         <span class="hljs-comment">// Size of file system image (blocks)</span><br>  uint nblocks;      <span class="hljs-comment">// Number of data blocks</span><br>  uint ninodes;      <span class="hljs-comment">// Number of inodes.</span><br>  uint nlog;         <span class="hljs-comment">// Number of log blocks</span><br>  uint logstart;     <span class="hljs-comment">// Block number of first log block</span><br>  uint inodestart;   <span class="hljs-comment">// Block number of first inode block</span><br>  uint bmapstart;    <span class="hljs-comment">// Block number of first free map block</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>bit map</p><p>用于指示哪些块正在被使用, 这里的块是磁盘中的所有块</p></li></ul></li></ul><h3 id="2-Buffer-cache"><a href="#2-Buffer-cache" class="headerlink" title="2. Buffer cache"></a>2. Buffer cache</h3><p>xv6中 <code>buffer cache</code>相关代码位于<code>bio.c</code>文件, <code>buffer cache</code>有两项工作：</p><ol><li>同步访问磁盘块，以确保磁盘块在内存中只有一个buffer缓存，并且一次只有一个内核线程能使用该buffer缓存</li><li>缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取</li></ol><ul><li><p>bio.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;sleeplock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;defs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;buf.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">binit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  initlock(&amp;bcache.lock, <span class="hljs-string">&quot;bcache&quot;</span>);<br><br>  <span class="hljs-comment">// Create linked list of buffers</span><br>  bcache.head.prev = &amp;bcache.head;<br>  bcache.head.next = &amp;bcache.head;<br>  <span class="hljs-keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct buf*</span><br><span class="hljs-function"><span class="hljs-title">bget</span><span class="hljs-params">(uint dev, uint blockno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-function">struct buf*</span><br><span class="hljs-function"><span class="hljs-title">bread</span><span class="hljs-params">(uint dev, uint blockno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bwrite</span><span class="hljs-params">(struct buf *b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">brelse</span><span class="hljs-params">(struct buf *b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bpin</span><span class="hljs-params">(struct buf *b)</span> </span>&#123;<br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt++;<br>  release(&amp;bcache.lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bunpin</span><span class="hljs-params">(struct buf *b)</span> </span>&#123;<br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码分析</p><ul><li><p>bcache</p><p>xv6使用了一个数据结构<code>bcache</code>用于维护整个缓存，其使用了一把大锁来保证缓存的并发访问的正确性</p></li><li><p>buf</p><p>xv6使用<code>buf</code>结构体来表示单个缓存块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span><br>  <span class="hljs-keyword">int</span> valid;   <span class="hljs-comment">// 其中的数据是否有效(可以刷回磁盘)</span><br>  <span class="hljs-keyword">int</span> disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;   <br>  uint blockno; <span class="hljs-comment">// 缓存块对应的设备文件以及设备上的磁盘块号</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span><br>  uint refcnt;  <span class="hljs-comment">// 引用计数，表示当前是否有进程正在使用该buufer</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">// LRU cache list</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span><br>  uchar data[BSIZE];<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个缓存块都有一把自己的<code>sleeplock</code>, 如果一个进程想要使用该<code>buffer</code>块, 必须要拿到<code>buffer</code>块的锁，然后将<code>refcnt</code>++</p></li><li><p>内存布局</p><p>xv6中使用了一个双向链表来维护所有的缓存块，该链表是一个LRU链表，链表头部的<code>buffer</code>块是最新被使用的<code>buffer</code>块</p><p>在这里，满足LRU的缓存块的条件就是<code>refcnt == 0</code>且最靠近链表尾部</p></li><li><p>API</p><ul><li><p>binit():  初始化整个缓存区域</p></li><li><p>bget():  返回某个设备上的某个磁盘块对应的<code>buffer</code>块，如果没有，那么就创建一个<code>buffer</code>块，并不覆盖其中的内容</p><p>该函数只会被<code>bread()</code>调用</p></li><li><p>bread(): 调用bread(), 并且如果没有对应<code>buffer</code>块的话，会使用磁盘块的内容覆盖得到的<code>buffer</code>块</p></li><li><p>bwrite(): 覆写一个<code>bufffer</code>块</p></li><li><p>brelse(): 每当进程使用完一个<code>buffer</code>块之后，就需要调用<code>breles()</code>将其释放回LRU链表</p></li></ul><blockquote><p>注意这里的LRU链表只有增加块而没有减少块</p></blockquote></li></ul></li></ul><h3 id="3-Logging"><a href="#3-Logging" class="headerlink" title="3. Logging"></a>3. Logging</h3><p>xv6中采用了日志系统来进行崩溃恢复</p><ul><li><p>磁盘日志结构</p><p>在xv6的实现中，磁盘中的Log区域由<code>logheader</code>以及很多<code>logged block</code>构成, <code>logged block</code>是更新之后的缓存块的副本</p><ul><li><p>logheader</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;              <span class="hljs-comment">// 当前日志块的数量, 每一个块都是一个完整的事务提交</span><br>  <span class="hljs-keyword">int</span> block[LOGSIZE]; <span class="hljs-comment">// 日志块(扇区号)数组, block[i]表示该block要写入的磁盘的扇区号</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>全局log结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">log</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-keyword">int</span> start;       <span class="hljs-comment">// logheader 块在磁盘中对应的blockno</span><br>  <span class="hljs-keyword">int</span> size;        <span class="hljs-comment">// log区域的大小</span><br>  <span class="hljs-keyword">int</span> outstanding; <span class="hljs-comment">// how many FS sys calls are executing.</span><br>  <span class="hljs-keyword">int</span> committing;  <span class="hljs-comment">// in commit(), please wait.</span><br>  <span class="hljs-keyword">int</span> dev;         <span class="hljs-comment">// 该log区域对应的是哪个磁盘设备</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> <span class="hljs-title">lh</span>;</span>  <span class="hljs-comment">// logheader</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>代码分析</p><p>先从底层函数开始描述，然后逐渐过渡到顶层</p><p><strong>日志记录</strong></p><ul><li><p><code>write_log()</code>: 将所有<code>logged block</code>刷新回磁盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将内存Logged block拷贝到磁盘log区域</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">write_log</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> tail;<br><br>  <span class="hljs-comment">// 这里并没有直接调用磁盘接口，而是将logged内容覆盖到了磁盘log块在内存中的缓存</span><br>  <span class="hljs-comment">// 然后再将缓存刷新回磁盘</span><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;<br>    <span class="hljs-comment">// 遍历所有的Loggded block</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">to</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>);     <span class="hljs-comment">// log block</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">from</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// cache block</span><br>    memmove(to-&gt;data, from-&gt;data, BSIZE);<br>    bwrite(to);  <span class="hljs-comment">// write the log</span><br>    brelse(from);<br>    brelse(to);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>write_head()</code>: 将<code>logheader</code>刷新回磁盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">write_head</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">hb</span> =</span> (struct logheader *) (buf-&gt;data);  <span class="hljs-comment">// 磁盘logheader对应的内存缓存</span><br>  <span class="hljs-keyword">int</span> i;<br>  hb-&gt;n = <span class="hljs-built_in">log</span>.lh.n;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;<br>    hb-&gt;block[i] = <span class="hljs-built_in">log</span>.lh.block[i];                         <span class="hljs-comment">// 更改磁盘Logheader内存buffer</span><br>  &#125;<br>  <span class="hljs-comment">/********** commit point !! ***********/</span><br>  <span class="hljs-comment">// 在bwrite 之前，如果发生crash, 那么并不会发生redo操作</span><br>  <span class="hljs-comment">// 在bwrite 之后，logheadr已经被刷新回磁盘，此时恢复程序就可以从磁盘中获取到</span><br>  <span class="hljs-comment">// 已经commit的事务，然后进行redo(此时恢复程序只知道已经commit, </span><br>  <span class="hljs-comment">// 但是不知道数据究竟有没有被刷回磁盘, 所以可能会发生重复redo)</span><br>  bwrite(buf);                                              <span class="hljs-comment">// 磁盘Logheader刷回磁盘</span><br>  brelse(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的第16行， 该函数是真正意义上的<code>commit point</code>, <code>bwrite(buf)</code>会将<code>logheader</code>刷新回磁盘，一旦该操作完成，就意味着该事务已经<code>commit</code>了</p><p>在该行执行之前，一旦<code>crash</code>, 那么恢复系统将不会在磁盘中对该事务进行<code>redo</code>, 因为根本没有<code>logheader</code>的记录</p><p>在此之后，一旦<code>crash</code>, 那么恢复系统就会对该事务进行<code>redo</code></p><p>即, <strong>一旦logheader被刷新回磁盘事务就提交成功</strong></p></li><li><p><code>install_trans()</code>: 应用事务，即将修改数据在log区域中的缓存刷新回磁盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将log 区域中缓存的内容真正刷新回磁盘</span><br><span class="hljs-comment">// 即应用事务</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">install_trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> recovering)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> tail;<br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>);   <span class="hljs-comment">// read log block</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">dbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// read dst</span><br>    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);                <span class="hljs-comment">// copy block to dst</span><br>    bwrite(dbuf);                                          <span class="hljs-comment">// write dst to disk</span><br>    <span class="hljs-keyword">if</span>(recovering == <span class="hljs-number">0</span>)<br>      bunpin(dbuf);<br>    brelse(lbuf);<br>    brelse(dbuf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>处于简单考虑， xv6中并没有直接将使用virtio_disk_rw()缓存数据刷新回磁盘，而是使用bread() + bwrite()的形式</p></blockquote><ul><li><p><code>commit()</code>: 提交事务， 然后清除日志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">commit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt; <span class="hljs-number">0</span>) &#123;<br>    write_log();     <span class="hljs-comment">// Write modified blocks from cache to log</span><br>                     <span class="hljs-comment">// 将内存的Logged block写入磁盘的log区域</span><br>    write_head();    <span class="hljs-comment">// Write header to disk -- the real commit</span><br>                     <span class="hljs-comment">// 将内存中的logheader写入磁盘当中</span><br>    install_trans(<span class="hljs-number">0</span>); <span class="hljs-comment">// Now install writes to home locations</span><br>    <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;     <span class="hljs-comment">// clear log</span><br>    write_head();    <span class="hljs-comment">// Erase the transaction from the log</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数是上面函数的整合，先将<code>log</code>刷回磁盘，然后将<code>log</code>中缓存的修改数据刷新回磁盘，最后执行<code>clear log</code></p></li><li><p><code>begin_op()</code>: 代表事务开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表示事务的开始</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">begin_op</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)&#123;<br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.lh.n + (<span class="hljs-built_in">log</span>.outstanding+<span class="hljs-number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;<br>      <span class="hljs-comment">// this op might exhaust log space; wait for commit.</span><br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">log</span>.outstanding += <span class="hljs-number">1</span>;<br>      release(&amp;<span class="hljs-built_in">log</span>.lock);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>end_op()</code>: 代表事务结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 表示事务的结束</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">end_op</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> do_commit = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>  <span class="hljs-built_in">log</span>.outstanding -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)<br>    panic(<span class="hljs-string">&quot;log.committing&quot;</span>);<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.outstanding == <span class="hljs-number">0</span>)&#123;<br>    do_commit = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// begin_op() may be waiting for log space,</span><br>    <span class="hljs-comment">// and decrementing log.outstanding has decreased</span><br>    <span class="hljs-comment">// the amount of reserved space.</span><br>    wakeup(&amp;<span class="hljs-built_in">log</span>);<br>  &#125;<br>  release(&amp;<span class="hljs-built_in">log</span>.lock);<br><br>  <span class="hljs-keyword">if</span>(do_commit)&#123;<br>    <span class="hljs-comment">// call commit w/o holding locks, since not allowed</span><br>    <span class="hljs-comment">// to sleep with locks.</span><br>    commit();<br>    acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">0</span>;<br>    wakeup(&amp;<span class="hljs-built_in">log</span>);<br>    release(&amp;<span class="hljs-built_in">log</span>.lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>基本上每一个与文件系统相关的系统调用都会在开始使用<code>begin_op()</code>, 然后在最后调用<code>end_op()</code>，</p><p><strong>崩溃恢复</strong></p><p>依旧是从底层函数开始</p><ul><li><p><code>read_head()</code>: 从磁盘中读取<code>logheader</code>到内存的<code>logheader</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">read_head</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">lh</span> =</span> (struct logheader *) (buf-&gt;data);<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-built_in">log</span>.lh.n = lh-&gt;n;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;<br>    <span class="hljs-built_in">log</span>.lh.block[i] = lh-&gt;block[i];<br>  &#125;<br>  brelse(buf);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>recover_from_log()</code>: 日志恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">recover_from_log</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  read_head();<br>  install_trans(<span class="hljs-number">1</span>); <span class="hljs-comment">// if committed, copy from log to disk</span><br>  <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;<br>  write_head(); <span class="hljs-comment">// clear the log</span><br>&#125;<br></code></pre></td></tr></table></figure><p>恢复过程比较简单，首先读取磁盘<code>logheadr</code>，因为此时内存中的<code>logheader</code>是无效的或者说根本就没有，然后再将<code>log</code>中的修改数据刷新回磁盘，进而<code>clear log</code></p></li><li><p><code>init_log()</code>: 初始化日志, 在xv6重启时会自动调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">initlog</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dev, struct superblock *sb)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(struct logheader) &gt;= BSIZE)<br>    panic(<span class="hljs-string">&quot;initlog: too big logheader&quot;</span>);<br><br>  initlock(&amp;<span class="hljs-built_in">log</span>.lock, <span class="hljs-string">&quot;log&quot;</span>);<br>  <span class="hljs-built_in">log</span>.start = sb-&gt;logstart;<br>  <span class="hljs-built_in">log</span>.size = sb-&gt;nlog;<br>  <span class="hljs-built_in">log</span>.dev = dev;<br>  recover_from_log();<br>&#125;<br></code></pre></td></tr></table></figure><p>只是简单地对<code>recover_from_log()</code>进行了封装而已</p></li></ul></li></ul><p>  <strong>Block Allocator</strong><br>  下面是xv6 fs 有关磁盘块分配与释放的代码</p><ul><li><p>balloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> uint</span><br><span class="hljs-function"><span class="hljs-title">balloc</span><span class="hljs-params">(uint dev)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 这里xv6貌似采用了可拓展的方案？</span><br>  <span class="hljs-comment">// 因为xv6的bit map只有一个block, 因此该循环至多也就执行一次</span><br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    <span class="hljs-comment">// 读出bitmap block</span><br>    bp = bread(dev, BBLOCK(b, sb));<br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      <span class="hljs-comment">// bp-&gt;[]得到的是8bit的一个字节</span><br>      <span class="hljs-comment">// 因此使用m表示bi正为于其所在字节的哪一位</span><br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        <span class="hljs-comment">// 将位图的该位标记位已经使用</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);<br>        brelse(bp);<br>        bzero(dev, b + bi);<br>        <span class="hljs-keyword">return</span> b + bi;         <span class="hljs-comment">// 这里b肯定就是0</span><br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>bfree()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 释放一个磁盘块</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param dev  指定设备</span><br><span class="hljs-comment"> * @param b    指定block num</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bfree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dev, uint b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-keyword">int</span> bi, m;<br><br>  bp = bread(dev, BBLOCK(b, sb));<br>  bi = b % BPB;                <span class="hljs-comment">// 这里肯定就是bi本身</span><br>  m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;freeing free block&quot;</span>);<br>  bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp;= ~m;        <span class="hljs-comment">// 将bitmap中的该位置0</span><br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-inode"><a href="#4-inode" class="headerlink" title="4. inode"></a>4. inode</h3><p>xv6中的<code>inode</code>分为磁盘中的<code>dinode</code>以及内存中的<code>inode</code>, 内存中的<code>inode</code>包含了更多内核所需要的额外信息</p><ul><li><p>dinode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-keyword">short</span> type;             <span class="hljs-comment">// File type</span><br>  <span class="hljs-keyword">short</span> major;            <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-keyword">short</span> minor;            <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-keyword">short</span> nlink;            <span class="hljs-comment">// Number of links to inode in file system(硬链接)</span><br>  uint size;              <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">2</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-keyword">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>                      <span class="hljs-comment">// 这里的引用计数是指在内存中有多少指针正指向该inode</span><br>                      <span class="hljs-comment">// 如果ref == 0, 那么内核救护清除inode在内存中的副本</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-keyword">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-keyword">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-keyword">short</span> major;<br>  <span class="hljs-keyword">short</span> minor;<br>  <span class="hljs-keyword">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">2</span>];  <br>&#125;;<br></code></pre></td></tr></table></figure><p>注意这里<code>nlink</code>与<code>ref</code>的区别:</p><p><code>nlink</code>代表有多少目录块正包含该<code>inode</code>, 这些目录块的数据块都存储在磁盘当中</p><p><code>ref</code>代表内存中引用该<code>inode</code>的指针数目，断电之后这些指针就会消失</p></li></ul><p>xv6同样使用了一个数据结构来维护内存中的整个<code>inode</code>区域</p><ul><li><p>icache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span>    <span class="hljs-comment">// NINODE == 50</span><br>&#125; icache;<br></code></pre></td></tr></table></figure><p>使用了一把全局锁来保护所有的<code>inode</code></p></li></ul><p>下面对<code>inode</code>的相关代码进行分析:</p><ul><li><p>iupdate(): 将更新后的内存<code>inode block</code>写回磁盘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">iupdate</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 每次更改icache中inode副本，都需要调用iupdate写入到磁盘</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>  dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br><br>  <span class="hljs-comment">// ip是新的inode缓存副本，dip是旧的磁盘inode</span><br>  dip-&gt;type = ip-&gt;type;<br>  dip-&gt;major = ip-&gt;major;<br>  dip-&gt;minor = ip-&gt;minor;<br>  dip-&gt;nlink = ip-&gt;nlink;<br>  dip-&gt;size = ip-&gt;size;<br>  memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>  <span class="hljs-comment">// 此次更新写入log</span><br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这里并没有真的写回磁盘，而只是将对<code>inode</code>块的修改写入了LOG中</p></li><li><p>itrunc(): 释放一个<code>inode</code>块以及其执行的<code>data</code>块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">itrunc</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  uint *a;<br>  <span class="hljs-comment">// 直接block块</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;addrs[i])&#123;<br>      bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>      ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 间接block块</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j])<br>        bfree(ip-&gt;dev, a[j]);<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 双重间接block</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j]) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp2</span> =</span> bread(ip-&gt;dev, a[j]);<br>        uint *a2 = (uint*)bp2-&gt;data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; k++)&#123;<br>          <span class="hljs-keyword">if</span>(a2[k])<br>            bfree(ip-&gt;dev, a2[k]);<br>        &#125;<br>        brelse(bp2);<br>        bfree(ip-&gt;dev, a[j]);<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ip-&gt;size = <span class="hljs-number">0</span>;<br>  iupdate(ip);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的代码是<code>lab8</code>中的代码，使用了双重间接指针</p></li><li><p>iget(): 从内存中获取inode的副本，如果没有就为其分配一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode*</span><br><span class="hljs-function"><span class="hljs-title">iget</span><span class="hljs-params">(uint dev, uint inum)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  <span class="hljs-comment">// empty负责记住一个空的inode slot</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-comment">// ip-&gt;ref &gt; 0 才能表示该inode是有效的数据</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br><br>  <span class="hljs-comment">// 在inode当中分配一个新的inode</span><br>  <span class="hljs-comment">// 但这里其实只是改了一些状态变量而已</span><br>  <span class="hljs-comment">// inode的真正数据还没有修改, 在ilock()中会进行数据的分配</span><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>iput(): 解除一个<code>inode</code>的引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 解除一个inode block在内存中的引用</span><br><span class="hljs-comment"> *        如果ref为0， 那么inode cache就可以将其替换出去了</span><br><span class="hljs-comment"> *        如果ref为0且nlinks为0， 即已经没有文件正在使用该</span><br><span class="hljs-comment"> *        inode了， 那么此时磁盘上的对应dinode就应该被释放 </span><br><span class="hljs-comment"> * @param ip </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">iput</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;ref == <span class="hljs-number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// inode has no links and no other references: truncate and free.</span><br><br>    <span class="hljs-comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span><br>    <span class="hljs-comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span><br>    acquiresleep(&amp;ip-&gt;lock);<br><br>    release(&amp;icache.lock);<br><br>    itrunc(ip);<br>    ip-&gt;type = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>    ip-&gt;valid = <span class="hljs-number">0</span>;<br><br>    releasesleep(&amp;ip-&gt;lock);<br><br>    acquire(&amp;icache.lock);<br>  &#125;<br><br>  ip-&gt;ref--;<br>  release(&amp;icache.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>iput()</code>有一些需要注意的点:</p><ul><li><p><code>iput()</code>中只给出了一个条件<code>if(ip-&gt;ref == 1 &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == 0)</code></p><p>仅当上面条件满足时才会释放<code>inode</code>的数据块</p></li><li><p>假设如下情况发生:<br>系统删除了所有某个文件的所有目录，此时其<code>nlink == 0</code>, 但是目前内存中仍有进程在读取该文件，即<code>ref != 0</code>, 那么当调用</p><p><code>iput()</code>时就不会释放该文件的数据(没有<code>itrunc()</code>, <code>ip-&gt;valid == 1</code>)</p><p>此时，如果突然<code>crash</code>, 那么当进程重启时，<code>ip-&gt;valid == 1</code>, 这也就意味着该<code>inode</code>块正在被使用，但是系统中却没有正在引用该<code>inode</code> 块的进程，此时<strong>xv6就永远失去了一些磁盘空间</strong></p></li><li><p>有两种方式处理这种情况：</p><p>一个简单的方法是，在系统启动的恢复阶段，文件系统扫描磁盘上的整个文件系统，检查是否有文件标记被分配，但是没有任何目录条目包含它，然后如果有，就删除释放这些文件</p><p>第二个方法是不需要扫描整个文件系统，而是在磁盘的某个位置上（例如超级块中），记录硬链接数为0，而指向其的指针数不为0的文件的<code>inode</code>号。如果该文件最后确实被删除释放了，那么就从该记录列表中移出相应的inode号。然后在系统启动的恢复阶段，不扫描整个文件系统，而是简单地扫描该列表，删除释放该列表中的文件即可</p></li><li></li></ul></li><li><p>ialloc(): 分配一个<code>inode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 在指定设备上分配一个inode</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param dev  指定设备</span><br><span class="hljs-comment"> * @param type  inode所代表文件的类型</span><br><span class="hljs-comment"> * @return struct inode*  分配的inode的指针，该inode处于 unlocked 且 referenced的状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct inode*</span><br><span class="hljs-function"><span class="hljs-title">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-keyword">short</span> type)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-comment">// 遍历所有inode, 找到一个空闲的inode，然后将其分配</span><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;<br>    <span class="hljs-comment">// 读取inode block</span><br>    bp = bread(dev, IBLOCK(inum, sb));<br>    dip = (struct dinode*)bp-&gt;data + inum%IPB;<br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      log_write(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      brelse(bp);<br>      <span class="hljs-keyword">return</span> iget(dev, inum);<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ilock(): 锁住给定的inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 锁住给定的inode, 必要时从磁盘读取inode</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param ip 指定inode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">ilock</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;ilock&quot;</span>);<br><br>  acquiresleep(&amp;ip-&gt;lock);<br><br>  <span class="hljs-comment">// ip-&gt;valid = 0表示inode虽然在内存Inode区域分配了</span><br>  <span class="hljs-comment">// 但是其内容还是无效的，没有与磁盘上的数据同步</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;valid == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 读取对应inode block</span><br>    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>    <span class="hljs-comment">// 读取block中的对应条目</span><br>    <span class="hljs-comment">// bp-&gt;data[ip-&gt;inum%IPB]</span><br>    dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br>    ip-&gt;type = dip-&gt;type;<br>    ip-&gt;major = dip-&gt;major;<br>    ip-&gt;minor = dip-&gt;minor;<br>    ip-&gt;nlink = dip-&gt;nlink;<br>    ip-&gt;size = dip-&gt;size;<br>    <span class="hljs-comment">// 拷贝</span><br>    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>    brelse(bp);  <span class="hljs-comment">// 释放之前获取的临时inode block缓存</span><br>    ip-&gt;valid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;ilock: no type&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>iunlock(): 解锁给定的<code>inode</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">iunlock</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;iunlock&quot;</span>);<br><br>  releasesleep(&amp;ip-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>Inode Content</strong></p><ul><li><p>inode 数据块布局</p><p><img src="3.png" alt="3"></p><p>xv6中的<code>dinode</code>中包含了12个直接块，1个间接块，每个间接块指向256个数据块</p></li></ul><p>下面是代码分析:</p><ul><li><p>bmap(): 返回<code>inode</code>中的第<code>bn</code>个块的磁盘地址</p><p>这里由于采用了间接指针，所以必要时需要递归的访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 返回inode中的第bn个块的磁盘地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param ip  给定inode</span><br><span class="hljs-comment"> * @param bn 第n个块</span><br><span class="hljs-comment"> * @return uint  数据块地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> uint</span><br><span class="hljs-function"><span class="hljs-title">bmap</span><span class="hljs-params">(struct inode *ip, uint bn)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>readi(): 将inode数据块的内容拷贝到<code>dst</code>中</p><p>开始时先检查读取是否合法，不能读超过文件大小的字节。然后主循环就会不断地读出文件相应的数据块，并把数据块的内容从<code>Buffer Cache</code>拷贝到<code>dst</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  从inode当中读取数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param ip        inode pointer</span><br><span class="hljs-comment"> * @param user_dst  为1表示dst是用户虚拟地址，否则表示dst是内核物理地址</span><br><span class="hljs-comment"> * @param dst       目的地址</span><br><span class="hljs-comment"> * @param off       相对于ip-&gt;addr的偏移量</span><br><span class="hljs-comment"> * @param n         拷贝的字节数</span><br><span class="hljs-comment"> * @return int      实际拷贝的字节数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">readi</span><span class="hljs-params">(struct inode *ip, <span class="hljs-keyword">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; ip-&gt;size)<br>    n = ip-&gt;size - off;<br><br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));<br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      tot = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>writei()</p><p><strong>writei</strong>如下，和<code>readi()</code>的架构相似，但有几个不同之处：</p><ul><li><p>writei可以超出文件大小，从而增长文件</p></li><li><p>与readi相反，writei拷贝数据到Buffer Cache中</p></li><li><p>一旦文件增长，就要更新其inode的大小信息</p></li></ul><p>值得一提的是，即便文件大小没有增长，也照样调用iupdate将inode写入磁盘，因为在调用bmap时可能分配了新的数据块，从而inode的addrs[ ]会被改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">writei</span><span class="hljs-params">(struct inode *ip, <span class="hljs-keyword">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; MAXFILE*BSIZE)<br>    <span class="hljs-comment">// off可以等于ip-&gt;size,这样就相当于增长文件，但off+n即期望文件总大小不能超过规定的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">// copies data into the buffers </span><br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));<br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存块被修改，将更新写入日志</span><br>    log_write(bp);<br>    brelse(bp);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size)<br>      ip-&gt;size = off;<br>    <span class="hljs-comment">// write the i-node back to disk even if the size didn&#x27;t change</span><br>    <span class="hljs-comment">// because the loop above might have called bmap() and added a new</span><br>    <span class="hljs-comment">// block to ip-&gt;addrs[].</span><br>    iupdate(ip);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>stati(): 将inode的元数据拷贝到位于内存中的struct stat，为上层的用户进程提供访问该inode元数据的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">stati</span><span class="hljs-params">(struct inode *ip, struct stat *st)</span></span><br><span class="hljs-function"></span>&#123;<br>  st-&gt;dev = ip-&gt;dev;<br>  st-&gt;ino = ip-&gt;inum;<br>  st-&gt;type = ip-&gt;type;<br>  st-&gt;nlink = ip-&gt;nlink;<br>  st-&gt;size = ip-&gt;size;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>stat结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>  <span class="hljs-keyword">int</span> dev;     <span class="hljs-comment">// File system&#x27;s disk device</span><br>  uint ino;    <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-keyword">short</span> type;  <span class="hljs-comment">// Type of file</span><br>  <span class="hljs-keyword">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>  uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-directory"><a href="#5-directory" class="headerlink" title="5. directory"></a>5. directory</h3><p>目录的实现机制与文件比较类似，它的<strong>inode</strong>类型是<strong>T_DIR</strong>，目录的<code>data</code>块中存储的是<code>dirent</code>结构的序列, <code>dirent</code>结构如下:</p><ul><li><p>dirent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 目录条目结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>  ushort inum;                <span class="hljs-comment">// 目录的inode num</span><br>  <span class="hljs-keyword">char</span> name[DIRSIZ];          <span class="hljs-comment">// 条目名 </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>即一个简单的{inum, name}对</p></li></ul><p><code>inode</code>为0的目录项是空闲的，在进行目录项的遍历是要将其忽略</p><p>下面介绍目录有关API</p><ul><li><p>dirlookup()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 在指定目录文件当中寻找一个目录条目</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param dp  目录的inode pointer</span><br><span class="hljs-comment"> * @param name  寻找的条目名称</span><br><span class="hljs-comment"> * @param[out] poff 寻找到的条目在数据块中的偏移量</span><br><span class="hljs-comment"> * @return struct inode*  找到的条目所对应的inode的内存副本指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct inode*</span><br><span class="hljs-function"><span class="hljs-title">dirlookup</span><span class="hljs-params">(struct inode *dp, <span class="hljs-keyword">char</span> *name, uint *poff)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint off, inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br><br>  <span class="hljs-comment">// 遍历所有的条目，查找指定文件</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-comment">// inode号为0的目录项是空闲的</span><br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// entry matches path element</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dirlink</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 将一个新的目录条目写入指定目录的data block中</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param dp  待写入的目录</span><br><span class="hljs-comment"> * @param name  条目name</span><br><span class="hljs-comment"> * @param inum  条目inum</span><br><span class="hljs-comment"> * @return int  0代表成功， -1代表失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">dirlink</span><span class="hljs-params">(struct inode *dp, <span class="hljs-keyword">char</span> *name, uint inum)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> off;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// Check that name is not present.</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 如果条目已经存在的话认为是错误</span><br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Look for an empty dirent.</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 找到一个空闲条目，将给定条目写入</span><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);<br>  de.inum = inum;<br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-path-name"><a href="#6-path-name" class="headerlink" title="6. path name"></a>6. path name</h3><p><code>path name</code>本身概念上没有什么可说的，主要是解析路径字符串的API较为繁杂</p><ul><li><p>skipelem()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 返回path对应的首元素, 将其(字符串)拷贝到name中 </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param path  给定路径名</span><br><span class="hljs-comment"> * @param name[out] path对应的首元素 </span><br><span class="hljs-comment"> * @return char* 首元素后面的路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>*</span><br><span class="hljs-function"><span class="hljs-title">skipelem</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 以a/bb/c为例</span><br>  <span class="hljs-keyword">char</span> *s;<br>  <span class="hljs-keyword">int</span> len;<br><br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  s = path; <span class="hljs-comment">// s == a</span><br>  <span class="hljs-keyword">while</span>(*path != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="hljs-number">0</span>)<br>    path++;<br>  len = path - s; <span class="hljs-comment">// len == 1</span><br>  <span class="hljs-keyword">if</span>(len &gt;= DIRSIZ)<br>    memmove(name, s, DIRSIZ);<br>  <span class="hljs-keyword">else</span> &#123;<br>    memmove(name, s, len);  <span class="hljs-comment">// name &lt;- &quot;a&quot;</span><br>    name[len] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">return</span> path;    <span class="hljs-comment">// path == &quot;bb/c&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>namex():  工具函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 查找并返回一个路径名对应的inode</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param path  给定的路径</span><br><span class="hljs-comment"> * @param nameiparent  如果nameiparent不为0， 那么会返回最后一个元素的父路径的inode, 并且</span><br><span class="hljs-comment"> *                     拷贝最后一个路径元素到name中</span><br><span class="hljs-comment"> *                     如a/b/c, 此时如果nameiparent !=0, 那么name = c, 返回的是a/b的inode</span><br><span class="hljs-comment"> * @param name[out]    写出的文件名 </span><br><span class="hljs-comment"> * @return struct inode* </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct inode*</span><br><span class="hljs-function"><span class="hljs-title">namex</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> nameiparent, <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">// 如果路径名以&#x27;/&#x27;开头则从根目录开始, 否则从当前工作目录开始</span><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>    ip = idup(myproc()-&gt;cwd);<br><br>  <span class="hljs-comment">// 以&quot;/a/b&quot;, nameiparent == 1为例</span><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 1. path == b, name = a</span><br>    ilock(ip);                                <span class="hljs-comment">// 2. paht == &#x27;0&#x27;, name = b</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.                // 2. stop! ip == &quot;/a&quot;对应的inode</span><br>      iunlock(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 1. next: &quot;/a&quot;的inode</span><br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    ip = next;                                <br>  &#125;<br>  <br>  <span class="hljs-comment">// 正常情况下nameiparent应该在主循环中返回</span><br>  <span class="hljs-comment">// 如果nameiparent运行到这就说明提前退出</span><br>  <span class="hljs-comment">// 由于iget()阶段refcnt++, 所以这里要复原</span><br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>nameiparent()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 返回path对应的父目录的inode</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param path  给定目录</span><br><span class="hljs-comment"> * @param name[out] 最底层元素</span><br><span class="hljs-comment"> * @return struct inode*  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct inode*</span><br><span class="hljs-function"><span class="hljs-title">nameiparent</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">1</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>namei()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  返回path的inode</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param path </span><br><span class="hljs-comment"> * @return struct inode* </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct inode*</span><br><span class="hljs-function"><span class="hljs-title">namei</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> name[DIRSIZ];<br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">0</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-file-descriptor"><a href="#7-file-descriptor" class="headerlink" title="7. file descriptor"></a>7. file descriptor</h3><p>xv6中使用了两张表来维护所有打开的文件，一张是每个进程自身的<strong>打开文件表</strong><code>ofile</code></p><ul><li><p>proc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files, NOFILE = 16</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是一个数组, 数组的每个条目是进程打开的文件</p></li></ul><p>另一张是<strong>全局打开文件表</strong><code>ftable</code></p><ul><li><p>ftable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">file</span>[<span class="hljs-title">NFILE</span>];</span>  <span class="hljs-comment">// NFILE == 100</span><br>&#125; ftable;<br></code></pre></td></tr></table></figure><p>该表中记录了系统中正处于打开状态的所有文件实例, xv6中最多能同时打开100个文件</p></li></ul><p>并不是每一个文件都有一个与之对应的<code>file</code>结构体，而是每个<strong>打开的</strong>文件都有一个对应的<code>file</code>结构体, 如果一个文件被打开(open())多次，那么它就会有多个<code>file</code>实例</p><ul><li><p>file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-keyword">int</span> ref;            <span class="hljs-comment">// reference count</span><br>  <span class="hljs-keyword">char</span> readable;<br>  <span class="hljs-keyword">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-keyword">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每个打开的文件在内存中对应的<code>file</code>实例维护了文件的打开状态，包括</p><ol><li><p>文件类型</p><p>xv6将文件类型分为了4类：</p><ol><li>FD_NONE: 已关闭文件</li><li>FD_PIPE: 管道文件</li><li>FD_INODE: 普通文件</li><li>FD_DEVICE: 设备文件</li></ol></li><li><p>文件权限(r/w)</p></li><li><p>文件偏移量</p><p>由于每个进程打开一个文件后都会产生一个对应的file实例，因此多个进程会有着不同的文件偏移量</p></li></ol></li></ul><p>下面介绍相关函数</p><ul><li><p>filealloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 分配一个file结构体</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return struct file*  分配的file结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct file*</span><br><span class="hljs-function"><span class="hljs-title">filealloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-comment">// 遍历全局打开文件表，寻找空闲槽位，然后将其标记位可用</span><br>  <span class="hljs-keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;ref == <span class="hljs-number">0</span>)&#123;<br>      f-&gt;ref = <span class="hljs-number">1</span>;<br>      release(&amp;ftable.lock);<br>      <span class="hljs-keyword">return</span> f;<br>    &#125;<br>  &#125;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>filedup()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 创建一个打开文件的副本</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f  给定打开文件</span><br><span class="hljs-comment"> * @return struct file*  打开文件结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct file*</span><br><span class="hljs-function"><span class="hljs-title">filedup</span><span class="hljs-params">(struct file *f)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;filedup&quot;</span>);<br>  f-&gt;ref++;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里所做的操作很简单，只是将打开文件的引用计数+1, 然后返回相同的<code>file</code>结构体指针</p></li><li><p>fileclose()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  关闭文件f</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f  被关闭的文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">fileclose</span><span class="hljs-params">(struct file *f)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">ff</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;fileclose&quot;</span>);<br>  <span class="hljs-comment">// 仅当引用计数为0时才真正地做释放操作</span><br>  <span class="hljs-keyword">if</span>(--f-&gt;ref &gt; <span class="hljs-number">0</span>)&#123;<br>    release(&amp;ftable.lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ff = *f;      <span class="hljs-comment">// 获取一份拷贝</span><br>  f-&gt;ref = <span class="hljs-number">0</span>;<br>  f-&gt;type = FD_NONE;<br>  release(&amp;ftable.lock);<br><br><br>  <span class="hljs-comment">// 根据文件的不用类型做出判断</span><br>  <span class="hljs-keyword">if</span>(ff.type == FD_PIPE)&#123;<br>    pipeclose(ff.pipe, ff.writable);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;<br>    begin_op();<br>    iput(ff.ip);<br>    end_op();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>filestat()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  获取文件的相关状态</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f    待访问文件</span><br><span class="hljs-comment"> * @param addr struct stat的地址</span><br><span class="hljs-comment"> * @return int  成功返回0， 否则返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">filestat</span><span class="hljs-params">(struct file *f, uint64 addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;<br>    ilock(f-&gt;ip);<br>    stati(f-&gt;ip, &amp;st);<br>    iunlock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-keyword">char</span> *)&amp;st, <span class="hljs-keyword">sizeof</span>(st)) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只允许获取普通文件或者设备文件的状态</p></li><li><p>fileread()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 从文件读取内容</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f  待读取文件</span><br><span class="hljs-comment"> * @param addr 缓冲区地址</span><br><span class="hljs-comment"> * @param n 读取字节数</span><br><span class="hljs-comment"> * @return int  读取的字节数，失败的话返回-1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fileread</span><span class="hljs-params">(struct file *f, uint64 addr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;readable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    r = piperead(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    r = devsw[f-&gt;major].read(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    ilock(f-&gt;ip);<br>    <span class="hljs-comment">// 从文件的当前偏移量开始读取, 由于偏移量off会被更新，因此加锁</span><br>    <span class="hljs-keyword">if</span>((r = readi(f-&gt;ip, <span class="hljs-number">1</span>, addr, f-&gt;off, n)) &gt; <span class="hljs-number">0</span>)<br>         f-&gt;off += r;<br>    iunlock(f-&gt;ip);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;fileread&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fwrite()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 向文件写内容</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f  待写入文件</span><br><span class="hljs-comment"> * @param addr  缓冲区地址</span><br><span class="hljs-comment"> * @param n     写入字节数</span><br><span class="hljs-comment"> * @return int 写入的字节数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">filewrite</span><span class="hljs-params">(struct file *f, uint64 addr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> r, ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;writable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    ret = pipewrite(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    <span class="hljs-comment">// write a few blocks at a time to avoid exceeding</span><br>    <span class="hljs-comment">// the maximum log transaction size, including</span><br>    <span class="hljs-comment">// i-node, indirect block, allocation blocks,</span><br>    <span class="hljs-comment">// and 2 blocks of slop for non-aligned writes.</span><br>    <span class="hljs-comment">// this really belongs lower down, since writei()</span><br>    <span class="hljs-comment">// might be writing a device like the console.</span><br>    <span class="hljs-comment">// 这里采用小批量多次写的操作来完成</span><br>    <span class="hljs-comment">// 因为日志区域优先，一次性写入太多可能会导致日志区域</span><br>    <span class="hljs-comment">// 不够</span><br>    <span class="hljs-keyword">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-1</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>      <span class="hljs-keyword">int</span> n1 = n - i;<br>      <span class="hljs-keyword">if</span>(n1 &gt; max)<br>        n1 = max;<br><br>      begin_op();<br>      ilock(f-&gt;ip);<br>      <span class="hljs-keyword">if</span> ((r = writei(f-&gt;ip, <span class="hljs-number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="hljs-number">0</span>)<br>        f-&gt;off += r;<br>      iunlock(f-&gt;ip);<br>      end_op();<br><br>      <span class="hljs-keyword">if</span>(r != n1)&#123;<br>        <span class="hljs-comment">// error from writei</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      i += r;<br>    &#125;<br>    ret = (i == n ? n : <span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;filewrite&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>fdalloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 给一个打开的文件分配一个文件描述符</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param f </span><br><span class="hljs-comment"> * @return int </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fdalloc</span><span class="hljs-params">(struct file *f)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">for</span>(fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd] == <span class="hljs-number">0</span>)&#123;<br>      p-&gt;ofile[fd] = f;<br>      <span class="hljs-keyword">return</span> fd;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从该函数中我们可以看出，当一个进程打开文件时，分配到的文件描述符永远是当前自己可以获得的最小文件描述符，与打开什么文件没有关系</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:pipe</title>
    <link href="/2022/03/29/xv6-pipe/"/>
    <url>/2022/03/29/xv6-pipe/</url>
    
    <content type="html"><![CDATA[<p>直接看代码</p><ul><li><p>pipe结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-keyword">char</span> data[PIPESIZE];<br>  uint nread;     <span class="hljs-comment">// number of bytes read</span><br>  uint nwrite;    <span class="hljs-comment">// number of bytes written</span><br>  <span class="hljs-keyword">int</span> readopen;   <span class="hljs-comment">// read fd is still open</span><br>  <span class="hljs-keyword">int</span> writeopen;  <span class="hljs-comment">// write fd is still open</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li> <code>pipe</code>中的<code>data</code>使用环型计数</li><li> <code>nread</code>以及<code>nwrite</code>不使用环型计数</li><li> 缓冲区满: <code>nwrite == nread + PIPESIZE</code></li><li> 缓冲区空: <code>nwrite == n</code></li></ul></li><li><p>pipewrite()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">pipewrite</span><span class="hljs-params">(struct pipe *pi, uint64 addr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">char</span> ch;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-comment">// 缓冲区满, 唤醒那些reader进程, writer进程陷入sleep</span><br>    <span class="hljs-keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="hljs-comment">//DOC: pipewrite-full</span><br>      <span class="hljs-keyword">if</span>(pi-&gt;readopen == <span class="hljs-number">0</span> || pr-&gt;killed)&#123;<br>        release(&amp;pi-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      wakeup(&amp;pi-&gt;nread);<br>      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);<br>    &#125;<br>     <span class="hljs-comment">// 每字节写入</span><br>    <span class="hljs-keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nread);<br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>piperead()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">piperead</span><span class="hljs-params">(struct pipe *pi, uint64 addr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-keyword">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-comment">// 没有数据可读</span><br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>    <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br>  <span class="hljs-comment">// 每字节读取数据到addr</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 读取完毕之后唤醒writer进程</span><br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:wait-exit-kill</title>
    <link href="/2022/03/29/xv6-wait-exit-kill/"/>
    <url>/2022/03/29/xv6-wait-exit-kill/</url>
    
    <content type="html"><![CDATA[<h4 id="1-wait"><a href="#1-wait" class="headerlink" title="1. wait"></a>1. wait</h4><p>xv6中并没有实现Linux中的信号(signal)机制，当一个子进程终止时，如果其父进程还未终止，那么其会将自己的<code>state</code>设置为<code>ZOMBIE</code>, </p><p>然后<code>wakeup()</code>正处于<code>wait()</code>状态的父进程，父进程遍历进程表，找到<code>state</code>为<code>ZOMBIE</code>的子进程，然后释放其资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** @param addr 子进程状态写入的地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">(uint64 addr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-keyword">int</span> havekids, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// hold p-&gt;lock for the whole time to avoid lost</span><br>  <span class="hljs-comment">// wakeups from a child&#x27;s exit().</span><br>  <span class="hljs-comment">// 获取p-&gt;lock避免丢失唤醒</span><br>  acquire(&amp;p-&gt;lock);<br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Scan through table looking for exited children.</span><br>    havekids = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;<br>      <span class="hljs-comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span><br>      <span class="hljs-comment">// acquiring the lock first would cause a deadlock,</span><br>      <span class="hljs-comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span><br>      <span class="hljs-comment">// 这里没有使用np-&gt;lock因为在扫描进程表过程中</span><br>      <span class="hljs-comment">// 可能会扫描到p的祖先(ap)，如果ap也正在使用wait, 那么它就会持有ap-&gt;lock(417行)</span><br>      <span class="hljs-comment">// 此时就会发生deadlock</span><br>      <span class="hljs-keyword">if</span>(np-&gt;parent == p)&#123;<br>        <span class="hljs-comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span><br>        <span class="hljs-comment">// because only the parent changes it, and we&#x27;re the parent.</span><br>        acquire(&amp;np-&gt;lock);<br>        havekids = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 检查处于ZOMBIE状态的子进程，将其回收</span><br>        <span class="hljs-keyword">if</span>(np-&gt;state == ZOMBIE)&#123;<br>          <span class="hljs-comment">// Found one.</span><br>          pid = np-&gt;pid;<br>          <span class="hljs-keyword">if</span>(addr != <span class="hljs-number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="hljs-keyword">char</span> *)&amp;np-&gt;xstate,<br>                                  <span class="hljs-keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="hljs-number">0</span>) &#123;<br>            release(&amp;np-&gt;lock);<br>            release(&amp;p-&gt;lock);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>          &#125;<br>          <span class="hljs-comment">// 释放子进程的最后资源</span><br>          freeproc(np);<br>          release(&amp;np-&gt;lock);<br>          release(&amp;p-&gt;lock);<br>          <span class="hljs-keyword">return</span> pid;<br>        &#125;<br>        release(&amp;np-&gt;lock);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No point waiting if we don&#x27;t have any children.</span><br>    <span class="hljs-keyword">if</span>(!havekids || p-&gt;killed)&#123;<br>      release(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Wait for a child to exit.</span><br>    <span class="hljs-comment">// 子进程还未退出, sleep等待</span><br>    <span class="hljs-comment">// sleep在自己身上， 即p-&gt;chan = p</span><br>    sleep(p, &amp;p-&gt;lock);  <span class="hljs-comment">//DOC: wait-sleep</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-exit"><a href="#2-exit" class="headerlink" title="2. exit"></a>2. exit</h4><p>当一个进程退出时，需要让<code>init</code>进程收养自己的子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 一个子进程退出之后会变为僵尸进程, 直到父进程调用wait()将其回收</span><br><span class="hljs-comment">// exit()并没有释放子进程的所有资源，因为其正在运行当中，如果贸然释放</span><br><span class="hljs-comment">// 会产生很多问题， 因为等子进程退出之后，再由父进程的wait()来释放子进程的资源</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-comment">// 1.关闭所有的打开文件</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 进程对与当前目录的一个引用，需要将其释放给文件系统</span><br>  <span class="hljs-comment">// 因为文件系统中使用了引用计数</span><br>  begin_op();<br>  iput(p-&gt;cwd);<br>  end_op();<br>  p-&gt;cwd = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// we might re-parent a child to init. we can&#x27;t be precise about</span><br>  <span class="hljs-comment">// waking up init, since we can&#x27;t acquire its lock once we&#x27;ve</span><br>  <span class="hljs-comment">// acquired any other proc lock. so wake up init whether that&#x27;s</span><br>  <span class="hljs-comment">// necessary or not. init may miss this wakeup, but that seems</span><br>  <span class="hljs-comment">// harmless.</span><br>  acquire(&amp;initproc-&gt;lock);<br>  wakeup1(initproc);<br>  release(&amp;initproc-&gt;lock);<br><br>  <span class="hljs-comment">// grab a copy of p-&gt;parent, to ensure that we unlock the same</span><br>  <span class="hljs-comment">// parent we locked. in case our parent gives us away to init while</span><br>  <span class="hljs-comment">// we&#x27;re waiting for the parent lock. we may then race with an</span><br>  <span class="hljs-comment">// exiting parent, but the result will be a harmless spurious wakeup</span><br>  <span class="hljs-comment">// to a dead or wrong process; proc structs are never re-allocated</span><br>  <span class="hljs-comment">// as anything else.</span><br>  <span class="hljs-comment">// 这里是为了防止子进程与父进程同时退出</span><br>  acquire(&amp;p-&gt;lock);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">original_parent</span> =</span> p-&gt;parent;<br>  release(&amp;p-&gt;lock);<br>  <br>  <span class="hljs-comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span><br>  <span class="hljs-comment">// the parent-then-child rule says we have to lock it first.</span><br>  <span class="hljs-comment">// </span><br>  acquire(&amp;original_parent-&gt;lock);<br><br>  acquire(&amp;p-&gt;lock);<br><br>  <span class="hljs-comment">// Give any children to init.</span><br>  <span class="hljs-comment">// 让init进程收养当前进程的子进程</span><br>  reparent(p);<br><br>  <span class="hljs-comment">// Parent might be sleeping in wait().</span><br>  <span class="hljs-comment">// 唤醒父进程</span><br>  wakeup1(original_parent);<br><br>  p-&gt;xstate = status;<br>  p-&gt;state = ZOMBIE;<br><br>  <span class="hljs-comment">// 释放父进程的锁</span><br>  release(&amp;original_parent-&gt;lock);<br><br>  <span class="hljs-comment">// Jump into the scheduler, never to return.</span><br>  <span class="hljs-comment">// 此时进程的资源还没有完全释放，进入到调度器线程</span><br>  sched();<br>  <span class="hljs-comment">// 由于进程的state为ZOMBIE, 因此其不会被调度</span><br>  panic(<span class="hljs-string">&quot;zombie exit&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-kill"><a href="#3-kill" class="headerlink" title="3. kill"></a>3. kill</h4><p>在xv6中， <code>kill</code>所做的事其实十分少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;pid == pid)&#123;<br>      <span class="hljs-comment">// 这里基本上没有干什么事情</span><br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING)&#123;<br>        <span class="hljs-comment">// Wake process from sleep().</span><br>        p-&gt;state = RUNNABLE;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有短短20行，可以看出，kill并没有直接杀死进程，因为当对一个进程执行<code>kill</code>操作的时候，进程可能正在更新某些数据，也可能正在创建一个文件，它们还可能持有锁，因此，直接杀死进程会导致一系列问题</p><p>xv6中的做法十分温和，仅仅是将进程的<code>killed</code>标志位置为了1，但是对于处于<code>SLEEPING</code>状态的进程有着特殊处理，接下来会说<br>通过将进程的<code>killed</code>标志位置为1， 然后在一些<strong>安全的地方</strong>对<code>killed</code>标志位进行检查，这样可以确保进程安全的退出</p><p>来看一个例子:</p><ul><li><p>trap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">usertrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br> ...<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br>    <span class="hljs-comment">// 第一处</span><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果进程发现killed标志位为1，会自愿调用exit()退出</span><br>  <span class="hljs-comment">// 在这里，进程并没有持有任何的锁</span><br>  <span class="hljs-comment">// 第二处</span><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>usertrap</code>当中，有两处这样的<code>killed</code>标志位检查， 当程序运行到这时，是没有锁的，并且也没有什么更新动作，即<strong>安全</strong></p><p>所以，通常，当<code>kill()</code>“杀死”进程后，该进程通常不会立即死亡，而是会在下一次的某个系统调用/计时器中断/设备中断时自愿的调用<code>exit()</code>退出</p></li></ul><p><strong>特殊的SLEEPING</strong></p><p>设想这样一种情况，当一个进程正在读取控制台输入，那么它会进入<code>SLEEPING</code>状态，而用户<code>kill()</code>该进程之后就没有继续理这个进程了，因此该进程就一直不会退出，因为其没有陷入<code>trap</code>, 所以，xv6的代码对<code>SLEEPING</code>状态的进程做了特殊处理，使其变为<code>RUNNABLE</code>,在接下来的某个时刻，中断调度线程就会调度该进程，该进程便会从<code>sleep()</code>中返回，下面是一个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">piperead</span><span class="hljs-params">(struct pipe *pi, uint64 addr, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-keyword">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-comment">// 没有数据可读</span><br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>      <span class="hljs-comment">// *************************************************//</span><br>      <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>      <span class="hljs-comment">//*************************************************//</span><br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br>  <span class="hljs-comment">// 每字节读取数据到addr</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 读取完毕之后唤醒writer进程</span><br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，当进程从<code>sleep()</code>中返回之后，便会重新进入循环，通常情况下仍然没有数据可读，进而<code>return -1</code></p><p>然后回到<code>usertrap()</code>的<code>syscall()</code>处，最后检查到<code>killed</code>标志位为1， 自愿<code>exit()</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:sleep-and-wakeup</title>
    <link href="/2022/03/29/xv6-sleep-and-wakeup/"/>
    <url>/2022/03/29/xv6-sleep-and-wakeup/</url>
    
    <content type="html"><![CDATA[<p>类似于<code>pthread</code>中的条件变量，xv6中也实现了与<code>pthread_cond_wait()</code>和<code>pthread_cond_broadcast()</code>类似的操作</p><p>在xv6中的对应api为<code>sleep()</code>以及<code>wakeup()</code></p><ul><li><p>sleep()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">oid</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *chan, struct spinlock *lk)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// 这里有两把锁, 一把是进程锁，一把是给定的lk</span><br>  <span class="hljs-comment">// 当进程调用该函数时，其需要获取进程锁p-&gt;lock, 因为接下来需要修改进程的state</span><br>  <span class="hljs-comment">// 同时进程还需要释放lk, 因为这是sleep函数所要求的</span><br>  <span class="hljs-comment">// 注意这里lk与p-&gt;lock是同一把锁的问题, 如果是同一把锁，那么acquire()操作就会造成死锁</span><br>  <span class="hljs-keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="hljs-comment">//DOC: sleeplock0</span><br>    acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1</span><br>    release(lk);<br>  &#125;<br><br>  <span class="hljs-comment">// Go to sleep.</span><br>  p-&gt;chan = chan;<br>  p-&gt;state = SLEEPING;<br><br>  <span class="hljs-comment">// 此时进程还持有着p-&gt;lock</span><br>  sched();  <span class="hljs-comment">// p-&gt;lock被scheduler释放 </span><br>  <span class="hljs-comment">// 此时进程已经从调度返回, 已经在scheduler()中重新获得了锁</span><br>  <span class="hljs-comment">// Tidy up.</span><br>  p-&gt;chan = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Reacquire original lock.</span><br>  <span class="hljs-keyword">if</span>(lk != &amp;p-&gt;lock)&#123;<br>    release(&amp;p-&gt;lock);<br>    acquire(lk);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>wakeup()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 唤醒所有睡在chan上的进程</span><br><span class="hljs-comment">// 这里的实际操作其实就是将进程的状态改为(RUNNABLE)可调度</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *chan)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 在调用wakeup时，会持有sleep()中指定的锁lk</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-comment">// wakeup什么时候进入该行?</span><br>    <span class="hljs-comment">// 有两种情况: </span><br>    <span class="hljs-comment">// 1. sleep()中的lk与p-&gt;lock不是同一把锁, 那么在sleep()中的sched()进入scheduler()</span><br>    <span class="hljs-comment">// 并且释放p-&gt;lock之后，wakeup()可以进入该行，此时p-&gt;state == SLEEPING, 没有丢失唤醒</span><br>    <span class="hljs-comment">// 2. sleep()中的lk与p-&gt;lock是同一把锁, 这种情况和上面一样，也是在schedule()释放p-&gt;lock之后</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<br>      p-&gt;state = RUNNABLE;<br>    &#125;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="丢失唤醒"><a href="#丢失唤醒" class="headerlink" title="丢失唤醒"></a>丢失唤醒</h4><p>下面是一个会产生丢失唤醒的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V</span><span class="hljs-params">(struct semaphore *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;s-&gt;lock);<br>  s-&gt;count += <span class="hljs-number">1</span>;<br>  wakeup(s);<br>  release(&amp;s-&gt;lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P</span><span class="hljs-params">(struct semaphore *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (s-&gt;count == <span class="hljs-number">0</span>)<br>    sleep(s);<br>  acquire(&amp;s-&gt;lock);<br>  s-&gt;count -= <span class="hljs-number">1</span>;<br>  release(&amp;s-&gt;lock);<br><br></code></pre></td></tr></table></figure><ul><li>假设当进程<code>p1</code>调用<code>P</code>, 进入第11行，发现<code>s-&gt;count == 0</code>, 准备进入第12行</li><li>此时发生计时器中断，进程<code>p2</code>调用<code>V</code>, <code>s-&gt;count</code>变为1, 然后进入第5行，调用<code>wakeup()</code>, 尽管此时并没有进程睡在信号量<code>s</code>之上</li><li>计时器再次中断，进程<code>p1</code>重新开始执行，进入第12行，陷入<code>sleep()</code>, 而此时<code>s-&gt;count</code>却是1而不是0， 这就叫<strong>丢失唤醒</strong></li><li>当发生丢失唤醒之后，除非再次有进程调用<code>V</code>, 否则进程<code>p1</code>将一直陷入睡眠</li></ul><p>xv6的实现中不会发生丢失唤醒的问题, 因为其在进行<code>state</code>的设置之前先获取了<code>p-&gt;lock</code>, 这样如果其它进程想要调用<code>wakeup</code>唤醒<code>state</code>还未设置为<code>SLEEPING</code>的进程时就会陷入阻塞</p><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>当多个进程睡在同一个条件之下，就有可能发生虚假唤醒的问题，xv6的实现也可能发生这种情况</p><ul><li><p>例子</p><ul><li><p>假设当前有进程<code>p1</code>, <code>p2</code>, 他们都调用了<code>sleep(g-&gt;chan, g-&gt;lock)</code>, 即睡在同一个条件，同一把锁之上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (read(fd) == <span class="hljs-number">0</span>) <br>    sleep(&amp;g-&gt;chan, &amp;g-&gt;lock);<br>release(g-&gt;lock);<br></code></pre></td></tr></table></figure></li><li><p>此时进程<code>p3</code>对文件写入,调用<code>wakeup()</code>, 进程<code>p1</code>, <code>p2</code>都被唤醒，此时它们会对<code>g-&gt;lock</code>进行竞争，假设<code>p1</code>先抢到了<code>g-&gt;lock</code></p></li><li><p>其使用<code>read()</code>将文件<code>fd</code>中的内容全部读取完毕,  然后进入第三行, 释放锁</p></li><li><p>计时器发生中断，调度到进程<code>p2</code>,进程<code>p2</code>抢到锁，执行<code>read()</code>, 却发现此时文件是空的, 它被唤醒了却什么都做不了, 这就叫<strong>虚假唤醒</strong></p></li></ul><p>虚假唤醒最有效的解决方案就是将<code>sleep()</code>置于循环当中，当发生虚假唤醒时，使被唤醒的进程再度<code>sleep(0</code>)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:调度</title>
    <link href="/2022/03/29/xv6-%E8%B0%83%E5%BA%A6/"/>
    <url>/2022/03/29/xv6-%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-xv中的线程与进程"><a href="#1-xv中的线程与进程" class="headerlink" title="1. xv中的线程与进程"></a>1. xv中的线程与进程</h3><ul><li><p>分时复用</p><p>xv6中采用的也是分时复用，即每个进程在CPU上运行一段时间，计时器超时过后引发<code>trap</code>,  然后再由调度器调度其它进程在CPU上运行，使得<strong>每个进程以为自己独占CPU</strong> </p></li><li><p>内核线程与调度线程</p><p>在xv6中，每个进程只有一个线程，该线程运行在内核当中，被称为<strong>内核线程</strong>, 这样做主要是为了简单，Linux这种复杂系统中，除了内核线程之外还拥有用户线程.</p><p>在每个CPU当中，还运行着一个<strong>调度线程</strong>，该线程负责不同内核线程之间的调度，当一个内核线程<code>t1</code>发生定时器中断时，就会自愿放弃CPU, 此时内核线程会首先切换为调度线程，然后调度线程再找出合适的其它内核线程<code>t2</code>，然后将CPU让给该内核线程</p><p>在xv6中，对于CPU来说，在任意时刻只能有一个线程正在运行，该线程只能是以下线程中的一个:</p><ul><li>内核线程</li><li>调度线程</li></ul></li><li><p>xv中的上下文(context)</p><p>所谓的上下文其实就是一系列寄存器, xv中的<code>context</code>结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>  uint64 ra;          <span class="hljs-comment">// 返回地址寄存器, 通过该寄存器，swtch会返回到不同线程当中</span><br>  uint64 sp;          <span class="hljs-comment">// stack pointer</span><br><br>  <span class="hljs-comment">// callee-saved     // 被调用者保存寄存器</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 所谓的<strong>上下文切换</strong>其实就是保存旧进程的寄存器值，加载新进程的寄存器的值, 这些值都会被保存在进程的<code>trapframe</code>中</p><p><strong>xv6中并没有使用一种特定的结构体来表示，而是使用了<code>proc</code>结构体中的<code>context</code>字段来表示该进程对应的内核线程</strong>, 因此在xv6中中，进程与线程的区别不是太大</p></li></ul><h3 id="2-调度实现"><a href="#2-调度实现" class="headerlink" title="2. 调度实现"></a>2. 调度实现</h3><ul><li><p>线程调度示意图</p><p><img src="1.png" alt="1"></p></li></ul><p>下面是对xv6中进程/线程调度流程的简要分析:</p><ul><li><p>进程<code>p1</code>的时间分片结束，计时器产生中断，陷入<code>trap</code></p></li><li><p><code>trap handler</code>发现为计时器中断，调用<code>yield()</code>计时器中断处理程序</p></li><li><p><code>yield()</code>将进程的状态由<code>RUNNING</code>改为<code>RUNABLE</code>，表示其在调度完毕之后可以被重新调度</p><p>紧接着调用<code>sched()</code></p></li><li><p><code>sched()</code>会对原进程的状态进行检查，然后跳转到<code>swtch.S</code>进行真正的上下文切换，切换到CPU的调度线程<code>scheduler</code></p></li><li><p>当跳转到<code>scheduler</code>中时，并不是直接跳转到函数首部，而是跳转到<code>scheduler</code>中的<code>swtch</code>调用后面的一条指令</p><p>接下来，在<code>scheduler</code>中会在全局进程表中挑选出可调度(<code>RUNABLE</code>)的新进程，再次调用<code>swtch</code>,切换到新进程</p></li><li><p>此时，会再次跳转到<code>sched()</code>中的<code>swtch.S</code>, 不过此时在CPU上运行的已经是新进程了</p></li></ul><p>在上面的例子中， <code>swtch</code>调用就像是一个传送门，从旧线程的<code>swtch</code>(p1)会跳转到<code>scheduler</code>的<code>swtch</code>(p2), 然后再从<code>scheduler</code>中的第二次<code>swtch</code>(p3)中跳转到(p1), 不过此时已经是新进程了</p><p>下面进行具体代码分析:</p><ul><li><p>kernel/trap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-comment">// 计时器中断</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br></code></pre></td></tr></table></figure><p><code>trap</code>处理程序发现为计时器中断, 调用<code>yield()</code></p></li><li><p>kernel/proc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">yield</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 让出CPU</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);<br>  <span class="hljs-comment">// 该lock将会一直持有，直到sched()返回一个新进程</span><br>  <span class="hljs-comment">// 这里lock的作用有三个:</span><br>  <span class="hljs-comment">// 1.保护p-&gt;state为RNNNABLE</span><br>  <span class="hljs-comment">// 2.保护trapframe中的寄存器不被更改</span><br>  <span class="hljs-comment">// 3.停止使用当前进程的内核栈，防止两个CPU使用同一个内核栈</span><br>  <span class="hljs-comment">// 总结： 1. 防止其它CPU的调度器调度这个进程，因为该进程正处于调度当中</span><br>  <span class="hljs-comment">//       2. acquire会关中断，防止swtch过程被中断导致寄存器保存不完整</span><br>  <span class="hljs-comment">// 将进程的状态改为RUNNABLE, 表示其可被调度</span><br>  p-&gt;state = RUNNABLE;<br>  <span class="hljs-comment">//************************************旧进程******************************//</span><br>  sched();<br>  <span class="hljs-comment">//************************************新进程*****************************//</span><br>  <span class="hljs-comment">// 运行到此时为新进程了，接下来释放原进程的lock</span><br>  release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>yield()</code>的作用包括:</p><ul><li>获取旧进程的锁</li><li>将旧进程的状态改为<code>RUNNABLE</code></li><li>调用<code>sched()</code>, 变为新进程</li><li>释放掉原进程的锁</li></ul></li><li><p>kernel/proc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">sched</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 进程调度</span><br>  <span class="hljs-keyword">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// 检查是否持有锁, 持有其它锁时无法放弃CPU</span><br>  <span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br><br>  <span class="hljs-comment">// 检测中断嵌套的层数，因为acquire会关闭中断，且中断可以叠加</span><br>  <span class="hljs-comment">// 其实本质上是在看旧线程acquire()获得锁的个数，这里一定得是1个</span><br>  <span class="hljs-comment">// 主要是为了预防死锁发生，因为如果旧线程还有其它锁m, 那么当调度到</span><br>  <span class="hljs-comment">// 新线程时，新线程可能也会尝试获取锁m, 此时就有可能会导致死锁发生</span><br>  <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <br>  <span class="hljs-comment">// 检查运行状态</span><br>  <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br><br>  <span class="hljs-comment">// 检查中断状态</span><br>  <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;  <span class="hljs-comment">// 在push_off之前是否interrupt enable</span><br>  <span class="hljs-comment">// 开始进行调度，准备切换上下文/线程</span><br>  <span class="hljs-comment">// 注意这里使用的新上下文是mycpu()-&gt;context, 即CPU的swtch调度线程</span><br>  <span class="hljs-comment">//*****************旧线程********************************//</span><br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  <span class="hljs-comment">//*****************新线程*******************************//</span><br>  <span class="hljs-comment">// 当执行到这时，已经切换到新内核线程了, 接下来会返回yield</span><br>  mycpu()-&gt;intena = intena;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sched()</code>中所做的工作包括:</p><ul><li>检查当前CPU的持有进程(旧进程)的各种状态:<ol><li>是否持有旧进程的锁</li><li>是否仅持有一个锁</li><li>是否关闭了中断</li></ol></li><li>调用<code>swtch</code>汇编代码，切换到<strong>调度线程</strong></li></ul></li><li><p><code>switch.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 上下文的切换<br># 保存旧线程的寄存器，然后加载新线程的寄存器<br># 这里的寄存器与proc.h中的context.h<br><br>.globl swtch<br>swtch:<br>        sd ra, 0(a0)<br>        sd sp, 8(a0)<br>        sd s0, 16(a0)<br>        sd s1, 24(a0)<br>        sd s2, 32(a0)<br>        sd s3, 40(a0)<br>        sd s4, 48(a0)<br>        sd s5, 56(a0)<br>        sd s6, 64(a0)<br>        sd s7, 72(a0)<br>        sd s8, 80(a0)<br>        sd s9, 88(a0)<br>        sd s10, 96(a0)<br>        sd s11, 104(a0)<br><br>        ld ra, 0(a1)   // 关键点, ra为 return address返回地址寄存器<br>        ld sp, 8(a1)<br>        ld s0, 16(a1)<br>        ld s1, 24(a1)<br>        ld s2, 32(a1)<br>        ld s3, 40(a1)<br>        ld s4, 48(a1)<br>        ld s5, 56(a1)<br>        ld s6, 64(a1)<br>        ld s7, 72(a1)<br>        ld s8, 80(a1)<br>        ld s9, 88(a1)<br>        ld s10, 96(a1)<br>        ld s11, 104(a1)<br>        <br>        ret<br><br></code></pre></td></tr></table></figure><p>该段代码的工作包括:</p><ul><li>保存<strong>被调用者保存寄存器</strong>，因为这些寄存器在调度线程/新进程中可能会被修改</li><li>切换上下文，即加载<strong>调度线程</strong>的寄存器，关键点在于<code>ra</code>寄存器，这是接下来要返回的地址</li></ul><p>执行完毕之后，原线程切换为<strong>调度线程</strong>， <code>ra</code>的值通常是<code>scheduler</code>中的<code>swtch</code>调用的下一条地址</p></li><li><p>kernel/proc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 每个CPU都有的进程调度器</span><br><span class="hljs-comment">// scheduler永远不会返回, 它的操作包括:</span><br><span class="hljs-comment">// 1. 选择一个进程</span><br><span class="hljs-comment">// 2. 切换到该进程</span><br><span class="hljs-comment">// 3. 新进程运行完毕之后最终通过swtch归还控制权</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">scheduler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>  <br>  <span class="hljs-comment">// c-&gt;proc为正在该cpu上运行的进程</span><br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    <span class="hljs-comment">// 开中断以避免死锁</span><br>    intr_on();<br>    <br>    <span class="hljs-keyword">int</span> nproc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      <span class="hljs-comment">// 新进程的锁</span><br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-comment">// ??</span><br>      <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED) &#123;<br>        nproc++;<br>      &#125;<br>      <span class="hljs-comment">// RUNNABLE表示进程可以被调度</span><br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        <span class="hljs-comment">// 从CPU的调度线程切换到挑选出的新进程的内核线程</span><br>        <span class="hljs-comment">// 由于ra返回地址寄存器改变了，因此接下来应该会跳转到sched()函数的swtch行</span><br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nproc &lt;= <span class="hljs-number">2</span>) &#123;   <span class="hljs-comment">// only init and sh exist</span><br>      intr_on();<br>      <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span></span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>紧接着上面，程序应该会跳转到40行，然后在经过一个循环之后</p><ul><li><p>从全局进程表中找出可以被调度的进程作为新进程</p></li><li><p>设置新进程的状态为<code>RUNNING</code>，<code>cpu-&gt;proc</code></p></li><li><p>调用<code>swtch</code>, 由<strong>调度线程</strong>切换为<strong>新线程</strong>，接下来会从上一次的<code>swtch</code>调用点返回, 即<code>sched()</code></p><p>在<code>sched()</code>中释放完旧线程的锁之后，整个调度过程结束</p></li></ul></li></ul><blockquote><p>例外:</p><p>ra并不总是指向<code>scheduler</code>，当一个进程刚被创建时，它的ra在<strong>allocproc</strong>中被设置为forkret，因此scheduler在调度执行一个新创建的进程时，会返回到forkret中，然后就从usertrapret直接返回到用户空间中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc*</span><br><span class="hljs-function"><span class="hljs-title">allocproc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// Set up new context to start executing at forkret,</span><br><span class="hljs-comment">// which returns to user space.</span><br><span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>p-&gt;context.ra = (uint64)forkret;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// A fork child&#x27;s very first scheduling by scheduler()</span><br><span class="hljs-comment">// will swtch to forkret.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">forkret</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// Still holding p-&gt;lock from scheduler.</span><br>release(&amp;myproc()-&gt;lock);<br><br><span class="hljs-comment">// ...</span><br>usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>调度过程中的lock</strong></p><blockquote><p>一是为什么从调用yield开始，持有p-&gt;lock直到在scheduler中释放；或者是从scheduler开始，持有p-&gt;lock直到在yield的出口处释放。</p></blockquote><p>以从<code>yield</code>到<code>scheduler</code>为例，<code>p-&gt;lock</code>保护三件事情：</p><ul><li>改变进程状态为RUNNABLE，防止进程状态的不一致。</li><li>swtch发生的上下文切换，防止保存和恢复寄存器不完整。</li><li>停止使用当前内核线程的内核栈，因此防止两个CPU使用同一个内核栈</li></ul><p>因此，p-&gt;lock的一个作用就是，在整个调度过程完成之前，不能让其它的调度器调度执行旧的进程，因为它处于一种<strong>不稳定的中间态</strong>：我们在yield中标记了该进程为<code>RUNNABLE</code>，但是实际上我们还在执行该进程的内核线程，若此时其它CPU发现了它，并且调度执行它，那么就会有两个CPU在执行该进程，这是一个严重的错误</p><p>因此，通过一直持有<code>p-&gt;lock</code>直到返回<code>scheduler</code>中，我们可以避免以上情况发生，因为就算其它CPU上的调度器发现该进程，即将调度执行它时，也会阻塞在<code>acquire(p-&gt;lock)</code>上。从<code>scheduler</code>回到<code>sched</code>或者用户空间中也是类似的，要持有<code>p-&gt;lock</code>直到新的内核线程已经在运行，则可以在<code>yield</code>中释放该锁。</p><ul><li><strong>中断相关</strong></li></ul><p>此外，通过<code>acquire(p-&gt;lock)</code>，中断也被关闭，因此保证了调度过程的<strong>原子性</strong>。对于在<code>swtch</code>中发生的上下文切换，在中断关闭的情况下可以放心地完成整个<code>wtch</code>的过程。否则，中断发生时进程会呈现出一种奇怪的运行状态，例如状态虽然为<code>RUNNING</code>，但是相关的寄存器还没有加载完全，然后时钟中断导致<code>swtch</code>时，将没有完成初始化的寄存器存进了<code>context</code>中，从而覆盖了该进程真正的寄存器值，这也是一个严重的错误。</p><p>总的来说，<code>p-&gt;lock</code>保证了取消调度和调度这两个过程的原子执行：</p><ul><li>如果进程状态是<code>RUNNING</code>，那么时钟中断导致的<code>yield</code>可以安全地，从这个进程的内核线程，切换到调度线程的调度器中。在这个过程中，CPU寄存器要保持着该进程的寄存器值，<code>c-&gt;proc</code>要保持指向该进程。</li><li>如果进程状态是<code>RUNNABLE</code>，那么调度器可以安全地，调度执行这个进程。在这个过程中，<code>p-&gt;context</code>要保持着该进程的寄存器值，没有CPU使用该进程的内核栈，而且没有CPU的<code>c-&gt;proc</code>指向该进程。</li></ul><blockquote><p>二是为什么在sched中检查，在调用swtch前，除了持有p-&gt;lock以外，不能持有其它锁</p></blockquote><p>这个问题的原因是可能会导致死锁</p><p>如果在单CPU上，一个内核线程持有了除<code>p-&gt;lock</code>以外的其它锁<code>m</code>，然后<code>swtch</code>到调度器，调度器再<code>swtch</code>执行一个新的内核线程，假如新的内核线程也要获取锁<code>m</code>的话，那么死锁就发生了</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:控制台中断</title>
    <link href="/2022/03/29/xv6-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%AD/"/>
    <url>/2022/03/29/xv6-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>控制台Console</strong>是与用户进行交互的硬件设备，它接受用户的输入（如键盘输入），将其传递给内核和用户程序，进行相应的处理，然后再输出结果给用户（如输出到屏幕上）</p><p>首先，简单地看总体流程：</p><ul><li><p>用户将会通过<strong>键盘</strong>键入一连串字符，通过连接到RISC-V上的<strong>UART串行端口</strong>（<strong>UART Serial-port</strong>）传输，<strong>控制台</strong>驱动程序将会顺利地接收这些输入</p></li><li><p>接控制台驱动程序处理其中的一些特殊字符（如BackSpace和Ctrl等），并不断累积这些输入字符，直到达到完整的一行（一般用户键入Enter表示一行的结束)</p></li><li><p><strong>用户进程</strong>，例如<strong>shell</strong>，就会使用read从控制台中读取这些一行行的输入，然后由shell来具体处理它们</p></li></ul><p>内核可以访问经<strong>内存映射</strong>的<strong>UART控制寄存器</strong>。RISC-V硬件将UART设备连接到事先约定好的物理地址上，对这些固定物理地址的读或写指令，相当于直接于硬件设备进行交互，而不是与RAM交互</p><p>UART经内存映射到从物理地址0x10000000开始的部分上，它有一小部分控制寄存器，每个<strong>1B</strong>大小， 当处理设备中断时需要使用到这些寄存器</p><ul><li><p>kernel/uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the UART control registers are memory-mapped</span><br><span class="hljs-comment">// at address UART0. this macro returns the</span><br><span class="hljs-comment">// address of one of the registers.</span><br><span class="hljs-comment">// 用于寻址, 采用的基址 + 偏移量的方式</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg))</span><br><br><span class="hljs-comment">// the UART control registers.</span><br><span class="hljs-comment">// some have different meanings for</span><br><span class="hljs-comment">// read vs write.</span><br><span class="hljs-comment">// see http://byterunner.com/16550.html</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RHR 0                 <span class="hljs-comment">// receive holding register (for input bytes)</span></span><br>                              <span class="hljs-comment">// 保持着UART接受的输入，等待着内核将其内容取走, 与read()相关</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THR 0                 <span class="hljs-comment">// transmit holding register (for output bytes)</span></span><br>                              <span class="hljs-comment">// 保持着内核的输入，等待着UART将其发送, 与write()相关</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER 1                 <span class="hljs-comment">// interrupt enable register</span></span><br>                              <span class="hljs-comment">// 中断控制寄存器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER_TX_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER_RX_ENABLE (1&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR 2                 <span class="hljs-comment">// FIFO control register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="hljs-comment">// clear the content of the two FIFOs</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISR 2                 <span class="hljs-comment">// interrupt status register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR 3                 <span class="hljs-comment">// line control register</span></span><br>                              <span class="hljs-comment">// 指定异步数据的传输格式: 字节长度, 停止字节</span><br>                              <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="hljs-comment">// special mode to set baud rate</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR 5                 <span class="hljs-comment">// line status register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="hljs-comment">// input is waiting to be read from RHR</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="hljs-comment">// THR can accept another character to send</span></span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-控制台读取用户输入流程"><a href="#1-控制台读取用户输入流程" class="headerlink" title="1. 控制台读取用户输入流程"></a>1. 控制台读取用户输入流程</h3><p>先给出整个流程，然后给出具体细节描述:</p><ul><li><p>用户使用<code>read()</code>系统调用从控制台读取输入，控制台等待用户输入, 此时会产生<code>consoleread()</code>进程</p></li><li><p>用户键盘输入一个字符</p></li><li><p><code>xv6</code>接收到中断，陷入<code>trap</code></p></li><li><p><code>trap handler</code>发现是外部设备中断，设备是<code>UART</code>，调用<code>uartintr()</code></p></li><li><p>发现<code>RHR</code>中有字符可读，调用<code>consoleintr()</code></p></li><li><p>将输入字符缓冲到<code>cons.buf</code>中，如果读到’\n’或’ctrl+D’，说明用户输入满足一行，就唤醒<code>consoleread()</code></p></li><li><p>读出一整行的用户输入，拷贝到用户空间中</p></li></ul><p><strong>键入字符后陷入trap</strong></p><p>用户键入字符后，<code>UART</code>硬件向RISCV抛出一个终端, 激活<code>usertrap()</code>, <code>usertrap()</code>对中断类型进行检查，调用<code>devintr()</code>判断是否为硬件中断</p><ul><li><p>kernel/trap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">devintr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 scause = r_scause();<br><br>  <span class="hljs-keyword">if</span>((scause &amp; <span class="hljs-number">0x8000000000000000</span>L) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>)&#123;<br>    <span class="hljs-comment">// this is a supervisor external interrupt, via PLIC.</span><br><br>    <span class="hljs-comment">// irq indicates which device interrupted.</span><br>    <span class="hljs-comment">// 从PLC硬件单元中询问哪个硬件设备中断了</span><br>    <span class="hljs-keyword">int</span> irq = plic_claim();<br><br>    <span class="hljs-keyword">if</span>(irq == UART0_IRQ)<br>      <span class="hljs-comment">// uart设备中断</span><br>      uartintr();<br><span class="hljs-comment">// 后面的可以忽略...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>发现为uart中断，调用uartintr()</strong></p><ul><li><p>kernel/uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uartintr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// read and process incoming characters.</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">// 从RHR控制寄存器中读取一个字符</span><br>    <span class="hljs-keyword">int</span> c = uartgetc();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    consoleintr(c);<br>  &#125;<br><br>  <span class="hljs-comment">// send buffered characters.</span><br>  acquire(&amp;uart_tx_lock);<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uartintr()</code>内部会使用<code>uartgetc()</code>来从<code>RHR</code>控制寄存器中获取用户键入的字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">uartgetc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(ReadReg(LSR) &amp; <span class="hljs-number">0x01</span>)&#123;<br>    <span class="hljs-comment">// input data is ready.</span><br>    <span class="hljs-keyword">return</span> ReadReg(RHR);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，已经确定了中断类型，会调用<code>consoleintr()</code>进行控制台相关处理</p></li></ul><p><strong>调用consoleintr()</strong></p><p>关于console, xv6使用了一个<code>cons</code>对象来对其进行维护</p><ul><li><p>kernel/console.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <br>  <span class="hljs-comment">// input</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INPUT_BUF 128</span><br>  <span class="hljs-keyword">char</span> buf[INPUT_BUF];     <span class="hljs-comment">// console缓冲区</span><br>  uint r;  <span class="hljs-comment">// Read index   </span><br>  uint w;  <span class="hljs-comment">// Write index</span><br>  uint e;  <span class="hljs-comment">// Edit index   // 这里的索引可能会超过缓冲区大小，后面使用了取余操作</span><br>&#125; cons;<br></code></pre></td></tr></table></figure></li><li><p>kernel/console.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//! @param c 用户键入的字符</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">consoleintr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-comment">// ctrl + P, ctrl + U, ctrl + H</span><br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span></span><br><span class="hljs-function">    <span class="hljs-title">procdump</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span></span><br><span class="hljs-function">    <span class="hljs-title">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="hljs-params"><span class="hljs-function">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span></span><br><span class="hljs-function">  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;:</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(cons.e != cons.w)</span></span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认情况下会回显字符</span><br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;<br>      <br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br><br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        <span class="hljs-comment">// 用户不断键入字符，直到用户输入换行符或者ctrl + d时</span><br>        <span class="hljs-comment">// 才会唤醒之前睡在cons.r的consoleread()进程</span><br>        cons.w = cons.e;<br>        <span class="hljs-comment">// </span><br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  release(&amp;cons.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，默认情况下会对用户键入的字符进行回显，同时将其保存到<code>cons</code>对象的缓冲区中</p><p>如果用户输入了一些特殊字符(如ctrl + p等)，那么就做特殊处理</p><p>当用户键入<code>\n</code>回车符或者<code>ctrl + d</code>文件结束符时，就立即<strong>唤醒之前处于sleep</strong>状态并且睡在<code>cons.r</code>的<code>consoleread()</code>进程</p><blockquote><p>consoleread()进程在用户发起read()操作时就会产生， 这些进程并没有阻塞，而是使用了<code>schedule()</code>让出了CPU</p></blockquote></li></ul><p><strong>consoleread()进程读取控制台缓冲区内容到用户空间</strong></p><ul><li><p>kernel/console.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*! @brief 将console缓冲区的内容拷贝到sdt </span><br><span class="hljs-comment"> *! @param user_dst 用于判断dst是用户地址还是内核地址</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">consoleread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> user_dst, uint64 dst, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint target;<br>  <span class="hljs-keyword">int</span> c;<br>  <span class="hljs-keyword">char</span> cbuf;<br><br>  target = n;<br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// wait until interrupt handler has put some</span><br>    <span class="hljs-comment">// input into cons.buffer.</span><br>    <span class="hljs-comment">// 当console的read index与console 的write index相等</span><br>    <span class="hljs-comment">// 有两种情况: </span><br>    <span class="hljs-comment">// 1. 缓冲区没有字符可读</span><br>    <span class="hljs-comment">// 2. 缓冲区已经读完，但是该行仍未结束</span><br>    <span class="hljs-keyword">while</span>(cons.r == cons.w)&#123;<br>      <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>        release(&amp;cons.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      <span class="hljs-comment">// 睡眠</span><br>      <span class="hljs-comment">// 这里并不会发生阻塞，而是进程的重新调度</span><br>      sleep(&amp;cons.r, &amp;cons.lock);<br>    &#125;<br><br>    <span class="hljs-comment">// 一次性读取一个字符 </span><br>    c = cons.buf[cons.r++ % INPUT_BUF];<br><br>    <span class="hljs-keyword">if</span>(c == C(<span class="hljs-string">&#x27;D&#x27;</span>))&#123;  <span class="hljs-comment">// end-of-file(十进制为4), 当键入ctrl + D时就会触发</span><br>      <span class="hljs-keyword">if</span>(n &lt; target)&#123;<br>        <span class="hljs-comment">// Save ^D for next time, to make sure</span><br>        <span class="hljs-comment">// caller gets a 0-byte result.</span><br>        <span class="hljs-comment">// 读取到了文件结束符, 但是没有达到target</span><br>        cons.r--;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the input byte to the user-space buffer.</span><br>    cbuf = c;<br>    <span class="hljs-comment">// 注意此时进程处于内核态</span><br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br><br>    dst++;<br>    --n;<br><br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>      <span class="hljs-comment">// a whole line has arrived, return to</span><br>      <span class="hljs-comment">// the user-level read().</span><br>      <span class="hljs-comment">// 行尾符, 此时整个read()操作结束</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> target - n;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-将用户数据发送到控制台流程"><a href="#2-将用户数据发送到控制台流程" class="headerlink" title="2. 将用户数据发送到控制台流程"></a>2. 将用户数据发送到控制台流程</h3><p>在发送过程中需要使用到的两个比较重要的寄存器:</p><ul><li><p><code>THR</code>: 如果用户想要将字符发送到控制台，就必须将字符写入到该寄存器当中，随后，会由硬件自动读取该寄存器中的值</p><p>​          如果THR寄存器中的值被硬件读出，就代表该字符真正的被控制台读取了，同时将会自动触发<strong>transmit complete 中断</strong>, 陷入         </p><p>​          trap</p></li><li><p><code>LSR</code>: 利用其中的第6个bit可以用来判断<code>THR</code>寄存器内部是否为空</p></li></ul><p>xv6同样也为发送过程维护了一个缓冲区：</p><ul><li><p>kernel/uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the transmit output buffer.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">uart_tx_lock</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UART_TX_BUF_SIZE 32</span><br><span class="hljs-keyword">char</span> uart_tx_buf[UART_TX_BUF_SIZE];<br><span class="hljs-keyword">int</span> uart_tx_w; <span class="hljs-comment">// write next to uart_tx_buf[uart_tx_w++]</span><br><span class="hljs-keyword">int</span> uart_tx_r; <span class="hljs-comment">// read next from uart_tx_buf[uar_tx_r++]</span><br></code></pre></td></tr></table></figure></li></ul><p>简要流程:</p><ul><li><p>用户使用<code>write()</code>系统调用, 最终将导向到UART驱动程序的<code>top half</code>, 结果为调用<code>uarputc()</code></p></li><li><p><code>uartputc()</code>尝试将用户提供的字符写入到<code>uart_tx_buf</code>缓冲区</p><p>如果缓冲区满的话，将会<code>sleep</code></p><p>否则，调用<code>uartstart()</code></p></li><li><p><code>uartstart()</code>会尝试将缓冲区的字符写入到<code>THR</code>寄存器中</p><p>如果<code>THR</code>寄存器此时为空，则表明可以写入</p><p>否则直接返回</p></li><li><p>位于<code>THR</code>寄存器中的值被控制台读出，触发<code>transmit complete</code>中断，陷入<code>trap</code></p></li><li><p>在<code>devintr()</code>中发现中断为<code>uart</code>设备中断，调用<code>uartintr()</code></p></li><li><p><code>uartintr()</code>中经过判断发现是<code>transmit complete</code>中断，调用<code>uartstart()</code>， 陷入循环</p></li></ul><blockquote><p>可以看出uartputc()会尝试将用户提供的字符一次性全部写入缓冲区，然后再由<code>uartstart()</code>一次中断写入一个字符到控制台</p></blockquote><p>在这里就不给出代码分析了，但重要的一点是, 上面的整个过程都是<strong>异步</strong>的， <code>uartstart()</code>在发现<code>THR</code>寄存器非空会直接返回,</p><p><code>uartputc()</code>发现缓冲区满会进行<code>sleep</code>, 让出CPU</p><p>在xv6中还提供了一个<code>uartputc_sync()</code>, 是<code>uartputc()</code>的同步版本，采用了轮询方式(poiling), 用于用户希望快速发出内容的情况</p><ul><li><p>kernel/uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uartputc_sync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  push_off();<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br><br>  <span class="hljs-comment">// wait for Transmit Holding Empty to be set in LSR.</span><br>  <span class="hljs-comment">// 一直阻塞直到THR中的内容发出</span><br>  <span class="hljs-comment">// 然后马上将待发送字符写入THR中</span><br>  <br>  <span class="hljs-keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)<br>    ;<br>  WriteReg(THR, c);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有使用到发送缓冲区，而是直接尝试将内容写入到THR中, 如果<code>THR</code>非空的话就会陷入阻塞</p></li></ul><blockquote><p>uart,  键盘,  显示器 ?</p><p>uart连接了两个键盘以及显示器(Console)两个设备，当通过键盘键入字符时，会将字符发送到uart的相关控制寄存器，然后寄存器的值会被显示器读取显示在屏幕上</p></blockquote><h3 id="3-uart相关并发"><a href="#3-uart相关并发" class="headerlink" title="3. uart相关并发"></a>3. uart相关并发</h3><p>在xv6中，<strong>设备与CPU(进程)是并发运行的</strong>, 一个简单的理解就是<code>UART</code>在向<code>Console</code>发送字符时, <code>Shell</code>可能正同时向Console的缓冲区写入字符, 这被称为<strong>producer-consumer并行</strong></p><p>通过代码可以看出，<code>UART</code>的输入以及输出缓冲区都是<strong>全局</strong>的，所有的CPU都会访问相同的输入输出缓冲区，因此在代码中使用了锁来保护共享的数据结构</p><p>**Top 与 Bottom **</p><p>通常情况下，大多数的设备驱动程序，都可以看成一个分上下部分的结构：顶部<strong>top half</strong>运行在内核空间中，通常由某一个进程的内核线程来运行，而底部<strong>bottom half</strong>则在中断产生时执行，大体上就是<code>Interrupt handler</code></p><p>当内核希望与设备进行一些交互时，请求read、write等系统调用，驱动程序的<code>top half</code>就会被调用，<code>top half</code>会根据相应请求，让设备开始执行一些具体的操作（例如从磁盘上读一块）；在相关操作完成后，设备就会产生中断，因此驱动程序的<code>bottom half</code>开始执行，它会查看设备完成的是什么工作，在适当的时候唤醒等待该工作的进程，同时让设备开始做新的工作</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:内存管理</title>
    <link href="/2022/03/29/xv6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/03/29/xv6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-Page-Table"><a href="#3-1-Page-Table" class="headerlink" title="3.1 Page Table"></a>3.1 Page Table</h2><p>下图展示了RISC-V页表真正的细节，它采用的是<strong>多级页表</strong>的方案，一共有三级，整体上是一个<strong>树形</strong>的结构。这种树形结构的多级页表节省了大量内存空间</p><p>为了跟踪装载页表的页是否有效，引入<strong>页目录PD</strong>(Page Directory，即高两级的页表，xv6并没有严格区分页目录和页表)</p><p>页目录指出装载页表或下一级页目录的物理页帧的位置；或者告诉我们页表或下一级页目录的整个页不包含有效页，这时页目录的<strong>页目录项PDE</strong>（Page Directory Entry）也不存在/无效。</p><p><img src="1.png" alt="1.png"></p><p>每级页表的大小都被设计为4KB，刚好能装进一页物理帧内, 前面提过，<code>PTE</code>用<code>uint64</code>类型来保存，因此一个<code>PTE</code>占用8B的空间，所以一个页表可以包含512个PTE</p><p>在每一级页表中，都取27位索引的其中9位来找到对应的PTE。通过查找前两级页表的PTE，可以访问新的物理页帧，在该物理页帧内保存着下一级的页表。当查找最后一级页表的PTE时，才将<code>PPN</code>和<code>Offset</code>结合，得到虚拟地址所映射的真正物理地址，然后再访问用户或内核需要的内容。</p><p>整个查找页表的过程一共要遍历三层，如果这三次查找有任意一次没有命中，即对应PTE不存在，这种异常的情况称为<strong>缺页错误Page-Fault</strong></p><p>现在我们来看一些PTE的标志位Flags，这些标志位告诉页表硬件，关于用户进程提供的虚拟地址的一些权限信息，这将指示页表硬件怎么对待这次地址转换。</p><ul><li><strong>PTE_V</strong>指示PTE是否存在/有效。如果不存在，尝试引用该页时就会引发一个缺页错误异常。</li><li><strong>PTE_R</strong>指示这一页物理帧是否能被读。</li><li><strong>PTE_W</strong>指示这一页物理帧是否能被写。</li><li><strong>PTE_X</strong>指示这一页物理帧是否能被CPU看待并转换成指令来执行。</li><li><strong>PTE_U</strong>指示这一页物理帧在用户模式下是否能访问。如果没有置位，则该一页物理帧只能在监管者模式下被访问。</li></ul><p>在xv6内核的启动阶段时，页表是被禁用的,  为了告诉RISC-V的分页硬件，现在可以使用页表了，内核必须将<strong>根页表</strong>的物理地址写入到<strong>satp</strong>寄存器中</p><p><strong>每个CPU都有自己的<code>satp</code>寄存器</strong>,  CPU在执行指令时，将使用自己的<code>satp</code>寄存器里指向的根页表，完成指令中虚拟地址的转换, 正因为每个CPU有自己的<code>satp</code>寄存器，因此不同CPU可以使用不同的页表</p><p>最后我们再弄清楚一些概念，<strong>物理内存</strong>通常指的是<strong>DRAM</strong>中的存储单元，物理内存中的每一字节都对应一个物理地址。而<strong>指令由始至终只使用虚拟地址</strong>，位于<code>MMU</code>的分页硬件负责，将CPU传来的虚拟地址转换为物理地址，然后将物理地址发送到DRAM以读取或写入数据</p><h2 id="3-2-Kernel-Address-Space"><a href="#3-2-Kernel-Address-Space" class="headerlink" title="3.2 Kernel Address Space"></a><strong>3.2 Kernel Address Space</strong></h2><p>除了为每个用户进程都维护一个页表，xv6为内核也单独维护了一个页表。下图展示了<strong>内核的虚拟地址空间</strong>如何映射到实际的物理地址空间中。</p><p><img src="2.png" alt="2.png"></p><p>QEMU仿真的RAM，将从物理地址0x80000000（<strong>KERNBASE</strong>）开始，至少到0x86400000为止（<strong>PHYSTOP</strong>，在kernel/memlayout.h中定义其值为0x88000000，所以xv6的RAM实际大小为128M）</p><p>QEMU同样也仿真了一些I/O设备，这些设备接口通过<strong>内存映射</strong>的方式，将设备的<strong>控制寄存器</strong>映射到物理内存中，位于KERNBASE下</p><p>内核只要读出或写入这些特殊的物理地址，就能直接读写设备的控制寄存器，从而直接地与设备进行通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the kernel expects there to be RAM</span><br><span class="hljs-comment">// for use by the kernel and user pages</span><br><span class="hljs-comment">// from physical address 0x80000000 to PHYSTOP.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNBASE 0x80000000L</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span><br><span class="hljs-comment">// 这里 PHYSTOP = 0x88000000L</span><br></code></pre></td></tr></table></figure><p>值得提醒的是，在上图右半部分的物理内存视图中，只有从KERNBASE到PHYSTOP才对应真正的<strong>DRAM芯片</strong></p><p>位于PHYSTOP上方，未使用的空间是没有DRAM芯片与之对应的，通过放置新的DRAM芯片，这部分空间可以被扩展并使用。而位于KERNBASE下方，访问相应的物理地址，实际上是直接访问相关I/O设备的控制寄存器，而不是访问DRAM芯片。</p><ul><li><p>直接映射</p><p>在内核未启用页表的时候，访问RAM以及经过内存映射的设备控制寄存器时，内核的虚拟地址将采用<strong>直接映射</strong>的方式进行转换，即虚拟地址与实际物理地址相同。这种直接映射，也会在初始化内核页表的过程中（kernel/vm.c的kvminit），记录到内核页表中，即使内核开始使用页表，这种直接映射的布局也被保留了下来</p></li></ul><p>内核的虚拟地址空间中，也有一些部分<strong>不仅仅使用直接映射</strong>。上图的左半部分展示了，除了直接映射之外，还有一些额外的布局与设置，它们位于内核虚拟地址空间的顶部，在初始化了内核页表，并且启用页表之后，就可以正式使用这些布局设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// map the trampoline page to the highest address,</span><br><span class="hljs-comment">// in both user and kernel space.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span><br><br><span class="hljs-comment">// map kernel stacks beneath the trampoline,</span><br><span class="hljs-comment">// each surrounded by invalid guard pages.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>trampoline</strong></p><p>它被映射到虚拟地址空间的顶端，用户和内核的页表里都有这一项映射，摆放的位置相同，trampoline页被映射了两次，一次映射到虚拟地址空间的顶端，一次是直接映射（trampoline页位于RAM中）。</p></li><li><p><strong>内核栈</strong></p><p>每个进程都对应一个内核栈,  更准确地说，每个进程在用户空间执行指令时使用的是用户栈，而在内核空间下执行时（一般称为这个用户进程的内核线程）使用的是内核栈，xv6内核是C代码，自然需要内核栈来保存关于函数调用等信息</p><p>内核栈是一页页地被分配的，从靠近PHYSTOP的位置开始往下分配。因此这些内核栈也在RAM当中，自然会被直接映射到内核的虚拟地址空间里。现在我们再一次将这些内核栈映射到内核虚拟地址空间的高地址部分，这样就可以自然地在它们之间插入一些<strong>保护页guard page</strong>。保护页的PTE_V是无效的，访问它会引发缺页错误的异常，从而陷入内核，这样的设计可以防止内核栈溢出</p></li></ul><p>对于内核代码和trampoline页，标志位PTE_R和PTE_X被设置，因此内核可以从这些页中读取内容并且直接当作指令运行。其它的页则设置标志位PTE_R和PTE_W，作为常规页进行读写。</p><h2 id="3-3-Code-Creating-an-Address-Space"><a href="#3-3-Code-Creating-an-Address-Space" class="headerlink" title="3.3 Code: Creating an Address Space"></a><strong>3.3 Code: Creating an Address Space</strong></h2><p>与xv6虚拟内存系统密切相关的代码位于<code>kernel/vm.c</code>中，下面我们来分析其中一部分代码。</p><p>核心的函数是<code>walk()</code>和<code>mappages()</code>,  <code>walk</code>为给定的虚拟地址，找到其相应的PTE，如果PTE不存在则新分配一页使之有效，它<strong>模仿</strong>的是真实分页硬件查找页表的过程，可以看成是查找页表的<strong>软件实现</strong>，<strong>在内核或进程的页表未初始化时，内核就用它来转换相关虚拟地址</strong><code>mappages()</code>为给定输入的映射建立<code>PTE</code>，更新页表</p><p>以kvm开头的函数对内核页表进行操作，以uvm开头的函数对用户页表进行操作，函数copyout和copyin完成内核空间和用户空间之间的数据复制…</p><p>在内核启动阶段，<strong>main()</strong>(kernel/main.c)将调用<strong>kvminit()</strong>, 创建内核页表,  整个工作流程如下:</p><ol><li>分配新的一页物理帧用于装载内核的根页表</li><li>调用<code>kvmmap()</code>，在即将装载的内核页表上建立一系列的直接映射，包括I/O设备、内核代码和数据、内核空闲内存段等</li><li>再把<code>trampoline</code>映射到内核虚拟地址的最顶端，完成了内核页表的初始化</li></ol><p>内核利用以下函数初始化内核页表时，能够正常工作，是建立在内核虚拟地址空间被<strong>直接映射</strong>到物理内存的<strong>前提</strong>下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> etext[];  <span class="hljs-comment">// kernel.ld sets this to end of kernel code.</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> trampoline[]; <span class="hljs-comment">// trampoline.S</span><br><br><span class="hljs-comment">// create a direct-map page table for the kernel.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvminit</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// allocates a page of physical memory to hold the root page-table page. </span></span></span><br><span class="hljs-params"><span class="hljs-function">  kernel_pagetable = (<span class="hljs-keyword">pagetable_t</span>) kalloc();</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-built_in">memset</span>(kernel_pagetable, <span class="hljs-number">0</span>, PGSIZE);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// include the kernel’s instructions and data, physical memory up to PHYSTOP, </span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// and memory ranges which are actually devices.</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// install mappings into a page table for a range of virtual addresses</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// to a corresponding range of physical addresses</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// uart registers</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// virtio mmio disk interface</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// CLINT</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// PLIC</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// 大小为kernel text(code)的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// map kernel text executable and read-only.</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// 从kernel text之后到PHYSTOP之前的区域都是kernel data和free memory</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time allocation. </span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// the highest virtual address in the kernel.</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// TRAMPOLINE = MAXVA - PGSIZE</span></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// 从最大虚拟地址向下分配一页给trampoline</span></span></span><br><span class="hljs-params"><span class="hljs-function">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><ul><li>kvmmap(): 建立虚拟地址与物理地址的映射</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// add a mapping to the kernel page table.</span><br><span class="hljs-comment">// only used when booting.</span><br><span class="hljs-comment">// does not flush TLB or enable paging.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvmmap</span><span class="hljs-params">(uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>mappages(): 建立映射关系的va和pa、映射的范围大小、以及PTE的权限</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to</span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not</span><br><span class="hljs-comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span><br><span class="hljs-comment">// allocate a needed page-table page.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">mappages</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// installs PTEs for new mappings </span><br>  <span class="hljs-comment">// this mapping is separately for each virtual address in the range, at page intervals</span><br>  uint64 a, last;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br><br>  a = PGROUNDDOWN(va);<br>  last = PGROUNDDOWN(va + size - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 为va的起始和终止地址分别向下向上取页大小4096的整</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// calls walk to find the address of the PTE for that address</span><br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// walk为虚拟地址a分配PTE失败</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      <span class="hljs-comment">// 该PTE已经被别的va映射，有效位有效</span><br>      panic(<span class="hljs-string">&quot;remap&quot;</span>);<br>    <span class="hljs-comment">// 将物理地址pa的PPN提取出来，加上标志位信息perm和有效位</span><br>    <span class="hljs-comment">// 然后将该条目放到PTE中</span><br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-comment">// 分到了足够页数就返回</span><br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>    <span class="hljs-comment">// 已经分配了一页，虚拟地址的起始位置和物理地址起始位置都加一页</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>walk(): 为输入的va找到其对应的<strong>最后一级页表的PTE</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pagetable</span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,</span><br><span class="hljs-comment">// create any required page-table pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table</span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.</span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:</span><br><span class="hljs-comment">//   39..63 -- must be zero.</span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.</span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.</span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.</span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.</span><br><span class="hljs-function"><span class="hljs-keyword">pte_t</span> *</span><br><span class="hljs-function"><span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">int</span> alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// walk函数为给定va找到其对应的PTE</span><br>  <span class="hljs-comment">// returns the address of the PTE in the lowest layer in the tree</span><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>    <span class="hljs-comment">// 根据当前level，对va进行移位和掩码操作，得到当前level页表中的对应PTE条目</span><br>    <span class="hljs-comment">// level=2时，向右移出12+2*9=30位，经掩码后得到9位level=2页表的PTE编号</span><br>    <span class="hljs-comment">// level=1时，向右移出12+9=21位，经掩码后得到9位level=1页表的PTE编号</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>      <span class="hljs-comment">// 判断有效位</span><br>      pagetable = (<span class="hljs-keyword">pagetable_t</span>)PTE2PA(*pte);<br>      <span class="hljs-comment">// 提取物理地址，对应一个页的首地址</span><br>      <span class="hljs-comment">// 将最右10位标志位移出，补充12位全0的偏移位，原44位PPN保留，得到指向下一层页表的物理地址</span><br>      <span class="hljs-comment">// level=2时，pagetable指向level=1的页表</span><br>      <span class="hljs-comment">// level=1时，pagetable指向level=0的页表</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 对应PTE不存在，且alloc被置位，则为该PTE指向的下一层页表分配一页</span><br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-keyword">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 一切清0，新分配的下一级页表的所有PTE也都是无效的</span><br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      <span class="hljs-comment">// 更新PTE，将56位物理地址右移12位去掉偏移位，移进10位标志位，同时将PTE_V置1</span><br>      *pte = PA2PTE(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 跳出while后，此时pagetable指向level=0的页表</span><br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>  <span class="hljs-comment">// level=0，向右移出12位，经掩码后得到9位level=0页表的PTE编号</span><br>  <span class="hljs-comment">// 返回va对应的level=0页表中的对应PTE</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>kvminit()</code>调用完成后，内核页表被初始化完毕，接着<code>main()</code>就调用<code>kvminithart()</code>装载内核页表</p><ul><li>kvminithart(): 装载内核页表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch h/w page table register to the kernel&#x27;s page table,</span><br><span class="hljs-comment">// and enable paging.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvminithart</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// install the kernel page table</span><br>  <span class="hljs-comment">// writes the physical address of the root page-table page into the register satp</span><br>  <span class="hljs-comment">// After this the CPU will translate addresses using the kernel page table</span><br>  w_satp(MAKE_SATP(kernel_pagetable));<br>  <span class="hljs-comment">// flushes the current CPU’s TLB</span><br>  <span class="hljs-comment">// 此外，在trampoline中，switches to a user page table before returning to user space，也会刷新TLB</span><br>  sfence_vma();<br>&#125;<br></code></pre></td></tr></table></figure><p>还是在内核空间下，<code>main()</code>马上就调用<strong>procinit</strong>，为每个用户进程分配一个内核栈，该内核栈将被映射到内核虚拟地址空间的高地址部分，位于<code>trampoline</code>下方,更新了所有内核栈的PTE之后，最后调用<code>kvminithart()</code>更新一次<code>satp</code>寄存器，分页硬件就能使用新的内核页表</p><ul><li>procinit(): 分配用户内核栈, 更新内核页表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// initialize the proc table at boot time.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">procinit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  initlock(&amp;pid_lock, <span class="hljs-string">&quot;nextpid&quot;</span>);<br><br>  <span class="hljs-comment">// 开始时p=proc，即p的地址是proc数组的最开始位置</span><br>  <span class="hljs-comment">// 每次遍历p就指向下一个进程结构</span><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      initlock(&amp;p-&gt;lock, <span class="hljs-string">&quot;proc&quot;</span>);<br>      <span class="hljs-comment">// Allocate a page for a kernel stack, for each process</span><br>      <span class="hljs-comment">// Map it high in memory at the va generated by KSTACK, followed by an invalid guard page.</span><br>      <span class="hljs-keyword">char</span> *pa = kalloc();<br>      <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>        panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>      <span class="hljs-comment">// 指针相减就是地址相减，获取当前进程p和proc数组最开始位置的偏移量</span><br>      <span class="hljs-comment">// 比如第一次，从p-proc=0开始，KSTACK生成虚拟地址: TRAMPOLINE - 2*PGSIZE</span><br>      <span class="hljs-comment">// 因此TRAMPOLINE的下面第一页是guard page，第二页是kstack，也就是va指向的位置</span><br>      <span class="hljs-comment">// 后面也以此类推，被跳过而未被处理的guard page，PTE_V是无效的</span><br>      uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>      <span class="hljs-comment">// adds the mapping PTEs to the kernel page table</span><br>      <span class="hljs-comment">// 内核栈可读可写，但在用户态不可访问，也不能直接执行</span><br>      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>      p-&gt;kstack = va;<br>  &#125;<br>  <span class="hljs-comment">// 将更新后的内核页表重新写入到satp中</span><br>  kvminithart();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-Physical-Memory-Allocation"><a href="#3-4-Physical-Memory-Allocation" class="headerlink" title="3.4 Physical Memory Allocation"></a><strong>3.4 Physical Memory Allocation</strong></h2><p>内核在运行时会分配和释放很多物理内存，xv6将一部分的物理内存，从<code>kernel data</code>结束开始，到<code>PHYSTOP</code>为止，这一部分称为<code>free memory</code>，用于运行时的内存分配</p><p>每次分配和回收都<strong>以页为单位</strong>，一页大小4KB，通过一个<strong>空闲物理帧链表free-list</strong>，将空闲的物理帧串起来保存</p><p>页表、用户内存、内核栈、管道缓冲区等操作系统组件需要内存时，内核就从<code>free list</code>上摘下一页或者多页分配给它们</p><p>在回收已经分配出去的内存时，这些被回收的物理帧，内核将它们一页页地重新挂到<code>free list</code>上。</p><h2 id="3-5-Code-Physical-Memory-Allocator"><a href="#3-5-Code-Physical-Memory-Allocator" class="headerlink" title="3.5 Code: Physical Memory Allocator"></a><strong>3.5 Code: Physical Memory Allocator</strong></h2><p>现在我们来看看内核的<strong>内存分配器</strong>，该模块位于<code>kernel/kalloc.c</code>中。分配器使用的数据结构很简单，如下所示，就是一个<code>struct kmem</code>，有一把保护<code>free-list</code>的自旋锁，每一页物理帧都通过<code>struct run</code>串在一起，<code>struct run</code>被保存在<strong>每个空闲物理页内部</strong></p><ul><li>链表节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br></code></pre></td></tr></table></figure><p>在<code>main()</code>中调用**kinit()**来完成内存分配器的初始化</p><ul><li>kinit()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> end[]; <span class="hljs-comment">// first address after kernel.</span><br>                   <span class="hljs-comment">// defined by kernel.ld.</span><br><br><span class="hljs-comment">//initialize the allocator</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kinit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// initializes the free list to hold every page between the end of the kernel and PHYSTOP</span><br>  <span class="hljs-comment">// xv6 assumes that the machine has 128MB of RAM</span><br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  <span class="hljs-comment">// kernel data之后到PHYSTOP之前都可以用于分配</span><br>  <span class="hljs-comment">// add memory to the free list via per-page calls to kfree</span><br>  freerange(end, (<span class="hljs-keyword">void</span>*)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>freerange(): 回收物理内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freerange</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *pa_start, <span class="hljs-keyword">void</span> *pa_end)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *p;<br>  p = (<span class="hljs-keyword">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-comment">//kfree是头插法</span><br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-keyword">char</span>*)pa_end; p += PGSIZE)<br>    kfree(p);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kfree(): 回收一页物理帧</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free the page of physical memory pointed at by v,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kfree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *pa)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  <span class="hljs-comment">// casts pa to a pointer to struct run, which records the old start of the free list in r-&gt;next,</span><br>  <span class="hljs-comment">// and sets the free list equal to r</span><br>  r = (struct run*)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kalloc(): 分配一个物理页</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">kalloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// removes and returns the first element in the free list.</span><br>  <span class="hljs-comment">// When a process asks xv6 for more user memory, xv6 first uses kalloc to allocate physical pages.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r)<br>    kmem.freelist = r-&gt;next;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-keyword">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-Process-Address-Space"><a href="#3-6-Process-Address-Space" class="headerlink" title="3.6 Process Address Space"></a><strong>3.6 Process Address Space</strong></h2><p>前面我们已经讨论过内核的虚拟地址空间，现在我们来看<strong>用户进程的虚拟地址空间</strong>，每个用户进程都有自己的页表，因此也有不同的虚拟地址空间。</p><p>用户进程的虚拟地址空间同样从0开始，一直到MAXVA（2^38-1），这其中有多达256GB的空间。一个用户进程如果在运行时需要额外内存，就向内核内存分配器发出请求，让kalloc分配一些物理页，然后内核会更新用户进程的页表，设置新的PTE（此前提到的5个标志位都被设置）。进程中间那些未使用的虚拟地址，只需要在页表中将相关的PTE标记为无效即可</p><ul><li>为什么使用页表</li></ul><ol><li>用户进程现在都有自己的页表，在进程之间提供了<strong>隔离性</strong></li><li>用户的虚拟地址空间是<strong>连续</strong>的，而对应的物理帧分布可以是<strong>不连续</strong>的</li><li>通过页表，内核可以将<code>trampoline</code>页映射到用户虚拟地址空间的顶端，所有进程都可以看到这一页。</li></ol><p>用户进程虚拟地址空间的布局如下图所示</p><p><img src="3.png" alt="3.png"></p><ul><li><p>stack</p><p>为了防止用户栈溢出，在栈的下面也放置了一页保护页。栈溢出时会访问到该保护页，从而出现缺页错误异常，用户进程因此陷入内核并等待处理，内核可能会终止掉该进程。而现在的操作系统在这种情况下，一般都会自动地为用户栈分配更多的空间</p><p>值得注意的地方有两点：</p><ol><li>内核虚拟地址空间中那些内核栈之间的保护页有所不同。这里的保护页是<strong>有实际的物理帧</strong>对应的，即内核确实为用户进程分配这一页（标志位为RWV，没有U）</li><li>在内核空间下，内核栈之间的保护页PTE_V无效，并没有实际分配物理页</li></ol></li><li><p>text， data段</p><p>xv6为了简单起见，将它们放在了同一页内，实际上现在的操作系统都会将它们放在不同的页内，这一点也可以通过在编译时指定-N选项来强制实现</p></li></ul><p><strong>Stack</strong></p><p>Stack的大体结构如上图所示，下面给出其具体结构</p><p><img src="4.png" alt="4.png"></p><p>上图是一个典型的<strong>运行时(Calling)栈</strong>, xv6中，一个<code>stack</code>只有一个page大小, 当进程进行嵌套调用(如函数A调用函数B)时， 每个被调用的函数都会产生一个<strong>栈帧(Stack Frame)</strong>, 每一个栈帧由四个部分组成</p><ul><li>返回地址(fp)</li><li>上一个栈帧的fp寄存器的值(fp - 8)</li><li>保存的寄存器(Caller)</li><li>局部变量</li></ul><p>对于每一个栈帧来说，寄存器<code>fp/s0</code>指向其栈帧的首部, 即栈帧的最大地址，寄存器<code>sp</code>指向栈帧的尾部, 即栈帧的最小地址</p><p>通常情况下，当申请一个新的栈帧时，会将sp - 16(至少-8， 因为可能没有上一个栈帧)</p><h2 id="3-7-Code-Sbrk"><a href="#3-7-Code-Sbrk" class="headerlink" title="3.7 Code: Sbrk"></a><strong>3.7 Code: Sbrk</strong></h2><p><strong>Sbrk</strong>是一个系统调用，用户进程调用它以增加或减少自己拥有的物理内存（proc-&gt;sz）</p><ul><li>sys_sbrk()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> addr;<br>  <span class="hljs-keyword">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-keyword">if</span>(growproc(n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>growproc(): 更改物理内存大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow or shrink user memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-comment">// Sbrk is implemented by the function growproc</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">growproc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br>  <span class="hljs-comment">// 是从sz接着分配内存给增长需要的</span><br>  <span class="hljs-comment">// 也就是紧接着user text、user data、guard page和user stack之后</span><br>  <span class="hljs-comment">// 从那个虚拟地址继续开始分配</span><br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>uvmalloc()</li></ul><p><strong>uvmalloc</strong>通过调用kalloc来分配物理内存，并调用mappages来更新页表，并设置PTE的5个标志位都置位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate PTEs and physical memory to grow process from oldsz to</span><br><span class="hljs-comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">uvmalloc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *mem;<br>  uint64 a;<br><br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;<br>    <span class="hljs-comment">// allocates physical memory with kalloc, and adds PTEs to the user page table with mappages</span><br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="hljs-number">0</span>)&#123;<br>      kfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>uvmdealloc()</li></ul><p><strong>uvmdealloc</strong>调用uvmunmap来回收已分配的物理内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Deallocate user pages to bring the process size from oldsz to</span><br><span class="hljs-comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span><br><span class="hljs-comment">// need to be less than oldsz.  oldsz can be larger than the actual</span><br><span class="hljs-comment">// process size.  Returns the new process size.</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">uvmdealloc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(newsz &gt;= oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  <span class="hljs-keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;<br>    <span class="hljs-keyword">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;<br>    <span class="hljs-comment">// calls uvmunmap, </span><br>    <span class="hljs-comment">// which uses walk to find PTEs and kfree to free the physical memory they refer to.</span><br>    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>uvmunmap()</p><p><strong>uvmunmap</strong>使用<code>walk()</code>找到相应的PTE，并且调用kfree回收相应的物理帧</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Remove npages of mappings starting from va. va must be</span><br><span class="hljs-comment">// page-aligned. The mappings must exist.</span><br><span class="hljs-comment">// Optionally free the physical memory.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uvmunmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="hljs-keyword">int</span> do_free)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 a;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;uvmunmap: not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmunmap: walk&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// examination of the user page table</span><br>      <span class="hljs-comment">// xv6 uses a process’s page table as the only record</span><br>      <span class="hljs-comment">// of which physical memory pages are allocated to that process</span><br>      panic(<span class="hljs-string">&quot;uvmunmap: not mapped&quot;</span>);<br>    <span class="hljs-keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)<br>      panic(<span class="hljs-string">&quot;uvmunmap: not a leaf&quot;</span>);<br>    <span class="hljs-keyword">if</span>(do_free)&#123;<br>      uint64 pa = PTE2PA(*pte);<br>      kfree((<span class="hljs-keyword">void</span>*)pa);<br>    &#125;<br>    *pte = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8-Code-Exec"><a href="#3-8-Code-Exec" class="headerlink" title="3.8 Code: Exec"></a><strong>3.8 Code: Exec</strong></h2><p>现在我们来看最后一段代码，系统调用<strong>exec</strong>的实现（kernel/exec.c）</p><p>系统调用<code>exec</code>将存储在文件系统上的，新的用户程序装载进内存里，然后执行它</p><blockquote><p>int exec(char *path, char **argv)</p></blockquote><ul><li>读取文件的<code>ELF Header</code></li></ul><p><code>exec</code>通过路径名打开文件，然后读取该文件的<strong>ELF Header</strong>（kernel/elf.h）, xv6的所有应用程序以通用的<strong>ELF格式</strong>来描述，一个ELF二进制文件大概这样组成：一个<code>ELF Header</code>，后面紧跟一系列的<code>Program Section Headers</code></p><p>每个<code>Program Section Header</code>都对应一段需要加载到内存中的程序，xv6的应用程序只有一个Program Section Header，而在其它操作系统上可能有好几个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint64 entry;<br>  uint64 phoff;<br>  uint64 shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint32 type;<br>  uint32 flags;<br>  uint64 off;<br>  uint64 vaddr;<br>  uint64 paddr;<br>  uint64 filesz;<br>  uint64 memsz;<br>  uint64 align;<br>&#125;;<br><br><span class="hljs-comment">// Format of an ELF executable file</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br></code></pre></td></tr></table></figure><p><code>exec</code>读取了文件系统上的文件之后，第一件事就是先检查该文件是否包含ELF二进制文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check ELF header</span><br><span class="hljs-comment">// exec的第一步是检查文件是否包ELF二进制文件。</span><br><span class="hljs-comment">// ELF二进制文件是以4个“magic number”开头的，即0x7F，“E”，“L”，“F”，即宏定义ELF_MAGIC。</span><br><span class="hljs-comment">// 如果ELF头中包含正确的magic number，exec就认为该ELF二进制文件的结构是正确的。</span><br><span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))<br>  <span class="hljs-keyword">goto</span> bad;<br><span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)<br>  <span class="hljs-keyword">goto</span> bad;<br></code></pre></td></tr></table></figure><ul><li><p>创建用户页表</p><p><code>exec</code>为用户进程调用<code>proc_pagetable()</code>，通过<code>uvmcreate()</code>创建一个空的用户页表，接着只在该页表上添加了<code>trampoline</code>和<code>trapframe</code>的映射，其它的虚拟地址空间都暂时为空</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//exec通过proc_pagetable分配了一个没有用户部分映射的页表</span><br><span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">goto</span> bad;<br><br><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">proc_pagetable</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.</span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br><span class="hljs-comment">// create an empty user page table.</span><br><span class="hljs-comment">// returns 0 if out of memory.</span><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">uvmcreate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> pagetable;<br>  pagetable = (<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>将程序由文件(磁盘)装载到内存</p><p><code>exec()</code>对于每个程序段，先是调用<code>uvmalloc()</code>分配足够的物理帧，更新了用户页表。然后调用<code>loadseg()</code>加载程序段到这些物理帧(DRAM)中</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Load program into memory</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;<br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)<br>    <span class="hljs-keyword">goto</span> bad;<br>  uint64 sz1;<br>  <span class="hljs-comment">// 再通过uvmalloc为每个ELF段分配内存</span><br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sz = sz1;<br>  <span class="hljs-keyword">if</span>(ph.vaddr % PGSIZE != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-comment">// 然后通过loadseg把段的内容载入物理内存中</span><br>  <span class="hljs-comment">// loadseg通过walkaddr找到写入ELF段的内存的物理地址；通过readi来将段的内容从文件中读出</span><br>  <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br><br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.</span><br><span class="hljs-comment">// va must be page-aligned</span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.</span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">loadseg</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va, struct inode *ip, uint offset, uint sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint i, n;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;loadseg: va must be page aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    pa = walkaddr(pagetable, va + i);<br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)<br>      n = sz - i;<br>    <span class="hljs-keyword">else</span><br>      n = PGSIZE;<br>    <span class="hljs-comment">// 将文件内容写入物理内存DRAM中</span><br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can only be used to look up user pages.</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">walkaddr</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>初始化用户栈</p><p><code>exec()</code>首先分配两页物理帧:</p><ul><li><p> 第一页用作保护页，通过调用<code>uvmclear()</code>将<code>PTE_U</code>设为无效，这样在用户空间下不能访问它</p></li><li><p> 第二页留给用户栈，argc, argv 已经其他需要的寄存器推入用户栈内</p></li></ul><p>最后，<code>exec()</code>就清除进程的旧内存映像，即释放旧页表所占用的物理内存，并使用新的页表, <code>exec()</code>顺利完成并返回，该进程将执行一个新的用户程序</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 到这里，用户空间的text和data都已经加载完毕了</span><br><span class="hljs-comment">// Allocate two pages at the next page boundary.</span><br><span class="hljs-comment">// 紧接着data的位置向上继续分配两个页，第一页用作guard page，第二页用作user stack</span><br><span class="hljs-comment">// ustack中的前三项就是伪造的返回PC值，argc和argv指针</span><br>sz = PGROUNDUP(sz);<br>uint64 sz1;<br><span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="hljs-number">2</span>*PGSIZE)) == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">goto</span> bad;<br>sz = sz1;<br><span class="hljs-comment">// uvmclear将PTE_U设为无效，因此这一页用作保护页</span><br>uvmclear(pagetable, sz<span class="hljs-number">-2</span>*PGSIZE); <br>sp = sz;<br>stackbase = sp - PGSIZE;<br><br><span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.</span><br><span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;<br>  <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;<br>  sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned</span><br>  <span class="hljs-keyword">if</span>(sp &lt; stackbase)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 保护页还让exec能够处理那些过于庞大的参数；当参数过于庞大时，</span><br>    <span class="hljs-comment">// exec 用于将参数拷贝到栈上的函数copyout会发现目标页无法访问，并且返回-1</span><br>    <span class="hljs-keyword">goto</span> bad;<br>  ustack[argc] = sp;<br>&#125;<br>ustack[argc] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// push the array of argv[] pointers.</span><br>sp -= (argc+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(uint64);<br>sp -= sp % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span>(sp &lt; stackbase)<br>  <span class="hljs-keyword">goto</span> bad;<br><span class="hljs-keyword">if</span>(copyout(pagetable, sp, (<span class="hljs-keyword">char</span> *)ustack, (argc+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">// arguments to user main(argc, argv)</span><br><span class="hljs-comment">// argc is returned via the system call return</span><br><span class="hljs-comment">// value, which goes in a0.</span><br><span class="hljs-comment">// 现在的sp指向argv[]数组，argc通过a0寄存器i 返回</span><br>p-&gt;trapframe-&gt;a1 = sp;<br><br><span class="hljs-comment">// Save program name for debugging.</span><br><span class="hljs-keyword">for</span>(last=s=path; *s; s++)<br>  <span class="hljs-keyword">if</span>(*s == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    last = s+<span class="hljs-number">1</span>;<br>safestrcpy(p-&gt;name, last, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br><span class="hljs-comment">// Commit to the user image.</span><br>oldpagetable = p-&gt;pagetable;<br>p-&gt;pagetable = pagetable;<br>p-&gt;sz = sz;<br><span class="hljs-comment">// 注意，在用户进程被创建的时候，这里就将返回到main的pc值放到寄存器epc里面</span><br>p-&gt;trapframe-&gt;epc = elf.entry;  <span class="hljs-comment">// initial program counter = main</span><br>p-&gt;trapframe-&gt;sp = sp; <span class="hljs-comment">// initial stack pointer</span><br>proc_freepagetable(oldpagetable, oldsz);<br><br><span class="hljs-comment">// the C calling convention on RISC-V places return values in a0</span><br><span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br></code></pre></td></tr></table></figure><ul><li>参考: <a href="https://zhuanlan.zhihu.com/p/351646541">https://zhuanlan.zhihu.com/p/351646541</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:trap</title>
    <link href="/2022/03/29/xv6-trap/"/>
    <url>/2022/03/29/xv6-trap/</url>
    
    <content type="html"><![CDATA[<ul><li><p>简介</p><p>xv6中的中断类型分为三种:</p><ul><li><p>系统调用</p><p>系统调用由<code>ecall</code>指令引发, 系统会由用户态陷入内核态(监管者模式, supervisor model)</p></li><li><p>异常</p><p>异常通常是指用户或者内核做了一些不合法的事，如除以0或者使用无效虚拟地址</p></li><li><p>中断</p><p>设备中断：当一个设备发出中断信号时，系统需要做出响应的响应</p><p>时钟中断：当时钟发出中断时，就需要CPU放弃当前进程，重新调度</p></li></ul><p><strong>trap</strong></p><p>在xv6中，统一将上面的三种中断称为<strong>trap</strong>,  以系统调用为例，当执行系统调用时，用户会由用户态进入到内核态，完成一些动作，然后返回， 这个过程对于被中断的进程来说是<strong>透明</strong>的</p><p><strong>四个阶段</strong></p><p>xv6对于trap的处理通常分为四个阶段:</p><ul><li><p>硬件自动处理</p><p>当用户执行指令(如ecall)陷入trap时，硬件会自动的执行一些动作，通常是设置某些寄存器(如pc)的状态</p></li><li><p>进入汇编入口</p><p>如上所说，陷入trap时pc的值可能会被置为某些特定寄存器的值，因此，在陷入中断之前，如果我们能够手动设置这些寄存器，那么当陷入中断时，就可以让程序跳转到指定的位置, 在xv6中，这个位置经常被设置为<code>*.S</code>文件中的某个label</p><p>而在这些汇编入口中，可以执行一些预处理，如寄存器的保存，页表的切换等等</p></li><li><p>执行C处理程序</p><p>通过跳转指令(jr), 可以从汇编入口跳转到对应的C处理程序， 这些程序会对中断的类型进行更加精确的判断</p></li><li><p>执行系统调用或者设备驱动服务</p><p>同样，这里也是更高层的C代码</p></li></ul><p>其实还有第五个阶段，就是从中断中返回，同样，该过程需要做的就是恢复寄存器的值，切换页表，最后执行一条特殊的返回指令(如<code>sret</code>)真正地返回原状态</p></li></ul><h3 id="1-内核Trap机制"><a href="#1-内核Trap机制" class="headerlink" title="1. 内核Trap机制"></a>1. 内核Trap机制</h3><p>之前说过，riscv中有三种模式: **M(机器模式), S(监管者模式), U(用户模式)**，在riscv中，当发生中断时，程序的控制权不会交给权限更低的模式,  因此，在S模式下发生的中断，永远不会交给U模式进行处理. </p><p>接下来将会介绍从U模式陷入S模式的相关机制</p><p><strong>状态控制寄存器</strong></p><p>当执行中断指令时，会有一些寄存器被自动的修改，其中，就包括了<strong>状态控制寄存器(CSR)</strong>, 当陷入S模式时，硬件所做的操作如下</p><ul><li>发生异常的指令的PC被存入<code>sepc</code></li><li><code>scause</code>被置为异常的类型</li><li><code>sstatus</code>的SIE字段被置为0， 用于关闭中断， <code>sstaus</code>的SPP字段被保存为中断发生前的模式</li><li>将模式转换为<strong>S</strong></li><li>pc被设置为<code>stvec</code></li><li>最后，执行新的pc</li></ul><p>在上面的过程中，页表，即<code>stap</code>寄存器的值并没有改变，因此需要我们手动编码进行修改, 同时，用户的寄存器也没有保存，同样需要我们手动完成</p><h3 id="2-用户态-gt-内核态"><a href="#2-用户态-gt-内核态" class="headerlink" title="2. 用户态-&gt;内核态"></a>2. 用户态-&gt;内核态</h3><p>下面是xv6的源码分析, 仍然是以ecall指令为例</p><ul><li><p>当执行ecall指令前，<code>stvec</code>的值为<code>kernel/trampoline.S</code>的<code>uservec</code>的地址</p></li><li><p>进程执行uservec段的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs asm">uservec:    <br>    # 该段为用户中断(ecall)的起始地址<br>        # 使用监管者模式，但是仍然使用用户的页表<br>        # trap.c sets stvec to point here, so<br>        # traps from user space start here,<br>        # in supervisor mode, but with a<br>        # user page table.<br>        #<br>        # sscratch points to where the process&#x27;s p-&gt;trapframe is<br>        # mapped into user space, at TRAPFRAME.<br>        #<br>        <br>   # swap a0 and sscratch<br>        # so that a0 is TRAPFRAME<br>        # 将TRAPFRAME的地址置于a0中，原a0寄存器的值写入到了sscratch寄存器中<br>        # 这里暂时借用了a0寄存器用做基址，存储TRAPFRAME<br>        csrrw a0, sscratch, a0<br><br>        # save the user registers in TRAPFRAME<br>        # 保存用户(Caller)寄存器<br>        # sd为存储双字(64bit)指令，ra --&gt; ao + 40<br>        sd ra, 40(a0)<br>        sd sp, 48(a0)<br>        sd gp, 56(a0)<br>        sd tp, 64(a0)<br>        sd t0, 72(a0)<br>        sd t1, 80(a0)<br>        sd t2, 88(a0)<br>        sd s0, 96(a0)<br>        sd s1, 104(a0)<br>        sd a1, 120(a0)<br>        sd a2, 128(a0)<br>        sd a3, 136(a0)<br>        sd a4, 144(a0)<br>        sd a5, 152(a0)<br>        sd a6, 160(a0)<br>        sd a7, 168(a0)<br>        sd s2, 176(a0)<br>        sd s3, 184(a0)<br>        sd s4, 192(a0)<br>        sd s5, 200(a0)<br>        sd s6, 208(a0)<br>        sd s7, 216(a0)<br>        sd s8, 224(a0)<br>        sd s9, 232(a0)<br>        sd s10, 240(a0)<br>        sd s11, 248(a0)<br>        sd t3, 256(a0)<br>        sd t4, 264(a0)<br>        sd t5, 272(a0)<br>        sd t6, 280(a0)<br><br>    # save the user a0 in p-&gt;trapframe-&gt;a0<br>        # 之前使用a0寄存器作为基址，现在将a0寄存器的原本值保存到trapframe中<br>        csrr t0, sscratch<br>        sd t0, 112(a0)<br>        <br>        # 下面这些操作会读取陷入监管者模式前用户的TRAPFRAME中的某些寄存器<br>        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp<br>        # 读取sp<br>        ld sp, 8(a0)<br><br>        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid<br>        # 读取tp, tp是线程id<br>        ld tp, 32(a0)<br><br>        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap<br>        # 读取TRAPFRAME中的usertrap()的地址 <br>        ld t0, 16(a0)<br><br>        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp<br>        # 从TRAPFRAME首部取出kernel page table, 然后将其置于satp<br>        # 此刻，进程使用的便是内核页表了<br>        ld t1, 0(a0)<br>        csrw satp, t1<br>        # sfence.vma 指令用于刷新TLB, 当两个参数均为x0(zero)的时候，就会刷新整个TLB表<br>        sfence.vma zero, zero<br><br>        # a0 is no longer valid, since the kernel page<br>        # table does not specially map p-&gt;tf.<br><br>        # jump to usertrap(), which does not return<br>        # 执行usertrap()<br>        jr t0<br></code></pre></td></tr></table></figure><p>这里执行的操作包括: <strong>保存用户寄存器</strong>, <strong>切换用户页表为内核页表</strong>，<strong>读取sp指针</strong>, 最后跳转到<code>usertrap</code>函数, 该函数的地址保存在进程</p><p><code>TRAPFRAME + 16</code>地址处</p><p>在这里可以看出，<strong>TRAPFRAME</strong>的作用就是在进行模式切换的时候，保存这些用户寄存器</p></li><li><p>程序来到trap.c, 执行<code>usertrap()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">usertrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 当陷入trap进入监督者模式的时候，sstatus寄存器的SPP字段会保存</span><br>  <span class="hljs-comment">// 陷入trap前的模式(硬件自动完成), 在这里检查其是否是从用户模式陷入的中断</span><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  <span class="hljs-comment">// 将stvec的值改为kernelvec </span><br>  <span class="hljs-comment">// 因为我们现在已经进入内核模式了，在内核模式陷入中断也会</span><br>  <span class="hljs-comment">// 将PC的值指向stvec</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  <span class="hljs-comment">// 导致trap发生的指令(ecall)的PC会被置于sepc寄存器中</span><br>  <span class="hljs-comment">// 在这里，将其置于进程的trapframe中</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-comment">// scause寄存器中会存储导致trap的类型</span><br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    <span class="hljs-comment">// 这里很关键, epc在执行完ecall指令后会被置为ecall指令的地址，我们应该将其置为下一条指令的地址</span><br>    <span class="hljs-comment">// 不然会陷入无限循环</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    <span class="hljs-comment">// 在trampoline.S中保存完用户模式下的寄存器之后，就可以打开设备中断了</span><br>    intr_on();<br><br>    <span class="hljs-comment">// 系统调用的入口</span><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-comment">// 软件中断</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里会执行一些检查操作，并且执行如下动作:</p><ul><li><p>将<code>stvec</code>改为内核中断处理程序的地址，因为此时进程已经进入了内核态</p></li><li><p>将<code>p-&gt;trapframe-&gt;epc</code>置为ecall的下一条指令，在从中断返回时会跳转到该位置</p></li><li><p>打开中断，此时用户寄存器已经保存完毕，也切换为了内核页表，可以打开中断</p><blockquote><p>再次之前，RISCV在进入trap的时候已经隐式地执行了关中断操作</p></blockquote></li><li><p>执行系统调用</p></li><li><p>准备中断返回，执行<code>uertrapret()</code>中断返回程序</p></li></ul></li><li><p>执行<code>usertrapret()</code>, 进行中断返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">usertrapret</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from</span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until</span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.</span><br>  <span class="hljs-comment">// 关中断</span><br>  intr_off();<br><br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S</span><br>  <span class="hljs-comment">// 将stvec置为trampoline.S中的uservec</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));<br><br>  <span class="hljs-comment">// set up trapframe values that uservec will need when</span><br>  <span class="hljs-comment">// the process next re-enters the kernel.</span><br>  <span class="hljs-comment">// 保存进程的内核trapframe中的内核相关变量</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()</span><br><br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use</span><br>  <span class="hljs-comment">// to get to user space.</span><br>  <span class="hljs-comment">// 从监管者模式中返回到用户模式需要执行sret指令</span><br>  <span class="hljs-comment">// 该指令会将pc设置为spec, 将权限由监管者模式置为sstaus.ssp字段所规定的模式 </span><br>  <span class="hljs-comment">// set S Previous Privilege mode to User.</span><br>  <span class="hljs-comment">// 设置sstatus的ssp字段为用户模式</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode</span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode</span><br>  w_sstatus(x);<br><br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.</span><br>  <span class="hljs-comment">// ecall的下一条指令</span><br>  w_sepc(p-&gt;trapframe-&gt;epc);<br><br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.</span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);<br><br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,</span><br>  <span class="hljs-comment">// and switches to user mode with sret.</span><br>  <span class="hljs-comment">// fn是trampoline.S中userret处的地址</span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);<br>  <span class="hljs-comment">// 该行的意思时，将fn解释成一个void (*)(uint64, uint64)类型的函数，然后以TRAPFRAME,</span><br>  <span class="hljs-comment">// satp作为参数调用</span><br>  ((<span class="hljs-keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数中执行的操作包括:</p><ul><li>关中断，因为接下来要修改寄存器的值</li><li>修改<code>stvec</code>, 使其恢复为<code>trampoline.S</code>中的<code>uservec</code></li><li>修改<code>spec</code>, 将其置为<code>p-&gt;trapframe-epc</code>， 即中断指令的下一条地址</li><li>修改<code>sstatus</code>的SPP字段，将其置为为用户模式</li><li>跳转到<code>trampoline.S</code>的<code>userret</code></li></ul></li><li><p>执行<code>userret</code>处的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs asm">userret:<br>        # 该段指令负责将进程由监管者模式转换为用户模式<br>        # 具体工作包括:<br>        # 1. 恢复用户寄存器<br>        # 2. 从内核页表切换为用户页表<br>        # 3. 执行sret指令真正的返回, 该指令会修改sstaus, 以及pc<br>        # userret(TRAPFRAME, pagetable)<br>        # switch from kernel to user.<br>        # usertrapret() calls here.<br>        # a0: TRAPFRAME, in user page table.<br>        # a1: user page table, for satp.<br><br>        # switch to the user page table.<br>        # 切换用户页表<br>        csrw satp, a1<br>        sfence.vma zero, zero<br><br>        # put the saved user a0 in sscratch, so we<br>        # can swap it with our a0 (TRAPFRAME) in the last step.<br>        # 与之前保存时的动作对应<br>        ld t0, 112(a0)<br>        csrw sscratch, t0<br><br>        # restore all but a0 from TRAPFRAME<br>        ld ra, 40(a0)<br>        ld sp, 48(a0)<br>        ld gp, 56(a0)<br>        ld tp, 64(a0)<br>        ld t0, 72(a0)<br>        ld t1, 80(a0)<br>        ld t2, 88(a0)<br>        ld s0, 96(a0)<br>        ld s1, 104(a0)<br>        ld a1, 120(a0)<br>        ld a2, 128(a0)<br>        ld a3, 136(a0)<br>        ld a4, 144(a0)<br>        ld a5, 152(a0)<br>        ld a6, 160(a0)<br>        ld a7, 168(a0)<br>        ld s2, 176(a0)<br>        ld s3, 184(a0)<br>        ld s4, 192(a0)<br>        ld s5, 200(a0)<br>        ld s6, 208(a0)<br>        ld s7, 216(a0)<br>        ld s8, 224(a0)<br>        ld s9, 232(a0)<br>        ld s10, 240(a0)<br>        ld s11, 248(a0)<br>        ld t3, 256(a0)<br>        ld t4, 264(a0)<br>        ld t5, 272(a0)<br>        ld t6, 280(a0)<br><br>    # restore user a0, and save TRAPFRAME in sscratch<br>        csrrw a0, sscratch, a0<br>        <br>        # return to user mode and user pc.<br>        # usertrapret() set up sstatus and sepc.<br>        # 真正的返回<br>        sret<br></code></pre></td></tr></table></figure><p>该阶段所做的操作包括:</p><ul><li>恢复用户寄存器</li><li>切换回用户页表</li><li>执行<code>sret</code>中断返回指令, 该指令会将pc置为<code>spec</code>, 将模式置为<code>sstaus</code>的SPP字段，即之前设置的用户模式</li></ul></li></ul><h3 id="3-内核中的trap"><a href="#3-内核中的trap" class="headerlink" title="3. 内核中的trap"></a>3. 内核中的trap</h3><p>内核态的<code>trap</code>不会发生模式的转变，因此没有用户态的中断那么复杂</p><p>当trap发生在内核态时，我们不需要对 <code>satp</code>进行处理，因为不需要更换模式，也就不需要更改页表</p><p>这里只需要在该进程对应的内核栈中开辟一段新的frame，将这些值保存在当前内核栈上就行了</p><ul><li><p>kernelvec.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs asm">#<br>        # interrupts and exceptions while in supervisor<br>        # mode come here.<br>        #<br>        # push all registers, call kerneltrap(), restore, return.<br>        #<br>        # 内核态下的中断处理<br>        # 当发生中断或异常时，只需要给当前的内核栈开辟新的空间(frame)<br>        # 然后保存当前的寄存器即可<br>        # 当中断处理结束，恢复寄存器，释放内核栈空间<br>.globl kerneltrap<br>.globl kernelvec<br>.align 4<br>kernelvec:<br>        // make room to save registers.<br>        // 在内核(监管者)模式下，如果发生中断，不需要更换页表操作<br>        addi sp, sp, -256<br><br>        // save the registers.<br>        sd ra, 0(sp)<br>        sd sp, 8(sp)<br>        sd gp, 16(sp)<br>        sd tp, 24(sp)<br>        sd t0, 32(sp)<br>        sd t1, 40(sp)<br>        sd t2, 48(sp)<br>        sd s0, 56(sp)<br>        sd s1, 64(sp)<br>        sd a0, 72(sp)<br>        sd a1, 80(sp)<br>        sd a2, 88(sp)<br>        sd a3, 96(sp)<br>        sd a4, 104(sp)<br>        sd a5, 112(sp)<br>        sd a6, 120(sp)<br>        sd a7, 128(sp)<br>        sd s2, 136(sp)<br>        sd s3, 144(sp)<br>        sd s4, 152(sp)<br>        sd s5, 160(sp)<br>        sd s6, 168(sp)<br>        sd s7, 176(sp)<br>        sd s8, 184(sp)<br>        sd s9, 192(sp)<br>        sd s10, 200(sp)<br>        sd s11, 208(sp)<br>        sd t3, 216(sp)<br>        sd t4, 224(sp)<br>        sd t5, 232(sp)<br>        sd t6, 240(sp)<br><br>// call the C trap handler in trap.c<br>        call kerneltrap<br><br>        // restore registers.<br>        ld ra, 0(sp)<br>        ld sp, 8(sp)<br>        ld gp, 16(sp)<br>        // not this, in case we moved CPUs: ld tp, 24(sp)<br>        ld t0, 32(sp)<br>        ld t1, 40(sp)<br>        ld t2, 48(sp)<br>        ld s0, 56(sp)<br>        ld s1, 64(sp)<br>        ld a0, 72(sp)<br>        ld a1, 80(sp)<br>        ld a2, 88(sp)<br>        ld a3, 96(sp)<br>        ld a4, 104(sp)<br>        ld a5, 112(sp)<br>        ld a6, 120(sp)<br>        ld a7, 128(sp)<br>        ld s2, 136(sp)<br>        ld s3, 144(sp)<br>        ld s4, 152(sp)<br>        ld s5, 160(sp)<br>        ld s6, 168(sp)<br>        ld s7, 176(sp)<br>        ld s8, 184(sp)<br>        ld s9, 192(sp)<br>        ld s10, 200(sp)<br>        ld s11, 208(sp)<br>        ld t3, 216(sp)<br>        ld t4, 224(sp)<br>        ld t5, 232(sp)<br>        ld t6, 240(sp)<br><br>        addi sp, sp, 256<br><br>        // return to whatever we were doing in the kernel.<br>        sret<br><br>        #<br>        # machine-mode timer interrupt.<br>        #<br>.globl timervec<br>.align 4<br>timervec:<br>        # start.c has set up the memory that mscratch points to:<br>        # scratch[0,8,16] : register save area.<br>        # scratch[32] : address of CLINT&#x27;s MTIMECMP register.<br>        # scratch[40] : desired interval between interrupts.<br>        <br>        csrrw a0, mscratch, a0<br>        sd a1, 0(a0)<br>        sd a2, 8(a0)<br>        sd a3, 16(a0)<br><br>        # schedule the next timer interrupt<br>        # by adding interval to mtimecmp.<br>        ld a1, 32(a0) # CLINT_MTIMECMP(hart)<br>        ld a2, 40(a0) # interval<br>        ld a3, 0(a1)<br>        add a3, a3, a2<br>        sd a3, 0(a1)<br><br>        # raise a supervisor software interrupt.<br>li a1, 2<br>        csrw sip, a1<br><br>        ld a3, 16(a0)<br>        ld a2, 8(a0)<br>        ld a1, 0(a0)<br>        csrrw a0, mscratch, a0<br><br>        mret<br></code></pre></td></tr></table></figure></li></ul><p>内核trap处理程序只需要处理三种trap：</p><ul><li><p>如果是硬件中断，就调用相应处理程序处理</p><p>如果是时钟中断(时钟中断属于硬件中断)，那么就让出处理器（由于调度给其它进程的时候， 可能会导致新的<code>traps</code>, <code>sepc</code> 、<code>sstatus</code>寄存器可能被修改，因此最后要对其进行恢复)</p></li><li><p>如果是异常,那么xv6会并调用 <code>panic</code>终止执行</p></li></ul><p>内核态陷阱处理完毕时，直接从frame中取出寄存器的值，然后删去之前在内核栈中开辟的空间</p><ul><li><p>trap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">kerneltrap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> which_dev = <span class="hljs-number">0</span>;<br>  uint64 sepc = r_sepc();<br>  uint64 sstatus = r_sstatus();<br>  uint64 scause = r_scause();<br>  <br>  <span class="hljs-keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: not from supervisor mode&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get() != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: interrupts enabled&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>((which_dev = devintr()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scause %p\n&quot;</span>, scause);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    panic(<span class="hljs-string">&quot;kerneltrap&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span> &amp;&amp; myproc() != <span class="hljs-number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)<br>    yield();<br><br>  <span class="hljs-comment">// the yield() may have caused some traps to occur,</span><br>  <span class="hljs-comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span><br>  w_sepc(sepc);<br>  w_sstatus(sstatus);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-page-fault-技巧"><a href="#4-page-fault-技巧" class="headerlink" title="4. page fault 技巧"></a>4. page fault 技巧</h3><p>当CPU无法转换一个虚拟地址时，即相应的用户页表里没有这一项映射，或者相关权限要求不满足时，就会产生我们熟知的page fault根据执行指令的不同，缺页错误又可以细分为三种：</p><ul><li><strong>Load Page Faults</strong>：无法转换的虚拟地址位于一条加载（读）指令中。Scause：13</li><li><strong>Store Page Faults</strong>：无法转换的虚拟地址位于一条存储（写）指令中。Scause：15</li><li><strong>Instruction Page Faults</strong>：无法转换的虚拟地址位于一条执行指令中。Scause：12</li></ul><p>RISC-V会将代表缺页错误类型的数字存放进<code>scause</code>寄存器中，同时将无法转换的虚拟地址存放在<code>stval</code>寄存器中</p><h4 id="1-copy-on-write-COW"><a href="#1-copy-on-write-COW" class="headerlink" title="1. copy-on-write(COW)"></a>1. copy-on-write(COW)</h4><ul><li><p>使用场景</p><p>在程序中，当我们调用 <code>fork</code>创建一个子进程后，经常第一件事情就是调用 <code>exec</code>运行一些其他程序。这里看起来有点浪费，因为 <code>fork</code>创建了父进程<code>page</code>的完整的拷贝，而 <code>exec</code>做的第一件事情就是创造新的<code>page</code>, 然后释放这些拷贝而来的<code>page</code></p></li><li><p>基本思想</p><p>与上面问题对应的优化则是：当我们创建子进程时，直接共享父进程的物理页</p><blockquote><p> 这里可以设置子进程的PTE指向父进程对应的物理页，然后将共享的页设置为read-only, 以确保隔离性</p></blockquote><p>在某个时间点，当某个进程需要更改共享的内容时，我们会得到<code>page fault</code>,  此时内核将页错误相关的物理页拷贝到新分配的物理页中，并将新分配的物理页映射到发生异常的进程里，由于新分配的<code>page</code>现在仅对父/子进程可见，原<code>page</code>现在仅对子/父进程有效，因此，内核会自动将这些<code>page</code>设置为可读写</p></li><li><p>引用计数</p><p>当一个进程决定释放一个页或者结束本进程时，我们不能立即释放相应的物理页，因为可能还有其他进程也在使用这些物理页。所以我们需要对于每一个物理页的引用进行计数，当某个进程释放一个物理页时，我们将物理页的引用数减1。如果引用数等于0，那么我们才真正去释放物理页</p></li></ul><h4 id="2-zero-fill-on-demand"><a href="#2-zero-fill-on-demand" class="headerlink" title="2. zero fill on demand"></a>2. zero fill on demand</h4><p>当编译器在生成二进制文件时，会向BSS区填写未被初始化或者初始化为0的全局变量。但其实这里的BSS区域特别浪费空间：假如在C语言中定义了一个特别大的矩阵作为全局变量，它的元素初始值都是0，那么我们没有必要为这个矩阵所有元素分配空间，只需要记住这个矩阵的内容是0就行。</p><p>具体的操作就是在物理内存中，我们只分配一个内容全是0的页。然后将所有虚拟地址空间中存储值全为0的页都映射到这一个物理页上，并抹去映射中 <code>PTE_W</code>相关的flag标记</p><p>之后在某个时间点，应用程序尝试写BSS中的一个页时，就会得到<code>page fault</code>，进入陷阱。这时我们就可以在物理内存中申请一个真正的物理页，将其内容设置为0，设置相应的PTE为可写，然后将发生异常的虚拟的页指向刚申请的物理页</p><h4 id="3-demand-paging"><a href="#3-demand-paging" class="headerlink" title="3. demand paging"></a>3. demand paging</h4><p>XV6会将用户空间里的所有有效区域（text区， data区）全部映射至页表中，并将它们从磁盘中全部加载到内存里。这其实是一个代价很高的操作，我们并不一定需要将整个二进制都加载到内存中，可以直到应用程序实际需要这些指令的时候再加载内存。</p><p>所以我们为<code>text</code>和<code>data</code>分配好地址段，但是相应的PTE并不对应任何物理页。对于这些PTE，我们只需要将<code>valid bit</code>位设置为0即可。当发生<code>page fault</code>时，我们在<code>page fault</code>处理程序中再去从程序文件中读取相应页的数据，加载到内存中，然后将这些物理页映射到页表中，最后再重新执行指令</p><h4 id="4-lazy-page-allocation"><a href="#4-lazy-page-allocation" class="headerlink" title="4. lazy page allocation"></a>4. lazy page allocation</h4><p>在XV6中，一旦调用了 <code>sbrk</code>，内核会立即分配应用程序所需要的物理内存。但是实际上应用程序很难预测自己需要多少内存，所以通常应用程序倾向于申请多于自己所需要的内存。这意味着进程的内存消耗会增加许多，但是有部分内存永远也不会被应用程序所使用到。</p><p>利用lazy allocation我们可以解决这里的问题。即像 <code>sbrk</code>这样的系统调用并不会真正去分配物理内存。如果应用程序使用到了新申请的那部分内存，就会触发页错误。这时page fault handler才去实际分配一个物理页，将这个页映射到用户页表中，最后重新执行指令。</p><blockquote><p>内存耗尽:</p><p>当发生<strong>内存耗尽</strong>的情况，可以选择<strong>撤回</strong>操作，即将内存中的某些<code>Page</code>刷新回磁盘，然后它们的位置就空出来了</p></blockquote><p>上面这些技术均是关于<code>page fault</code>的一些技巧，更重要的是它们对于进程来说完全是透明的，硬件会自动的完成这些事</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[xv6]:内核启动</title>
    <link href="/2022/03/29/xv6-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/03/29/xv6-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>当RISC-V计算机启动时，他会初始化自己，并且运行一个位于只读存储器的引导装载程序（boot loader）。这个程序会把XV6的内核加载到 <code>0x80000000</code>这个物理地址，然后CPU从此位置开始执行。</p><p>每个CPU刚开始运行时都会为自己设置一个大小为4096字节的向下生长的栈。由于此时系统操作的地址都是物理地址，所以每个CPU都会根据自己的CPU编号计算出属于自己的栈顶位置，以避免栈相互渗透干扰。（entry.S/_entry）</p><ul><li><p>entry.S</p><p><img src="1.png" alt="1"></p><blockquote><p>kernel.ld 连接脚本会将_entry符号置于0x80000000处</p></blockquote></li></ul><p>此时系统位于机器模式（machine mode）下，但是由于该模式下我们无法使用虚拟地址空间，因此我们需要尽快切换进入管理员模式（supervisor mode）。为了达成这个目的，我们需要巧用几个机器模式下的寄存器和指令，这些寄存器原本是用来在机器模式下处理异常的：</p><ul><li><code>mepc</code>寄存器：当发生异常时，<code>pc</code>寄存器中的值会被复制到该寄存器中。</li><li><code>mstatus</code>寄存器：记录发生异常的指令运行时的一些状态</li><li><code>mret</code>指令：从机器模式返回。执行完该指令后会把存储在 <code>mepc</code>的地址复制到 <code>pc</code>寄存器中，并恢复原来的模式</li></ul><p>此时我们的系统并不是因为发生异常后进入的，但我们可以通过修改寄存器的值来营造这样的假象：将 <code>mstatus</code>中代表异常指令所处模式的那一个bit位设置成管理员模式，将 <code>mepc</code>设置为 <code>main</code>函数的地址。这样修改后，就好像是之前正以管理员模式运行，但是刚运行到 <code>main</code>函数时发生了异常，进入机器模式</p><ul><li><p>start.c</p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><p><img src="4.png" alt="4"></p></li></ul><p>这样修改后，当我们调用 <code>mret</code>指令时，就可以“返回到之前发生异常的”地方，即 <code>main</code>函数处，且模式也“恢复”成了原来的管理员模式。于是完成了以管理员模式运行 <code>main</code>函数的目的。当然我们在机器模式下也不是立刻就跳转进入管理员模式的，中间还是需要进行了一些设置的。比如关闭虚拟地址的转换功能（这样之后进入管理员模式后使用的也是物理地址），初始化时钟中断，将cpu编号存入 <code>tp</code>寄存器里。(kernel/start.c)</p><ul><li>start.c</li></ul><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><p>在 <code>main</code>函数(kernel/main.c)里会根据CPU编号进行一些初始化设置，CPU0会先进行初始化，并在初始化时调用创建第一个用户进程其余CPU只有等CPU0完成初始化后才能进行初始化（初始化调用的函数与CPU0并不相同）</p><p>第一个用户进程会创建console（控制台），并且将文件描述符0，1，2均指向console。然后该进程调用 <code>fork</code>，在子进程中调用 <code>exec</code>来运行 <code>sh</code>，即运行操作系统的终端。这样就完成了内核的启动</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:ICMP与IGMP</title>
    <link href="/2022/03/17/TCP-IP%E8%AF%A6%E8%A7%A3-ICMP%E4%B8%8EIGMP/"/>
    <url>/2022/03/17/TCP-IP%E8%AF%A6%E8%A7%A3-ICMP%E4%B8%8EIGMP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>简介</p><ul><li><p>IP协议本身并没有提供直接的方式来发现那些发往目的地址失败的IP数据报，也无法获知它们发送失败的原因，</p></li><li><p>为了解决这些不足之处，**ICMP(Internet控制报文协议)**被用来与IP层结合使用, 以提供差错诊断以及控制信息</p></li><li><p>ICMP工作在IP层与传输层之间，它既不是IP协议，也不是传输层协议</p></li></ul></li></ul><h3 id="1-ICMP"><a href="#1-ICMP" class="headerlink" title="1. ICMP"></a>1. ICMP</h3><p><strong>功能</strong></p><p>ICMP协议的功能主要有：</p><ol><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ol><p><strong>在IPV4中的封装</strong></p><p><img src="1.png" alt="1"></p><blockquote><p>在IPV4中，<strong>协议</strong>字段会被置为1， 对应的ICMP报文也被称为ICMPv4</p></blockquote><p><strong>报文头</strong></p><p><img src="2.png"></p><p><strong>分类</strong></p><p>ICMP报文可以分为两大类:</p><ol><li>⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」</li><li>另⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」</li></ol><p>通过报文头的<strong>Type</strong>字段可以判断报文的类型，配合<strong>Code</strong>字段可以进行精确的功能判断</p><p><img src="3.png" alt="3"></p><h3 id="2-IGMP"><a href="#2-IGMP" class="headerlink" title="2. IGMP"></a>2. IGMP</h3><ul><li><p>组播</p><p>组播允许一台主机发送报文给一组主机，范围比单播要大，比广播要小</p></li></ul><p><strong>IGMP</strong></p><p>IGMP与ICMP没有什么关系，是两个完全不同的协议，其全称为<strong>互联网组管理协议</strong>, 用于管理组播中组的分配，其工作在<strong>组播成员以及最</strong></p><p><strong>后一跳路由器之间</strong><br><img src="4.png" alt="4"></p><ul><li>IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除⾮主机 通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 <strong>IGMP 路由器表</strong>，路由器后续就会转发 组播包到对应的主机了</li><li>IGMP 报⽂采⽤ IP 封装，IP 头部的协议号为 2，⽽且 TTL 字段值通常为 1，因为 IGMP 是⼯作在主机与连接 的路由器之间</li></ul><p>IGMP 分为了三个版本分别是，IGMPv1、IGMPv2、IGMPv3，接下来，以IGMPv2作为例⼦，说说<strong>常规查询与响应</strong>和<strong>离开组播组</strong>这两个⼯作机制</p><ul><li><p>常规查询和响应</p><p><img src="5.png" alt="5"></p><ul><li><p>路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂</p></li><li><p>主机1 和 主机 3 收到这个查询，随后会启动<strong>报告延迟计时器</strong>，计时器的时间是随机的，通常是 0~10 秒，</p><p>计时器超时后主机就会发送 IGMP<strong>成员关系报告报⽂</strong>(源 IP 地址为⾃⼰主机的 IP 地址，⽬的 IP 地址为组播 地址), 该报文包含了组的成员信息</p><p>如果在定时器超时之前，某个主机收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这 样可以减少⽹络中多余的 IGMP 报⽂数</p></li><li><p>路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播地址的数据 到达路由器，它会把数据包转发出去</p></li></ul></li><li><p>离开组播组⼯作机制</p><p><img src="6.png" alt="6"></p><p>情况1: 主机离开后该组还有其它主机</p><ul><li><p> 主机1要离开组 224.1.1.1，发送 IGMPv2 离组报⽂，报⽂的⽬的地址是 224.0.0.2（表示发向⽹段内的所有路 由器）</p></li><li><p> 路由器 收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个），以便确认该⽹络是 否还有 224.1.1.1 组的其他成员</p></li><li><p> 主机 3 仍然是组 224.1.1.1 的成员，因此它⽴即响应这个特定组查询。路由器知道该⽹络中仍然存在该组播组 的成员，于是继续向该⽹络转发 224.1.1.1 的组播数据包</p></li></ul><p>情况2: 主机离开之后该组没有别的主机</p><p><img src="7.png" alt="7"></p><ul><li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报⽂</li><li>路由器收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个）。此时在该⽹段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询</li><li>⼀定时间后，路由器认为该⽹段中已经没有 224.1.1.1 组播组成员了，将不会再向这个⽹段转发该组播地址的 数据包</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:防火墙与NAT</title>
    <link href="/2022/03/17/TCP-IP%E8%AF%A6%E8%A7%A3-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8ENAT/"/>
    <url>/2022/03/17/TCP-IP%E8%AF%A6%E8%A7%A3-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8ENAT/</url>
    
    <content type="html"><![CDATA[<h3 id="1-防火墙"><a href="#1-防火墙" class="headerlink" title="1. 防火墙"></a>1. 防火墙</h3><ul><li><p>简介</p><p>防火墙是一种用于限制所转发流量类型的路由器, 最常用的两种防火墙为<strong>代理防火墙</strong>与<strong>包过滤防火墙</strong></p></li></ul><h4 id="1-包过滤防火墙"><a href="#1-包过滤防火墙" class="headerlink" title="1. 包过滤防火墙"></a>1. 包过滤防火墙</h4><ul><li><p>概念</p><p>包过滤防火墙会设置一个过滤器，当有报文需要转发时，会检查其网络层或传输层报头中的某些字段，如IP地址，ICMP类型，根据数据报端口号确定的各种UDP/TCP服务</p></li><li><p>无状态与有状态</p><p>包过滤防火墙还分有<strong>无状态</strong>和<strong>有状态</strong>两种，无状态的包过滤防火墙会过滤每一个数据报，而有状态的防火墙能够推断出那些属于同一个IP数据报但是还未到达的IP的消息</p></li><li><p>图例</p><p><img src="1.png" alt="1"></p><blockquote><p>DMZ(Demilitarized Zone, 非军事区), 是一个外网和内网之间，用于给外网提供服务的子网，通常不包含任何机密资料</p></blockquote></li></ul><h4 id="2-代理防火墙"><a href="#2-代理防火墙" class="headerlink" title="2. 代理防火墙"></a>2. 代理防火墙</h4><ul><li><p>概念</p><p><strong>代理防火墙</strong>并不是真正意义上的网络路由器，而是运行着一个或多个**应用层网关(Application-Layer Gateways, ALG)**的主机，该主机拥有多个网络接口，可以在应用层中继两个连接之间的流量</p><p>客户机会将防火墙当做服务器，服务器会将防火墙当做客户机</p><blockquote><p>所谓的网关，就是中继设备，用于连接不同的主机或路由器</p></blockquote><p>代理防火墙必须要为每个传输层服务设置一个代理，任何新服务如果想要与防火墙通信，必须要在防火墙中设置相应的代理服务，这极大确保了安全性</p></li><li><p>图例</p><p><img src="2.png" alt="2"></p></li><li><p>实例</p><p>代理防火墙的两种最常见形式为: <strong>HTTP代理防火墙</strong>，<strong>SOCKS防火墙</strong></p></li></ul><h3 id="2-NAT"><a href="#2-NAT" class="headerlink" title="2. NAT"></a>2. NAT</h3><p><strong>网路地址转换(NAT)</strong></p><ul><li>NAT:NetWork Address Translation</li></ul><p><strong>NAT产生的背景</strong></p><p>IPv4地址逐渐被瓜分殆尽,NAT技术的出现使得IPV4起死回生</p><p><strong>NAT的作用</strong></p><p>NAT的作用即是是一个子网对于外界来说使用一个共同的IP地址</p><ul><li><p>NAT使能路由器对外界来说就如同一个具有单一IP地址的单一网络，它对外界隐藏了了家庭网络的细节</p></li><li><p>[RFC1918]规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255</p><p>这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被<code>IANA</code>作为私有地址保留</p><p>这些地址<strong>可以在任何组织或企业内部使用</strong>，和其他Internet地址的区别就是，<strong>仅能在内部使用，不能作为全球路由地址</strong>，</p><p>这些IP地址也被称为<strong>私网IP</strong></p></li><li><p>路由器从ISP经过DHCP协议得到它的Ip地址，并为它所控制的家庭网络中的主机提供地址</p></li></ul><blockquote><p>如今的NAT是基本NAT + NAPT(Network Address Port Translation, 网络地址端口转换)</p><p>基本NAT只会执行IP地址的重写，但这样的话就要求当同时有N个设备发出报文时，NAT路由器必须能够提供N个公有地址，有些不现实</p><p>NAPT则是采用了公有IP+不同端口号的方式，这使得通常只需要一个公有IP地址即可</p></blockquote><p><img src="3.png" alt="3"></p><p><strong>NAT的实现过程</strong></p><blockquote><p>NAT转换表:</p><p>NAT转换表中包含了家庭网络，即私网中的主机的端口号和IP地址(家庭网络地址),</p><p>当建立TCP连接时，一旦SYN报文被发出，表中就会增加一个条目，而一旦接收到FIN报文，表文对应的条目就会被删除</p></blockquote><ul><li><p>一个主机位于家庭网络地址为10.0.0.1,请求IP地址为128.119.40.186的某台Web服务器上的一个Web页面</p></li><li><p>源主机任意指派了一个源端口号3345并将数据报发送到局域网中</p></li><li><p>NAT路由器接收到该数据报，并为该数据报生成一个新的源端口号5001(这个源端口号不能出现在当前的NAT转换表中)，将其源IP地址改为自身输出接口的IP地址</p><blockquote><p>通过NAT公有IP + 端口号，可以生成大量不同套接字</p></blockquote></li><li><p>NAT路由器的NAT转换表增加表项(3345,10.0.0.1,5001)</p></li><li><p>Web服务器接收到请求报文，发送响应报文，目的IP与目的端口均是路由器之前自己生成的</p></li><li><p>路由器接收到响应报文，将其中的目的IP与目的端口改为源主机的IP与端口(10.0.0.1,2245)，并将响应发送给源主机</p></li></ul><p><strong>NAT的缺点</strong></p><ul><li>外部⽆法主动与 NAT 内部设备建⽴连接</li><li>转换表的⽣成与转换操作都会产⽣性能开销</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置</li></ul><p><strong>NAT穿越技术</strong></p><p><strong>NAT 穿越技术</strong>拥有这样的功能:  它能够让⽹络应⽤程序主动发现自己位于 NAT 设备之后，并且会<strong>主动获得 NAT设备的公有 IP</strong>，并<strong>为⾃⼰</strong>建⽴端⼝映射条⽬，即不需要NAT路由器为它建立映射了</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:DHCP</title>
    <link href="/2022/03/16/TCP-IP%E8%AF%A6%E8%A7%A3-DHCP/"/>
    <url>/2022/03/16/TCP-IP%E8%AF%A6%E8%A7%A3-DHCP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>简介</p><ul><li><p>DHCP属于应用层协议，它的作用是为主机或者路由器指定配置信息(IP地址, 子网掩码, DNS服务器地址等)</p></li><li><p>DHCP前身是被称为<strong>BOOTP</strong>的<strong>Internet引导程序协议</strong>, 该协议已经过时，但是DHCP完全兼容BOOTP</p></li><li><p>DHCP使用<strong>租用</strong>机制来将这些配置信息租用给客户机，但租期到了之后，客户机可以选择续约</p></li><li><p>DHCP的传输层协议为UDP, 客户机，服务器分别使用固定端口号68, 67</p></li></ul></li></ul><h3 id="1-地址池与租用"><a href="#1-地址池与租用" class="headerlink" title="1. 地址池与租用"></a>1. 地址池与租用</h3><p>DHCP服务器为客户机提供三种地址分配: <strong>自动分配，动态分配，手动分配</strong>, 其中<strong>动态分配</strong>使用的最多，接下来只关注动态分配</p><ul><li><p>在动态分配中，客户机向DHCP服务器请求一个IP地址，服务器从地址池中选出一个可用的地址作为响应</p><p>这个地址池是一个连续的IP地址范围</p></li><li><p>服务器会根据客户机请求中提供的信息并结合外部信息(如接受请求的接口)为客户机分配IP地址</p><p>当服务器向客户机提供租约之后，会将租约写入<strong>非易失性存储器</strong>当中，以确保当服务器重启之后租约信息不会丢失</p></li></ul><p><strong>DHCP消息格式</strong></p><p><img src="1.png" alt="1"></p><p>该图其实是BOOTP的消息格式，但是与DHCP完全兼容，DHCP可以在上面的<strong>选项超载区域</strong>携带额外选项</p><p><strong>DHCP协议操作</strong></p><ul><li><p>总流程</p><p><img src="2.png" alt="2"></p><p>当一个主机第一次连接该子网时，会经历上面的阶段</p><ul><li><p><strong>DHCPDISCOVER</strong></p><p>客户机使用链路层广播来寻找可用的DHCP服务器，消息中包含了自身的相关信息，如自身MAC地址</p></li><li><p><strong>DHCPOFFER</strong></p><p>如果有DHCP服务器接受到了请求，就会发送DHCPOFFER响应报文, 发送方式为单播，因为已经知道了客户机的MAC地址</p><p>响应消息中包含服务器提供的IP地址、子网掩码、租期以及提供IP的DHCP服务器的IP地址</p></li><li><p><strong>DHCPQEQUEST</strong></p><p>之所以还需要该过程是因为<strong>可能不止有一个DHCP服务器向客户机发送DHCPOFFER</strong>, 但一个客户网卡只能接受一个租约服务</p><p>因此客户机再次进行<strong>广播</strong>，广播消息中包含了其第一次接受到的DHCP服务器的IP地址，其他发送租约的DHCP接受到该消息之后</p><p>就会收回自己的租约(把分配出去的IP地址归还会地址池等)</p></li><li><p><strong>DHCPACK</strong></p><p>如果服务器可以分配的话，它会响应一个DHCPACK消息表示确认，可如果不能分配的话，就会响应一个DHCPNAC消息</p></li><li><p>检测冲突</p><p>客户机会向服务器发送一个检测消息(如ACD)，用于检测分配的地址是否重复</p><p>如果冲突，那么客户机就会向服务器发送一个DHCPDECLINE的消息表示该地址不能使用, 在一段时间过后，可能进行重新检测</p><p>如果客户机主动放弃租约，会向服务器发送一个DHCPRELEASE消息</p></li></ul></li><li><p>租约更新</p><p>有时，上述流程可以被简化成<strong>DHCPREQUEST</strong>和<strong>DHCPACK</strong>, 这发生在客户机已经有一个IP地址并且希望更新其租约的情况下，客户机会通过DHCPREQUEST消息来请求其正在使用的地址</p></li><li><p>获取其他配置信息</p><p>客户机还可以发送一个DHCPREFORM消息来获取更多非地址的配置信息</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:地址解析协议</title>
    <link href="/2022/03/16/TCP-IP%E8%AF%A6%E8%A7%A3-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/16/TCP-IP%E8%AF%A6%E8%A7%A3-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ul><li><p>简介</p><p>一台主机如果要将自己的链路层帧发送给另一台主机，光知道目的IP地址是不够的，还需要直到主机在网络中的有效硬件地址</p><blockquote><p>硬件地址:</p><p>硬件地址, 又被称为MAC地址，链路层地址，物理地址，以太网地址, 是由设备制造商定义的，它会存储在设备的永久性内存当中，永远不会改变, 大小为48位.  对主机而言，一块网卡就对应着一个MAC地址. 当两个局域网的主机之间传递以太网帧的时候，由以太网地址确定该帧的目的接口</p><p>IP地址:</p><p>IP地址由网络管理员进行分配，当移动设备在不同子网之间进行移动时，IP地址也会发生改变</p></blockquote></li></ul><h3 id="1-ARP"><a href="#1-ARP" class="headerlink" title="1. ARP"></a>1. ARP</h3><p>**地址解析协议(ARP)**提供了一种在IPV4地址到MAC地址之间的映射</p><p>ARP从设计上是支持多种协议的，但大多数情况下都是用来执行IPV4到MAC地址的映射</p><p><strong>工作机制</strong></p><p>ARP的工作基于<strong>链路层广播</strong>, 下面考虑当应用程序想要访问IP地址为10.0.0.1的主机</p><ul><li><p>如果10.0.0.1与当前主机位于同一个子网，那么直接进行链路层广播，否则，需要进行路由器中转</p></li><li><p>在共享的链路层网段之上，ARP向该网段上的其它所有主机均发送一条<strong>ARP请求</strong>，即<strong>广播</strong></p><p>向它们询问谁当前的IP地址为10.0.0.1</p></li><li><p>如果有主机接受到ARP请求并且其IP地址为10.0.0.1, 那么向发送主机发送<strong>ARP响应</strong>，是<strong>单播</strong>，响应中包含了自己的MAC地址</p></li><li><p>发送方收到响应，建立TCP连接，向目的地址发送报文</p></li></ul><p><img src="1.png" alt="1"></p><blockquote><p>点到点链路(PPP)并不使用ARP, 在PPP协议中，当链路建立完毕之后，就不需要使用MAC地址了</p></blockquote><h3 id="2-ARP缓存"><a href="#2-ARP缓存" class="headerlink" title="2. ARP缓存"></a>2. ARP缓存</h3><p>主机和路由器都会为自己的每个网络接口维护一个<strong>ARP表(ARP缓存)</strong>, 当主机/路由器接收到一个ARP请求帧时， 会使用其中的</p><p>源IP地址和源MAC地址来在该表中记录一个条目, 当下一次需要向该IP发送报文时，就可以直接使用缓存得到对应的MAC地址，不必进行</p><p>广播</p><ul><li><p>arp命令</p><p>在Linux或者windows当中都提供了arp命令用于查看当前主机的每个网络接口上的ARP表</p><ul><li><p>Linux</p><p><img src="2.png" alt="2"></p><p>其中, <code>ether</code>代表接口类型为以太网接口，<code>Flags Mask</code>有3种: </p><ol><li>C: 动态学习产生的</li><li>M: 手工输入的</li><li>P: 表示“发布”， 常用于代理ARP</li></ol></li><li><p>Windows</p><p><img src="3.png" alt="3"></p><p>与LInux类似</p></li></ul></li></ul><h3 id="3-超时"><a href="#3-超时" class="headerlink" title="3. 超时"></a>3. 超时</h3><p><strong>ARP重传</strong></p><p>当一个ARP请求在指定时间内没有收到回应时，就会执行重传操作，而这个重传的时间看系统的实现, [RFC1122]建议设置为1秒一次</p><blockquote><p>当发送主机没有收到ARP响应的时候，会在自己的ARP表中建立一个不完整条目</p></blockquote><p><img src="4.png" alt="4"></p><p><strong>ARP缓存超时</strong></p><p>ARP表中的条目可能是陈旧的，通常情况下完整条目的存在时间是20分钟，而不完整条目的存在时间是3分钟</p><h3 id="4-代理ARP"><a href="#4-代理ARP" class="headerlink" title="4. 代理ARP"></a>4. 代理ARP</h3><p><strong>代理ARP</strong>使一个主机代替其它主机方ARP响应帧，这样做可以使得发送方认为做出相应的系统就是目的主机，该技术可以用于</p><p>在物理网络上隐蔽自己，但并不常见</p><h3 id="5-免费ARP与ACD"><a href="#5-免费ARP与ACD" class="headerlink" title="5. 免费ARP与ACD"></a>5. 免费ARP与ACD</h3><ul><li><p>免费ARP</p><p>免费ARP指的是这样一种ARP请求帧: 其目的IP地址就是自身的IP地址， 免费ARP用于实现一些特殊的用途</p><ul><li><p>确认是否有其它主机配置了相同的IPV4地址</p><p>通常情况下，主机并不希望免费ARP接收到响应报文，但有时主机会接受到其它主机的警告报文，用于提醒主机使用了重复的IP地址</p></li><li><p>更新其它主机的ARP缓存</p></li></ul></li><li><p>ACD</p><p>**IPV4地址检测冲突(ACD)**，如果网段中有着相同的IPV4地址，那么使用ACD协议可以解决这个问题, ACD使用了两个分组:</p><ol><li> <strong>ACD探测分组</strong> ACD探测分组用于查看候选IPV4地址是否被其它系统所使用</li><li> <strong>ACD通告分组</strong> ACD通告分组用于通告发送方使用候选IPV4地址的意图</li></ol><p>初次之外, ACD协议还会在主机接收到一个ARP响应帧的时候检查发送主机的原地址是否与自身的IP地址重复</p></li></ul><h3 id="6-ARP帧"><a href="#6-ARP帧" class="headerlink" title="6. ARP帧"></a>6. ARP帧</h3><p><img src="5.png" alt="5"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:链路层</title>
    <link href="/2022/03/15/TCP-IP%E8%AF%A6%E8%A7%A3-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/03/15/TCP-IP%E8%AF%A6%E8%A7%A3-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<ul><li><p>术语介绍</p><ul><li><p>PDU: 消息对象，因特网的每一层都有自己的消息对象，传输层的消息对象为报文段，链路层的消息对象为<strong>帧</strong></p></li><li><p>MTU: 最大传输单元，用于描述链路层帧有效载荷的最大长度，该值通常为1500字节</p><p>路径MTU: 当两台主机跨越多个网络进行通信时，每条链路可能有不同的MTU, 在所有网络路径上，最小的MTU被称为路径MTU</p></li></ul></li></ul><p>有关链路层的知识点很繁杂，并且过于底层，因此只做简单介绍</p><h3 id="1-MAC协议"><a href="#1-MAC协议" class="headerlink" title="1. MAC协议"></a>1. MAC协议</h3><p><strong>CSMA/CD</strong></p><p>最开始的以太网的网络结构如下所示</p><p><img src="1.png" alt="1"></p><ul><li>多个网络站点被连接到同一个共享的电缆段之上，在任何给定的时间，网络中只能有一个帧进行传输</li></ul><p><strong>带冲突检测的载波侦听多路访问(CSMA/CD)</strong></p><p>这是一种在每个以太网接口上使用的分布式算法，用于协调每个站点发送数据</p><p>算法描述:</p><ul><li>站点首先检测目前网络上正在发送的信号，并在网络空闲时发送自己的帧，即<strong>载波侦听</strong></li><li>如果其它站碰巧同时发送，那么重叠的电信号将会被是做一次<strong>碰撞</strong>，此时，每个站将会等待一段随机时间，然后重新发送</li><li>最终，每个站要么得到机会发送，要么在一定此时的重新发送失败后超时</li></ul><p><strong>MAC协议</strong></p><p>**介质访问控制协议(MAC)**其实是CSMA/CD这种协议的正式名称，可以理解为它的超集</p><p>MAC协议包含竞争协议(如CSMA/CD)和协调协议两种</p><ul><li><p>现状</p><p>如今，共享电缆已经被双绞线所替代，如CSMA/CD之类的竞争协议不再流行，现在的网络结果基于交换机，站点之间的线路通常不共享</p><p><img src="2.png" alt="2"></p></li></ul><h3 id="2-以太网帧格式"><a href="#2-以太网帧格式" class="headerlink" title="2. 以太网帧格式"></a>2. 以太网帧格式</h3><ul><li><p>图例</p><p><img src="3.png" alt="3"></p><p>一些比较重要的字段:</p><ul><li><p>前导</p><p>用于时钟同步</p></li><li><p>SFD</p><p>帧起始分隔符，表示帧的开始，为固定值0xAB</p></li><li><p>DST/SRC</p><p>MAC地址</p></li><li><p>有效载荷</p><p>该字段用于存放上层PDU, 由于有效载荷有着最小字节要求，如果字节数不够，后面会使用0进行填充</p></li></ul></li></ul><h3 id="3-网桥与交换机"><a href="#3-网桥与交换机" class="headerlink" title="3. 网桥与交换机"></a>3. 网桥与交换机</h3><ul><li>网桥: 网桥用于连接多个物理的链路层网络，交换机即是高性能的网桥</li></ul><p><img src="4.png" alt="4"></p><p>上面的图例中，每个交换机都有<strong>端口</strong>，用一个编号表示，每个交换机，每个站点，都有自己的MAC地址</p><p>下面分析一下链路层帧在经过网桥(链路层帧)之后会发生什么：</p><ol><li><p>每个交换机内部都会有一张表，每个条目是一个{站点MAC地址，端口编号}对，当第一次打开一个交换机时，该表为空</p></li><li><p>当一个链路层帧到达交换机，且该帧的目的地址与交换机的MAC地址不相符时，交换机会尝试在表中进行寻找</p></li><li><p>如果没有找到对应的条目，它会向其它所有端口发送该链路层帧， 即该帧会被复制很多份，有点类似于广播</p><p>同时，交换机在自己的表中做好记录(忽略细节)</p><p>如果找到了，则会将链路层帧经过条目指定的端口发出</p></li></ol><p>由于站可能出现移动，网卡更换，MAC地址改变的情况，所以网桥不能假设其表中记录的地址一定是正确的，因此，网桥会为每个条目启动一个<strong>定时器</strong>，如果超过一定时间仍没有收到新的去往相同MAC地址的帧，就会清除该条目</p><h3 id="4-环回"><a href="#4-环回" class="headerlink" title="4. 环回"></a>4. 环回</h3><p>有时，客户可能希望使用Internet协议来与本地上的服务器进行通信，大多数系统实现了这一功能，它们使用一个虚拟的<strong>环回网络接口</strong>来实现，其使用软件实现，并没有与之对应的网卡</p><ul><li><p>Linux环境中的环回</p><p>Linux为环回接口分配的IPV4地址为127.0.0.1, IPV6地址则是(::1), 为它分配的名称叫<code>localhost</code>, 简写为<code>lo</code></p></li><li><p>注意点</p><ul><li>发送到环回接口的IP数据报不会出现在任何网络中</li><li>发送到环回接口的IP数据报会经过传输层以及网络层的传输，当数据报离开网络层时重新将其送回本地的网络层</li></ul></li></ul><h3 id="5-其它协议"><a href="#5-其它协议" class="headerlink" title="5. 其它协议"></a>5. 其它协议</h3><ul><li><p>STP</p><p>由于网络中存在很多交换机，这些交换机可能会使得帧在它们之间不断循环，即形成回路，链路层使用**生成树协议(STP)**来解决该问题</p></li><li><p>PPP</p><p>PPP表示<strong>点到点协议</strong>，本质上其实是一个协议集合，它用于在两个节点之间创建直接连接，进而传递IP数据报</p><p>除此之外，该协议还提供连接认证，传输加密以及压缩等服务</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:Internet地址结构</title>
    <link href="/2022/03/14/TCP-IP%E8%AF%A6%E8%A7%A3-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/14/TCP-IP%E8%AF%A6%E8%A7%A3-Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="1-IP地址的表示"><a href="#1-IP地址的表示" class="headerlink" title="1. IP地址的表示"></a>1. IP地址的表示</h4><p><strong>IPV4</strong></p><p>IPV4地址为32位，通常采用<strong>点分十进制</strong>表示</p><p><img src="1.png" alt="1"></p><p><strong>IPV6</strong></p><p>IPV6地址为128位，长度是IPV4的四倍，传统的表示方法是将其分为8 *4个16进制数</p><p><img src="2.png" alt="2"></p><p>其中，还有一些简写方式，在RFC[5952]中已经将这些作为强制要求 :</p><ol><li><p>前导0简写</p><p>5f05:2000:80ad:5800:0058:0800:2023:1d71——-&gt;5f05:2000:80ad:5800:58:800:2023:1d71</p></li><li><p>全0块省略, 使用::代替</p><p>但是如果有多处全0块只能省略一处，并且只能用于压缩数最大的地方</p><p>0:0:0:0:0:0:0:1 ————-&gt;::1</p></li><li><p>a到f的16进制数小写</p></li></ol><h4 id="2-IP地址结构"><a href="#2-IP地址结构" class="headerlink" title="2. IP地址结构"></a>2. IP地址结构</h4><ul><li><p>单播: 目的地址为单一目标</p><p>在IPV4中: 0.0.0.0~255.255.255.255为单播地址</p></li></ul><p>下面将介绍一下IP地址的历史演变</p><p><strong>分类寻址</strong></p><p>最初，每个IP地址都被分为了<strong>网络号</strong>和<strong>主机号</strong>两个部分，网络号用于标识接口使用的IP地址在哪个网络中可以被发现, 主机号则指明了网络中的某个主机，最开始，IP地址被划分为5大类</p><p><img src="3.png" alt="3"></p><p>其中， A, B, C类均用于单播地址</p><ul><li><p>地址划分表</p><p><img src="4.png" alt="4"></p></li></ul><p><strong>子网寻址</strong></p><p>随着局域网LAN的发展，IP地址开始出现一个问题，那就是很难为新接入Internet的网络分配一个网络号，因为网络号太少了，后来，人们使用子网寻址解决了这个问题</p><ul><li><p>基本思想</p><p>在一个站点(拥有网络号)内部划分更多子网，由站点管理员进行统一管理</p></li><li><p>实现</p><p>站点可以将原理IP地址中的主机部分进行细分，分成一个<strong>子网</strong>字段以及<strong>主机</strong>字段</p><p><img src="5.png" alt="5"></p><p>当外来站点需要访问该站点时，所有的流量将会经过边界路由器，边界路由器再将这些流量分配到不同的子网</p><p><img src="6.png" alt="6"></p><blockquote><p>注: 对于外部站点而言，子网是透明的，其根本不知道子网的存在, 只有划分子网的主机和路由器直到子网的结构</p></blockquote></li></ul><p><strong>子网掩码</strong></p><p>边界路由器通过<strong>子网掩码</strong>来将流量分配到他们对应的子网当中, 子网掩码的位数与IP地址位数相同，也有着一些简写方法</p><p><img src="7.png" alt="7"></p><ul><li><p>确定一个IP地址所属子网的过程</p><p>该过程非常简单，只需要将IP地址与子网掩码进行与运算即可</p><p><img src="8.png" alt="8"></p><p>在该例子当中，128.32.1.14属于子网128.32.1/24 , 其中128.32.1是表示子网， /24表示掩码的长度为24bit , 而掩码的长度同时也就是子网的网络号的长度</p></li></ul><p><strong>可变长度子网掩码(VLSM)</strong></p><p>在上面的例子当中，子网掩码只有一个，所以划分出的子网的数目固定，每个子网中的主机数目也是固定的</p><p>但有时，需要更加精细化的操控某个子网中的主机数目，因此，出现了<strong>可变长度子网掩码(VLSM)</strong>, 这样可用于不同的子网容纳不同数量的</p><p>主机</p><p><img src="9.png" alt="9"></p><p><strong>广播地址</strong></p><p>在IPV4地址中，有一个特殊地址被用作<strong>子网广播地址</strong>，子网广播地址的主机字段全为1</p><p><img src="10.png" alt="10"></p><ul><li><p>定向广播</p><p>当一个广播数据报通过Internet到达了目标子网，会将其内容发送给所有当前子网的主机</p><blockquote><p>该技术很容易被恶意利用来进行网络攻击，因此被禁止使用</p></blockquote></li><li><p>本地网络广播</p><p>特殊用途地址<code>255.255.255.255</code>被保留为<strong>本地广播地址</strong>，它不会被路由器转发，而是会将其内容发送给当前子网中的其他所有主机</p></li></ul><blockquote><p>IPV6中没有广播地址，只有组播地址</p></blockquote><h4 id="3-CIDR"><a href="#3-CIDR" class="headerlink" title="3. CIDR"></a>3. CIDR</h4><ul><li><p>为了帮助缓解IPV4地址的压力，人们开始使用<strong>无类域间路由（Classless Inter-Domain Routing，CIDR）</strong>, 该技术基于VLSM, 它不区分 A 类、B 类、C 类地址，而是使用CIDR前缀(CIDR掩码)的值指定地址中作为网络ID的位数</p></li><li><p>之前所看过的128.32.2.128/25其实就是CIDR表示法，/25表示网络号的位数是25</p></li><li><p>CIDR还是用了一种被称为<strong>路由聚合</strong>的技术，该技术可以有效减少路由表中的条目</p></li><li><p>因此, CIDR技术如今正被广泛使用</p></li></ul><h4 id="4-公有IP与私有IP"><a href="#4-公有IP与私有IP" class="headerlink" title="4. 公有IP与私有IP"></a>4. 公有IP与私有IP</h4><p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址</p><p><img src="11.png" alt="11"></p><p><strong>私有IP</strong></p><p>平时使用的IP地址，基本上都是私有IP, 即该IP地址只在组织内部有效，不同组织的私有IP地址甚至可以重复</p><p>私有IP由组织内部的人员管理</p><p><strong>公有IP</strong></p><p>公有IP地址是由统一的机构分配的，并且公有IP地址在全世界范围内唯一</p><p>公有IP由<strong>ICANN</strong>进行管理，中⽂叫「互联⽹名称与数字地址分配 机构」，<strong>IANA</strong> 是 ICANN 的其中⼀个机构，它负责分配互联⽹ IP 地址，是按州的⽅式层层分配</p><p><img src="12.png" alt="12"></p><p>其中，在中国是由 <strong>CNNIC</strong> 的机构进⾏管理，它是中国国内唯⼀指定的全局 IP 地址管理的组织</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP保活机制</title>
    <link href="/2022/03/14/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/03/14/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>TCP协议当中，没有其它网络协议中的轮询机制，如果TCP连接双方都不向对方发送数据，那么TCP连接的两端就不会有任何数据交换</p><p>这意味客户端进程可以与服务器建立连接之后，离开几天，几个星期，连接依旧存在</p><blockquote><p>然而实际上在大多数应用层协议当中会建立超时计时器，中间的路由器也不会持久保存连接状态，所以上面的情况一般不会发生</p></blockquote><p>TCP保活机制用于解决上面的问题，关于保活机制有一些注意点：</p><ul><li>保活机制不是TCP规范中的一部分，然而大多数实现当中都提供了保活机制</li><li>保活机制是一个可选的功能，他可能会导致一个正常的连接由于中间路由器的短暂断开而导致连接终止</li><li>保活功能一般是为服务器提供的，服务器希望直到客户端进程是否已经结束，以避免为他们绑定不必要的资源</li><li>那些实现长时间交互服务的服务器可能不希望使用保活功能，如ssh</li></ul><h4 id="2-细节"><a href="#2-细节" class="headerlink" title="2. 细节"></a>2. 细节</h4><p>保活功能在默认情况下是关闭的，连接双方可以选择性的打开</p><ul><li><p>机制</p><ul><li>建立TCP连接后，如果在<strong>保活时间(keepalive time)<strong>内连接处于非活动状态，那么启用了保活功能的一方就可以向接收方发送一个</strong>保活探测报文</strong></li><li>如果发送方没有收到对应的响应报文，那么在**保活时间间隔(keepalive interval)**之后，发送方会再次发送保活探测报文</li><li>如果保活探测报文的发送次数到达了**保活探测数(keepalive probe)**， 这是对方主机将被确认为不可到达，连接终止</li></ul></li><li><p>保活探测报文</p><p>保活探测报文是一个空或者只包含一个字节的报文段，其Seq字段为接收到的最大ACK - 1, 即是一个<strong>垃圾数据</strong></p></li></ul><ul><li><p>接收方状态</p><p>接受方可能处于以下4中状态之一:</p><ul><li><p>仍在工作，报文可以正常到达</p><p>此时接收方将返回一个<strong>保活响应报文</strong>，发送方将<strong>保活计时器</strong>重置</p><p>每当连接有数据传输时，保活计时器的值都会被重置</p></li><li><p>已经崩溃，报文无法到达</p><p>此时发送方会持续发送保活探测报文，当发送保活探测数数量的报文时，就会停止发送，断开连接</p></li><li><p>崩溃后重启</p><p>此时接收方会丢弃关于之前的TCP连接的所以记录，所以无法识别发送方发过来的报文，接收方发送RST报文段作为响应</p></li><li><p>仍在工作，但是响应报文无法到达请求段</p><p>由于网络延迟，可能会发生这种情况，但是发送端无法识别该情况与状态2的区别，因此和状态2一样的进行处理</p></li></ul></li><li><p>Linux的相关变量</p><ul><li>/proc/sys/net/ipv4/tcp_keepaliver_time: 保活时间, 默认是7200秒</li><li>/proc/sys/net/ipv4/tcp_keepalive_interval: 保活时间间隔，默认是75秒</li><li>/proc/sys/net/ipv4/tcp_keepalive_proves: 保护探测数，默认是9次</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP拥塞控制</title>
    <link href="/2022/03/12/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/03/12/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<ul><li><p>介绍</p><p>TCP采取了拥塞控制算法来防止网络因为大规模的通信负载而瘫痪，基本方法就是当认为网络已经或者即将陷入拥塞状态时减缓TCP发送速率或者是丢弃一部分数据</p><p>当路由器无法处理高速到达的流量而被迫丢弃数据信息的现象称为<strong>拥塞</strong></p></li></ul><h4 id="1-TCP拥塞检测"><a href="#1-TCP拥塞检测" class="headerlink" title="1. TCP拥塞检测"></a>1. TCP拥塞检测</h4><p>当网络处于拥塞状态时，共用一条网络传输路径的多个TCP连接需要重传更多的数据报，这好比火上浇油</p><p>对于TCP而言，没有一个明确的信号告诉它网络发生了拥塞，<strong>丢包</strong>常常被用作判断拥塞发生的指标</p><ul><li><p>拥塞窗口</p><p>TCP引入了一个叫做<strong>拥塞窗口</strong>的变量<code>cwnd</code>来调节发送速率, 发送端实际可用的窗口<code>W=min(awnd, cwnd)</code>, awnd是接收端发过来的通知窗口</p><blockquote><p>当不使用SACK时，W的限制作用体现为发送端发送的报文段序列不能大于ACK号的最大值和W之和</p><p>当使用SACK时，W被用来限制在外数据量，即那些已经发送但是还没有收到ACK的数据</p></blockquote><p>变量<code>W</code>, <code>cwnd</code>, <code>awnd</code>的值都要根据经验设定并动态调节, 通常希望W的值接近<strong>带宽延时积(Bandwidth-Delay Product, BDP)</strong>, 这也被称作<strong>最佳窗口大小</strong>, 其值为<code>RTT X 通信链路上的瓶颈速率</code></p></li></ul><h4 id="2-经典算法"><a href="#2-经典算法" class="headerlink" title="2. 经典算法"></a>2. 经典算法</h4><p>当TCP连接建立之初，TCP通过与接收方交换一个报文段就能够获取awnd的值，而获取cwnd的唯一方法就是以越来越快的速率来不断发送数据，直到发生丢包</p><ul><li><p>数据包守恒和ACK时钟原理</p><p>稳定状态下的TCP拥塞行为，其实是视图使在网络传输路径上的数据包守恒</p><p><img src="1.png" alt="1"></p><p>上面的通道是数据包通道，下面的通道是ACK通道，数据包的发送速率会根据ACK的到达速率而调整</p></li></ul><h5 id="1-慢启动算法"><a href="#1-慢启动算法" class="headerlink" title="1.慢启动算法"></a>1.慢启动算法</h5><ul><li><p>触发条件</p><p>新建立TCP连接或者发生超时重传时</p></li><li><p>目的</p><p>在传输开始阶段，由于对于当前网络的拥塞情况位置，如果直接注入大量数据可能会导致拥塞，所以需要缓慢探测可以用传输资源</p></li><li><p>规则</p><p>慢启动的规则很简单: <strong>发送方每收到一个好的ACK, cwnd窗口就会加1</strong>，从效果上看，cwnd呈<strong>指数级增长</strong></p><blockquote><p>好的ACK:</p><p>ACK号大于之前收到的ACK号</p></blockquote><p><img src="2.png" alt="2"></p><p>cwnd的初始大小可能是一个或几个数据包(k * SMSS)， 被称为<strong>初始窗口IW(Initial Window)</strong></p><blockquote><p>SMSS为接收方发送的MSS选项和MTU(最大传输单元)的较小者</p></blockquote><ul><li><p>停止</p><p>慢启动会一直持续直到cwnd到达一个阙值为止，该值被称作<strong>慢启动阙值(slow start threshold, ssthresh)</strong></p><ul><li>当cwnd &lt; ssthresh时，使用慢启动算法</li><li>当cwnd &gt; ssthresh时，使用拥塞避免算法</li></ul></li></ul></li></ul><h5 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2. 拥塞避免算法"></a>2. 拥塞避免算法</h5><ul><li><p>触发条件</p><p>拥塞窗口cwnd &gt; ssthresh 时</p></li><li><p>目的</p><p>当cwnd 到达阙值后，意味着继续增长cwnd可能就会导致网络拥塞， 此时需要减缓cwnd的增长</p></li><li><p>规则</p><p>在该阶段中，cwnd的计算公式如下:</p><p><img src="3.png" alt="3"></p><p>如果$cwnd_t$为$k * SMSS$, 那么$cwnd_t$就为$(k + 1/k) * SMSS$, 是一种<strong>线性增长</strong>, 增长速率取决于k </p><p><img src="4.png" alt="4"> </p></li></ul><ul><li><p>重传时sshthresh以及cwnd的确定</p><p>拥塞避免算法假设由于比特错误而导致的丢包概率很小(小于1%), 因此在该算法当中<strong>丢包(重传) == 拥塞</strong></p><p>重传分为快速重传和超时重传两种, 当发生重传时, ssthresh和 cwnd的值都会发生响应改变</p><ul><li><p>ssthresh</p><p>在两种重传模式下， ssthresh的值都是以相同的模式改变</p><p>慢启动阙值的初始值可以随意设置，因为不清楚网络的拥塞情况，当发生重传时, ssthresh的值就会按照如下公式改变</p></li></ul><p><img src="5.png" alt="5"></p><p>   <strong>解释</strong></p><pre><code>    `在外数据值/2`代表着上一次的发送窗口大小</code></pre><p>​        <code>2 * SMSS</code>则限定了拥塞窗口的大小</p><p>通常情况下ssthresh的值会被减半，即ssthresh = sshtresh / 2</p><ul><li><p>cwnd</p><ul><li><p>超时重传</p><p>cwnd = 1 SMSS</p></li><li><p>快速重传</p><p>cwnd = cwnd / 2</p></li></ul></li></ul></li></ul><h5 id="3-快速恢复算法"><a href="#3-快速恢复算法" class="headerlink" title="3. 快速恢复算法"></a>3. 快速恢复算法</h5><ul><li><p>触发条件</p><p>发生快速重传时，与慢启动算法触发条件有所差异</p></li></ul><p>首先看一下慢启动算法</p><p><img src="6.png" alt="6"></p><blockquote><p>慢启动算法会直接将cwnd降到1，对于有较大BDP的链路来说，会使得带宽利用率低下</p></blockquote><ul><li><p>快速恢复算法规则</p><p>快速重传会受到3个ACK, TCP认为网络没有那么糟糕， 所以没有必要像超时重传那样激烈</p><ul><li><p>ssthresh 与 cwnd</p><p>经过前面的说明，当触发快速重传时:</p><p> <img src="7.png" alt="7"></p><p>一般情况下就是:</p><ul><li><p>cwnd = cwnd / 2</p></li><li><p>ssthresh = cwnd</p></li></ul></li></ul><p>之后，会正式进入快速恢复算法, 会执行以下行为</p><ul><li>拥塞窗⼝ cwnd = ssthresh + 3 (3 的意思是确认有 3个发送的数据报被收到了）</li><li>重传丢失的数据报 (这是快速重传的行为)</li><li>每接收到一个冗余ACK,  就将cwnd的值<strong>暂时</strong>增加1 SMSS</li><li>当接收到一个好的ACK, 算法结束, 将cwnd重设为ssthresh, <strong>进入拥塞避免状态</strong></li></ul><p><img src="8.png" alt="8"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP数据流与窗口管理</title>
    <link href="/2022/03/10/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <url>/2022/03/10/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1-交互式通信"><a href="#1-交互式通信" class="headerlink" title="1. 交互式通信"></a>1. 交互式通信</h4><ul><li><p>交互式TCP连接</p><p><strong>交互式TCP连接</strong>指的是该连接需要在客户和服务器之间传输用户输入信息，如按键操作，短消息或者是鼠标操作，这些操作会产生<strong>交互式数据</strong>, 一般都是一些比较小的报文段</p></li><li><p>例: ssh</p><p><strong>ssh(Secure Shell, 安全外壳协议)</strong>, 是一种安全的远程登录协议, 会在数据传输之前将用户输入的信息进行加密</p><p>ssh会在远程系统上调用一个shell, 对用户的输入字符做出回显, <strong>用户每按下一个按键都会生成一个单独的数据包</strong></p><ul><li><p>数据报交互图</p><p><img src="1.png" alt="1"></p></li></ul><p>通常，第二三段可以被合并，这是接下来会说明的延时ACK技术</p><ul><li><p>延时ACK数据包交互</p><p><img src="2.png" alt="2"></p></li></ul></li></ul><h4 id="2-延时ACK"><a href="#2-延时ACK" class="headerlink" title="2. 延时ACK"></a>2. 延时ACK</h4><p>一般情况下，当接收方收到某个报文段时，并不会立即对发送端返回ACK, 而是会延时一段时间，以便将ACK和相同方向上需要传输的数据结合发送,   这被称作<strong>捎带延时确认</strong></p><blockquote><p>延时时间通常是200ms</p></blockquote><ul><li><p>优势</p><p>使用延时ACK可以减少网络中的报文数目，一定程度上可以减轻网络负载</p></li></ul><blockquote><p>LInux采用了一种动态调节算法，可以在”立即返回ACK”与”延时返回ACK”两种模式之间切换</p></blockquote><h4 id="3-Nagle算法"><a href="#3-Nagle算法" class="headerlink" title="3. Nagle算法"></a>3. Nagle算法</h4><p>在之前谈过的ssh协议中，每次按下一个按键就会发送一个数据包，下面分析以下该数据包的组成:</p><ul><li>IP报文头: 20字节</li><li>TCP头: 20字节</li><li>数据: 48字节</li></ul><p>可以看到，数据部分占比几乎只有一半，大量这些微型数据包会造成相当高的网络传输代价, <strong>Nagle</strong>算法提出了一种解决方案</p><p><strong>算法思想</strong></p><p>Nagle算法要求:</p><ul><li>当一个TCP连接中有<strong>已发送但未收到ACK</strong>的数据时，那些微型数据包(小于SMSS, Sender MSS)就不能够被发送, 直到所有的在传数据都收到ACK</li><li>当所有在数据收到ACK之后，TCP需要整合这些小的数据包，将其整合到一个报文段中发送</li></ul><p>该算法也被称为<strong>stop-and-wait</strong>规则， 特点是在任意时刻只有一个方向保持传输状态</p><p><img src="3.png" alt="3"></p><p><strong>优点</strong></p><ul><li>实现了<strong>self-clocking</strong>: ACK返回的越快，数据传输地也就越快</li><li>使得单位时间内发送的报文段的数目更少</li></ul><p><strong>缺点</strong></p><ul><li>单个包的传输时延增加了</li></ul><p><strong>延时ACK与Nagle算法</strong></p><ul><li><p>图例</p><p><img src="4.png" alt="4"></p></li></ul><p>由于服务器端在接收到ACK之前不能发送响应数据报，而ACK延时机制又会持续等待，因此会形成一个暂时的<strong>死锁</strong></p><p>因此，这两种机制在一起效果会很差，ssh默认禁止了Nagle算法</p><h4 id="4-流量控制与窗口管理"><a href="#4-流量控制与窗口管理" class="headerlink" title="4. 流量控制与窗口管理"></a>4. 流量控制与窗口管理</h4><p>每个TCP报文段当中都包含<strong>窗口大小</strong>字段，该字段表明<strong>发送该窗口信息的通信方为即将到来的新数据项预留的存储空间</strong>，当接收方可用的存储空间不足时，就会减小该字段</p><ul><li><p>滑动窗口</p><p>TCP连接的每一端的收发数据量是通过一组窗口结构来维护的，分为<strong>发送窗口</strong>以及<strong>接收窗口</strong>，窗口结构以字节为单位</p><ul><li><p>发送窗口(提供窗口)</p><p>发送窗口如图所示</p><p><img src="5.png" alt="5"></p><p>发送窗口包含3个变量</p><ul><li>SND.UNA: 左边界， 位于左边界的数据均已经发送并收到ACK</li><li>SND.NXT:可用窗口的开始位置</li><li>SND.WND: 发送窗口的大小</li></ul><p>使用三个术语来描述窗口边界的运动:</p><ul><li>关闭(close): 窗口左边界右移，当已发送数据接收到ACK时会触发</li><li>打开(open): 窗口右边界右移, 当接收到的ACK中的窗口大小字段变大时触发</li><li>收缩(shrink): 窗口右边界左移</li></ul><p>注：左边界不可能左移，因为ACK号是累计的</p></li><li><p>接受窗口</p><p>接收方的窗口更加简单</p><p><img src="6.png" alt="6"></p><ul><li>RCV.NXT: 左边界，左边的数据均已经接收并发送ACK</li><li>RCV.WND: 窗口大小, 当接受端接收到窗口内部数据时，会将其保存</li></ul><p>对于接收端来说，当接收到位于窗口之外的数据时会直接丢弃，而接收到窗口内部的数据时会保存，</p><p>仅当接收到窗口最左边的字节时窗口会发生滑动，而当打开<code>SACK</code>选项之后，窗口内的其他乱序数据也会被接受</p></li></ul></li></ul><h4 id="5-零窗口与TCP持续计时器"><a href="#5-零窗口与TCP持续计时器" class="headerlink" title="5. 零窗口与TCP持续计时器"></a>5. 零窗口与TCP持续计时器</h4><ul><li><p>零窗口</p><p>当接收端给发送方发送的报文段中的窗口大小字段为0时，发送方便会停止发送报文段，直到其接收到接收端发送的</p><p><strong>窗口更新</strong>报文段为止</p></li><li><p>窗口更新</p><p>窗口更新报文段是一个不包含数据的纯ACK(只有ACK标志位被置位), 用于通告发送端可以继续发送数据，纯ACK不会被重传, TCP必须采取相应措施来处理这些丢包</p></li><li><p>持续计时器</p><p>如果一个包含窗口更新的ACK丢失，通信双方就会一直处于等待状态：</p><ul><li>接受方等待接受来自发送方的数据</li><li>发送方等待来自接收方的窗口更新</li></ul><p>此时就会导致一个死锁，TCP使用了持续计时器来解决死锁问题:</p><ul><li><p>窗口探测</p><p>发送端会使用一个<strong>持续计时器</strong>，每当持续计时器超时，就会向接收端发送**窗口探测(window probe)**报文段</p><p><strong>强制要求接收端返回ACK</strong>, 该计时器也采取了<strong>指数退避</strong>方法</p><p>窗口探测报文段包含一个字节数据，因此可以被重传，避免了死锁</p></li></ul></li></ul><p><strong>糊涂窗口综合征</strong></p><ul><li><p>概念</p><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。，</p><p>到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节， 这就是<strong>糊涂窗⼝综合症(Silly Window Syndrome, SWS)</strong></p><p>简而言之就是<strong>发送方和接收方一直在传输小报文段</strong></p></li><li><p>解决方案</p><p>糊涂窗口综合征的原因就在于发送方和接收方传输的数据太小，因此只要组织他们发送小数据报即可</p><ul><li><p>接收端</p><p>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通 告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来</p></li><li><p>发送端</p><p>思路是采用Nagle算法，将小报文段整合成大报文段，仅当发送报文段满足以下条件之一时才能发送</p><ul><li><p>报文段大小为全长(MSS)</p></li><li><p>纯数据段的长度 &gt;= 接收端通告过的最大窗口值一半</p><p>这需要发送方不断记录并更新接收到的最大窗口大小值</p></li><li><p>接收到错误ACK</p></li><li><p>连接禁用Nagle算法</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP超时与重传</title>
    <link href="/2022/03/09/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/"/>
    <url>/2022/03/09/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>TCP协议提供可靠数据传输服务，为了保证数据的正确性，发送端会重传它认为已经丢失的包</p><p>TCP协议当中，总共有4种重传方式：<strong>超时重传</strong>,<strong>快速重传</strong>，<strong>SACK</strong>,<strong>D-SACK</strong></p><h4 id="1-超时重传"><a href="#1-超时重传" class="headerlink" title="1. 超时重传"></a>1. 超时重传</h4><p>TCP在<strong>包含数据(SYN或FIN被置位)<strong>的报文段被发出的时候会设置一个</strong>计时器(timer)</strong>, 如果计时器直到超时都没有收到该报文段的ACK, 那么就会触发超时重传机制</p><p><strong>一些变量</strong></p><p>RFC[1122]规定了一些关于超时重传的变量</p><ul><li><p>R1</p><p>R1表示TCP在向IP层传递<strong>消极建议</strong>(如重新判断当前的IP路径)时，至少需要重传的次数</p><p>Linux当中，该值记录在<code>/proc/sys/net/ipv4/tcp_retries1</code>下，默认是3次</p></li><li><p>R2</p><p>R2表示当重传多少次时，TCP应该放弃当前的连接</p><p>Linux当中，该值记录在<code>/proc/sys/net/ipv4/tcp_retries2</code>下，默认是15次</p></li></ul><p>上面的变量都与携带数据的报文段相关，而SYN报文段则与另外一些文件有关</p><ul><li><code>/proc/sys/net/ipv4/tcp_syn_retries</code>：重传SYN报文段的最大次数</li><li><code>/proc/sys/net/ipv4/tcp_synack_retries</code>: 重传[SYN ACK]报文段的最大次数</li></ul><p><strong>RTO</strong></p><p>先来介绍一下一些术语:</p><ul><li><p><strong>RTO</strong>: (Retransmission Timeout, 重传超时时间)</p><p>计数器的超时时间会被设为该值</p></li><li><p><strong>SRTT</strong>:(smoothed RTT, 平滑的RTT)</p><p>用于估计RTT</p></li><li><p><strong>DevRTT</strong>:(平滑的RTT与 最新 RTT 的差值)</p></li></ul><p>超时重传中最关键的部分便在于RTO的求解</p><ul><li>当RTO远大于RTT时，连接的吞吐量会大幅下降</li><li>当RTO小于RTT时，会在网络中引入不必要的重复数据</li></ul><p>因此，<strong>RTO应该略大于RTT</strong>, RTT则与网络当前拥塞状况有关，因此是一个即时量</p><blockquote><p>RTO求解的标准方法记录在RFC[6298]当中</p></blockquote><ul><li><p>标准RTO求解</p><p><img src="1.png" alt="1"></p></li></ul><p>在Linux当中，这些系数为: <strong>α = 0.125，β = 0.25， μ = 1，∂ = 4</strong>,是模拟后得出的结果</p><p><strong>重传二义性与Karn算法</strong></p><ul><li><p>重传二义性</p><p>假设一个数据报的传输超时，那么该数据报会被重传，可如果接下来收到一个ACK, 那么<strong>无法确定该ACK是第一次还是第二次传输的响应</strong>,  这就是<strong>重传二义性</strong></p></li><li><p>二进制指数退避</p><p>在TCP计算RTO时，会采取一个<strong>退避系数(backoff factor)</strong>,  初始时该值为1， <strong>后面每当重传计时器超时时，该系数就会加倍</strong></p><p>设初始RTO为<code>R</code>, 当前退避系数为<code>k</code>, 那么当前计时器的超时时间R会被更新为**R * k **</p><p>如果计时器收到了对应的ACK, 且<strong>该ACK不具有重传二义性</strong>，那么<code>k</code>就会被重置为1</p></li><li><p>Karn算法</p><p>Karn算法就是基于上面的理论，且当今的超时重传的标准计算方法就是基于karn算法</p><blockquote><p>当接收到重复传输数据的ACK时，不进行该数据报的RTT测量，以避免重传二义性问题</p><p>之后，对该数据报采取退避策略，仅当接收到未经重传的数据时，该SRTT才用于计算RTO</p></blockquote></li></ul><h4 id="2-快速重传"><a href="#2-快速重传" class="headerlink" title="2. 快速重传"></a>2. 快速重传</h4><p>快速重传基于接收端的反馈来引发重传，而不是重传计时器的超时</p><ul><li><p>重复ACK</p><p>当接收端接收到失序报文段时，TCP需要立即生成ACK, 该ACK应该和上一次发送的ACK一样，被称为<strong>重复ACK</strong></p><p>之所以要立即生成，是因为需要发送端尽早的值失序报文段，并告诉其空缺在哪</p></li><li><p>快速重传</p><p>TCP发送端在接收到至少**dupthresh(ACK阙值)**个重复ACK之后，即重传可能丢失的数据分组，而不必等到重传计时器超时</p></li><li><p>图例</p><p><img src="2.png" alt="2"></p><p>该图中将<code>dupthresh</code>设置为3, 此时第四次接收到重复ACK之后，就会触发快速重传，此时发送端重传可能的丢失分组，这里是Seq2</p><ul><li><p>恢复点</p><p>将发送端在执行重传之前发送的最大序列号称为<strong>恢复点</strong>，上图中是Seq5, 仅当发送方收到大于恢复点的ACK之后，才会从恢复阶段结束，否则持续发送可能丢失的报文段</p></li></ul></li></ul><p><strong>问题</strong></p><p>快速重传有一个没有解决的问题就是，到底应该重传多少个包, 如果没有使用SACK的话，默认应该就是从接收到的ACK号开始向后所有的包(即图中的2—5), 即<strong>回退N步</strong></p><p>这样会造成很多不必要的重复重传</p><h4 id="3-SACK"><a href="#3-SACK" class="headerlink" title="3. SACK"></a>3. SACK</h4><p>在快速重传当中，可能会导致很多不必要的重传，通过使用SACK， 可以进行优化</p><ul><li><p>SACK选项</p><p>SACK是一个TCP报文头的选项，总共包含(8n + 2)个字节</p><ul><li>接收方已经成功接受报文段的序列号范围，是一个数值对{start, end}, 占8n个字节</li><li>选项种类和长度，占2个字节</li></ul><p><img src="3.png" alt="3"></p></li><li><p>SACK允许选项</p><p>当接收方收到SACK允许选项后，就可以生成SACK</p><ul><li><p>SACK只包含2个字节</p><p><img src="4.png" alt="4"></p></li></ul></li></ul><blockquote><p>由于TCP报文头选项部分最多只有40个字节，因此最多只能包含4个数据块，又通常SACK选项会与TSOPT选项(10字节)一同使用</p><p>因此通常一个ACK只会包含3个块</p></blockquote><ul><li><p>SACK接收端行为</p><blockquote><p>注：包含一个或多个SACK块的ACK有时简单称为SACK</p></blockquote><p>当接收端接收到SACK允许选项之后就生成SACK了</p><p>假设SACK中包含3个块，那么其第一个块包含的是<strong>最近接收到</strong>的报文段的序列号范围，第二，三个块是倒数第二，三个接收到的报文段的序列号范围</p><p><strong>注: 这样做意味着不同SACK中的块可能会有重叠，目的是为了进行备份，因为SACK可能会丢失，并且如果其SYN字段没有置位的话</strong></p><p><strong>也不会被重传</strong></p></li><li><p>SACK发送端行为</p><p>发送方根据接收到的SACK以及收到的重复ACK, 可以推断出空缺的范围，因此可以精确的重传那些空缺报文段，这种重传操作也被称为<strong>选择重传</strong></p><ul><li><p>重传缓存</p><p>在发送方中有一个重传缓存，用于缓存那些已经重传的报文段，当其接收到缓存中指定序列范围的普通ACK时，就将重传缓存中的指定报文段标记为重传成功</p><p>注: 发送端同样记录了接收到的SACK信息，不过书上没有指明</p></li><li><p><strong>食言</strong></p><p>RFC[2018]中还记录了接收方的食言特性，即接收方可能会在发送SACK指定某个范围的数据已经接受成功之后，又将这些乱序数据从缓冲区中清空，前提是接收方缓冲区快被耗尽了， 不过不建议这种行为</p><p>食言特性会带来一些影响:</p><ul><li><p>SACK发送端不能够在收到一个SACK之后就将其重传缓存中的数据清空</p><p>只有当收到普通ACK的ACK号大于其最大序列号时才可以</p></li><li><p>重传计时器应该忽略SACK</p></li></ul></li></ul></li></ul><p><img src="5.png" alt="5"></p><h4 id="4-DSACK"><a href="#4-DSACK" class="headerlink" title="4. DSACK"></a>4. DSACK</h4><p>先来介绍一下<strong>伪超时</strong>与<strong>伪重传</strong></p><ul><li><p>伪超时</p><p>过早判定超时，即RTO &lt; RTT</p></li><li><p>伪重传</p><p>由伪超时导致的重传行为</p></li></ul><p><img src="6.png" alt="6"></p><p>伪超时可能会导致快速重传</p><ul><li><p>DSACK</p><p>DASCK(Duplicated SACK, 重复SACK), 这个机制是在 SACK 的基础上，额外携带信息，<strong>告知发送方有哪些数据包自己重复接收了</strong></p><p>书上没有细说，留坑</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP连接管理</title>
    <link href="/2022/03/08/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2022/03/08/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1-TCP连接的建立与终止"><a href="#1-TCP连接的建立与终止" class="headerlink" title="1. TCP连接的建立与终止"></a>1. TCP连接的建立与终止</h4><ul><li><p>简介</p><ul><li><p>一个TCP连接由一个四元组**&lt;源IP, 源端口, 目的IP, 目的端口&gt;**组成，通信的每一端都由一个套接字，即&lt;IP, 端口&gt;对所唯一标识</p></li><li><p>一个TCP连接分为三个过程:  启动， 数据传输，退出</p><p>启动阶段负责建立连接，退出阶段负责断开连接</p></li></ul></li><li><p>TCP表头</p><p><img src="1.png" alt="1"></p></li><li><p>TCP连接图</p><p><img src="2.png" alt="2"></p><ul><li><p>三次握手</p><p>TCP启动过程需要三次报文段的传递，因此也被形象的称为三次握手</p><blockquote><p>下面所说的SYN, ACK,FIN报文指的是TCP报文头部的SYN, ACK,FIN字段被置为1</p></blockquote><ul><li><p>第一次</p><p>客户端发送一个SYN报文段，指明自己想要连接的端口号以及自己的Seq字段，此时的Seq字段值为ISN(c)</p></li><li><p>第二次</p><p>服务器发送[SYN, ACK]报文段作为响应，ACK字段被置为<code>ISN(c) + 1</code>表明自己接下来想要接受的Seq号</p><p>同时指明自己的Seq字段, 称为ISN(s)</p></li><li><p>第三次</p><p>客户端对服务器的SYN报文段做出响应, 返回ACK报文段， ACK字段被置为<code>ISN(s) + 1</code></p></li></ul><p>服务器端收到最后的ACK报文段之后，TCP连接建立成功</p></li><li><p>数据传输</p><p>客户于服务器使用write(), read()等操作进行数据传输</p></li><li><p>四次挥手</p><p>TCP退出过程需要四次报文段的传递，因此也被称为四次挥手</p><ul><li><p>第一次</p><p>主动关闭者(通常是客户端)发送一个[FIN, ACK]报文段指明序列号K,  同时其ACK字段L用来确认最近一次接收到的数据</p></li><li><p>第二次</p><p>被动关闭者(通常是客户端)发送一个ACK报文段表明自己接收到了[FIN, ACK]报文段, Seq字段为L, ACK字段为K + 1</p></li><li><p>第三次</p><p>被动关闭者的身份转变，变为主动关闭者，发送[FIN, ACK]报文段给原来的主动关闭者, Seq与ACK字段都与上一次一样</p></li><li><p>第四次</p><p>原主动关闭者发送ACK报文段表示自己收到了[FIN, ACK]报文段</p></li></ul><p>最后的ACK报文段被接受之后，TCP连接结束</p><blockquote><p>FIN报文常常与套接字的close()操作相关联， 当某一段执行close()操作时，就会发送FIN报文段给另一方</p><p>同时还会在发送数据自己流的末尾加上EOF文件结束符</p></blockquote></li></ul></li><li><p>TCP半关闭</p><p>TCP的<strong>半关闭</strong>操作指的是仅关闭数据流的一个传输方向，如仅关闭发送方向的数据，但仍然可以接受数据</p><p>这种操作很少见但也是TCP协议的一部分，通过调用<code>shutdown()</code>函数来代替<code>close()</code>函数就能够做到TCP半关闭操作</p><ul><li><p>TCP半关闭图</p><p><img src="3.png" alt="3"></p><p>可以看到，TCP连接的完全关闭可以由客户端与服务器双方的两个半关闭操作来完成， 此时发送FIN报文段并得到接受之后数据仍然是可以单向流通的</p></li></ul><blockquote><ul><li><p>TCP半开连接</p><p>TCP半开连接与TCP半关闭听起来感觉是一回事，但是其实完全不同</p><ul><li><p>概念</p><p>在TCP连接过程中, 如果一方在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于<strong>半开状态</strong></p><p>当通信的一方主机崩溃时，就会发生该情况，此时另一方将不会检测出另一端已经崩溃</p></li><li><p>举例</p><p>在CS模式当中，半开连接分为两种情况</p><ol><li><p>服务器崩溃</p><p>如果服务器崩溃，那么在服务器重启之后，它将会丢失关于之前的TCP连接的所有记忆，此时如果客户端发送一个数据报，服务器端将会返回一个RST报文段作为响应</p></li><li><p>客户端崩溃</p><p>如果客户端崩溃，而服务器端又正在等待来自客户端的数据，那么服务器端可能就会一直保持这个连接</p><p>此时需要<strong>保活机制</strong>来关闭该链接</p></li></ol></li></ul></li></ul></blockquote></li><li><p>同时打开与关闭</p><ul><li><p>同时打开</p><p>在极少见的情况下，会发生两个主机之间同时<strong>在一对套接字</strong>上主动打开TCP连接，这种情况被称为<strong>同时打开</strong></p><p>同时打开时的报文的发送与普通的报文发送略有不同，会多出一个报文</p><p><img src="4.png" alt="4"></p><p>当双方都收到ACK报文段之后，数据就可以正常传输了</p></li><li><p>同时关闭</p><p>同时关闭的情况则比较简单，只是TCP报文段的顺序发生了交叉而已</p><p><img src="5.png" alt="5"></p></li></ul></li><li><p>ISN</p><p>TCP报文头中的序列号用于解决报文段乱序抵达导致的混乱问题</p><blockquote><p>假设一个连接在关闭之后，网络中的报文段还没有完全消失，此后连接重新启动，网络中旧的报文段可能会被接收端所接收</p></blockquote><ul><li>需求</li></ul><ol><li>为了防止同一个连接先后的不同实例产生上面的问题，需要避免实例之间的序列号产生重叠</li><li>一些恶意用户可以伪造TCP报文段，他们只需要选取合适的序列号，IP地址以及端口号即可</li></ol><ul><li>ISN,  即初始序列号(<strong>I</strong>nitial <strong>S</strong>equence <strong>N</strong>umber, ISN), 通常是一个与时间有关的数字，用于保证同对套接字每一个连接都有不同的初始序列号</li></ul><p>选择一个合适的ISN可以用来解决上面的问题，现代的系统通常采用半随机的方式来创建ISN</p><blockquote><p>Linux 采用一个相对复杂的过程来选择 ISN。它采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量</p><p>随机偏移量是在连接标识（即连接四元组：<code>&lt;ClientIP,ClientPort,ServerIP,ServerPort&gt;</code>）的基础上利用加密散列函数得到的</p><p>散列函数的输入每 5 分钟就会改变 1 次</p></blockquote></li></ul><h4 id="2-TCP的状态转换"><a href="#2-TCP的状态转换" class="headerlink" title="2. TCP的状态转换"></a>2. TCP的状态转换</h4><p>TCP为一个连接建立了11种状态, 并且定义了状态转换之间的规则</p><ul><li><p>TCP状态转换图</p><p><img src="6.png" alt="6"></p><blockquote><p>从LISTEN状态到SYS_SENT状态也是合法的，但是Berkely套接字却并没有实现，因此没有画出</p></blockquote><ul><li><p>客户服务器状态转换</p><p><img src="7.png" alt="7"></p></li></ul></li></ul><p>下面详细介绍一下<code>TIME_WAIT</code>状态</p><ul><li><p>TIME_WAIT</p><p>TIME_WAIT状态，也被称为<strong>2MSL状态</strong>，因为处于该状态的套接字需要处于这个状态至少2MSL的时间, 在这个时间段内，不能够使用原来的套接字对重新建立连接</p><blockquote><p>有些实现更加严格，规定如果一个端口号被处于TIME_WAIT状态的通信所使用，那么该端口号将在2MSL的时间内无法使用</p><p>可以使用SO_REUSEADDR套接字选项来绕开这一限制</p></blockquote><ul><li><p>MSL</p><p>MSL(Maximun Segment Lifetime, MSL)， 最大段生存期，是任何IP数据报能够在因特网上的存活的最长时间</p><p>Linux上可以修改:<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>文件来修改这个时间，通常是60s</p></li></ul><p><strong>TIME_WAIT状态为什么是2MSL的理由</strong></p><ul><li><p>可靠地实现TCP全双工连接的终止</p><p>假设主动关闭方发送的最后一个ACK丢失了，那么服务器将重新发送FIN,  从主动关闭方发送ACK到其接收到新的FIN的最长时间就是2MSL </p></li><li><p>允许老的分重复分组在网络中消逝</p><p>TCP必须防止来自某个连接的老的重复分组在该连接终止而又重启之后再次到达服务器的情况, 假设发送方在进入TIME_WAIT状态前发送了一条报文段A，然后关闭，接收方接收后响应了一条新的报文段B给发送方，那么在服务器重启时， 2MSL的时间内A,B都会消失</p></li></ul></li></ul><h4 id="3-连接队列"><a href="#3-连接队列" class="headerlink" title="3. 连接队列"></a>3. 连接队列</h4><p>Linux为任何处于监听状态下的套接字维护两个队列:</p><ul><li><strong>未完成连接队列（incomplete connection queue）</strong>：即处于 SYN_RCVD 状态，可由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 进行控制（默认为 1000）</li><li><strong>已完成连接队列（completed connection queue）</strong>：已经完成三次握手，等待应用层的接受，即处于 ESTABLISHED 状态，可通过 <code>/proc/sys/net/core/somaxconn</code> 和 <code>listen()</code> 控制（默认为 128）</li></ul><p>队列条目的变化随着connect()函数的调用以及返回发生变化</p><p><img src="8.png" alt="8"></p><p>可以看出，当来自 Client 的 SYN 到达时，TCP 在未完成队列中创建一个新项，然后响应三次握手的第二个报文</p><p>这一项一直保留在未完成连接队列中，直到三次握手成功或者该项超时为止</p><p>如果三次握手正常完成，该项就从未完成连接队列中移到已完成连接队列的队尾</p><p>当进程调用 <code>accept()</code> 时，已完成连接队列中的队头项将返回给进程，如果队列未空，进程继续投入睡眠</p><h4 id="4-SYN泛洪"><a href="#4-SYN泛洪" class="headerlink" title="4. SYN泛洪"></a>4. SYN泛洪</h4><p><a href="https://zhuanlan.zhihu.com/p/377002085">https://zhuanlan.zhihu.com/p/377002085</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[TCP/IP详解]:TCP初步</title>
    <link href="/2022/03/07/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E5%88%9D%E6%AD%A5/"/>
    <url>/2022/03/07/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>一、概念介绍</p><h4 id="1-ARQ与重传"><a href="#1-ARQ与重传" class="headerlink" title="1. ARQ与重传"></a>1. ARQ与重传</h4><ul><li><p>ARQ</p><p><strong>自动重复请求(automatic repeat request, ARQ)</strong>, 是一种错误纠正机制，简单的说就是自动重传，TCP就使用了这种机制</p></li><li><p>ACK</p><p>考虑在互联网上分组丢失的情况, 最直接的方法就是使用ARQ，重新传递分组</p><p>通常,  接收方在接收到发送方发送过来的分组后，会向原发送方发送一个**ACK(acknowledge)**分组，用于确认自己已经接受到了一个分组</p><p>有关ACK会引出一系列问题 :</p><ol><li><p>发送方对于一个ACK应该等待多长时间</p><p>难以判断</p></li><li><p>如果ACK丢失了怎么办</p><p>对于发送方而言，ACK丢失与原分组丢失这两种错误是无法区分的，所以发送方的基本操作就是<strong>重新发送分组</strong></p></li><li><p>接收方接收到的分组发生了差错怎么办</p><p>分组中会包含检验和，接收方计算检验和之后，如果发现差错，那么就<strong>不发送ACK</strong></p></li><li><p>接收方接收到了重复分组怎么办</p><p>由于重传机制，接收方有可能收到重复的分组，使用<strong>序列号</strong>机制可以进行处理</p><ul><li><p>序列号</p><p>为每个分组分配一个序列号，当重新发送分组时，序列号不会改变，接受方可以通过查看序列号来判断它时候接受过这个分组</p></li></ul></li></ol></li><li><p>重传时间</p><p>通常情况下，协议会尝试估计分组的RTT,  并将该时间设置为重传时间</p></li></ul><h4 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h4><p>发送方和接收方必须要维护他们所发送或者接受的分组，可以采用一种<code>分组窗口</code>的机制来进行维护</p><ul><li><p>分组窗口(发送方)</p><p>发送方的窗口如下</p><p><img src="1.png" alt="1"></p><ul><li>窗口内的分组处于<strong>已发送但是未收到ACK</strong>的状态</li><li>窗口左边的分组处于已发送并且收到ACK的状态, 此时表明该分组已经传达完毕，发送方不需要继续保存它的副本以准备重传</li><li>窗口右边的分组处于仍未被发送的状态</li></ul><p>如果一个窗口内的分组(如4)接收到了ACK, 此时窗口就会减小，仿佛向右滑动了一个分组一样，因此该机制又被称为<strong>滑动窗口</strong></p><p>接收方也有类似的窗口，在这里不做过多的解释</p></li></ul><h4 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3. 流量控制"></a>3. 流量控制</h4><p>有时会发生接收方的接收速率相对于发送方的发送速率太慢的问题，此时就需要进行<strong>流量控制</strong>，有两种流量控制的方式:</p><ul><li><p>基于速率</p><p>接收方给发送方指定某个速率，确保发送发送速率不能超过这个值</p></li><li><p>基于窗口</p><p>这种方法比较流行，基本思想是通过接收方通知发送方窗口大小来控制流量速率，这种通知的操作被称为<strong>窗口更新</strong>，也叫作窗口通告</p><p>通常接受方会在发送ACK时捎带窗口更新的信息</p></li></ul><h3 id="二、TCP介绍"><a href="#二、TCP介绍" class="headerlink" title="二、TCP介绍"></a>二、TCP介绍</h3><ul><li><p>简介</p><p>TCP是传输层协议，提供<strong>面向连接的可靠字节流服务</strong>，字节流表示TCP发送消息时不会在消息中插入消息结束的标记，也表明了对于</p><p>数据字节流的解释将完全依靠应用程序</p></li></ul><h4 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1. 可靠性"></a>1. 可靠性</h4><ul><li><p>分组</p><p>TCP会将来自应用程序的数据拆成适合大小的多个分组来发送，接收方最终会将这些分组进行组合</p><p>这些分组会包含序列号，<strong>每个分组的序列号就是其第一个字节在整个数据流中的字节偏移</strong></p><p>由TCP传递给IP的分组被称为<strong>报文段(segment)</strong></p></li><li><p>检验和</p><p>TCP强制维护了一个检验和字段，任何带有无效检验和的报文到达都会被直接丢弃</p></li><li><p>ACK</p><p>当接收方接收到另一方的数据时，会发送ACK，而TCP的ACK不是立即发送，而是采用累计策略</p><p>一般来说，当发送方收到序列号为N的ACK分组时，表明该序号为N之前的所有字节均已被完全接收，</p><p>但是如果某个序列号小于N的ACK丢失了， 那么可能就会发生误判</p></li><li><p>重传</p><p>TCP一次性发送一个窗口数目的报文段，并且为这一组报文段设置一个<strong>计时器</strong>用于超时重传</p></li><li><p>全双工</p><p>TCP是全双工的，这意味着数据可以沿两个方向流动</p></li></ul><p>有关TCP的特性如下图</p><p><img src="2.png" alt="2"></p><h4 id="2-TCP头"><a href="#2-TCP头" class="headerlink" title="2. TCP头"></a>2. TCP头</h4><ul><li>TCP在IP数据报中的封装</li></ul><p><img src="3.png" alt="3"></p><ul><li><p>TCP头</p><p><img src="4.png" alt="4"></p><p>关于具体bit的讲解可以看wiki</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#.E5.B0.81.E5.8C.85.E7.B5.90.E6.A7.8B">https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#.E5.B0.81.E5.8C.85.E7.B5.90.E6.A7.8B</a></p></li></ul><h4 id="3-TCP中的计时器"><a href="#3-TCP中的计时器" class="headerlink" title="3. TCP中的计时器"></a>3. TCP中的计时器</h4><p>每当建立一个TCP连接，TCP都会维护四个计时器，后面我们会一一讲解</p><ul><li><p>重传定时器使用于当希望收到另一端的确认</p></li><li><p>持续计时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口</p></li><li><p>保活计时器检测到一个空闲连接的另一端何时崩溃或重启</p></li><li><p>2MSL定时器测量一个连接处于TIME_WAIT状态的时间</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[计算机网络_自顶向下]:应用层</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h3 id="一、应用层协议原理"><a href="#一、应用层协议原理" class="headerlink" title="一、应用层协议原理"></a>一、应用层协议原理</h3><h4 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1.网络应用程序体系结构"></a>1.网络应用程序体系结构</h4><ul><li><p>网络体系结构</p><p>网络体系结构是不变的，即因特网五层模型或OSI七层模型</p></li><li><p>应用程序体系结构</p><p>应用程序体系结构主要由应用程序研发者决定，主要包括两大类</p><ul><li><strong>客户-服务器体系结构</strong></li><li><strong>对等体系结构(P2P)</strong></li></ul></li></ul><p><strong>客户-服务器体系结构</strong></p><ul><li>服务器:总是不宕机，服务于许多来自于其他客户机的请求</li><li>客户:向服务器发送请求的主机</li></ul><p>在客户-服务器体系结构中，客户之间互相并不通信</p><p><strong>P2P体系结构</strong></p><ul><li>P2P体系结构几乎不依赖于专有服务器</li><li>应用程序在间断连接的主机之间可以直接通信，这些主机对被称为<strong>对等方</strong></li></ul><h4 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2.进程通信"></a>2.进程通信</h4><p>从操作系统的角度，主机间进行通信的的其实是<strong>进程</strong>而不是程序</p><ul><li><p>客户和服务器进程</p><p>在一对进程之间的通话场景中，发起通信的进程被称为 <strong>客户</strong>,在回话开始时等待联系的进程是<strong>服务器</strong></p></li><li><p>进程与计算机网络之间的接口</p><ul><li><p><strong>套接字</strong></p><p>套接字是进程与网络之间发送、接受报文的软件接口，即应用层与传输层之间的接口，也比称之为应用程序与网络之间的应用程序编程接口<strong>（API)</strong></p></li></ul></li><li><p>进程寻址</p><p>发送进程要想发送报文给接受进程，必须得知道接受进程的”所在位置”,这个所在位置通过<strong>IP地址</strong>和<strong>端口号</strong>进行标记</p><ul><li>IP地址:一个32位字符串，用来标记每一条主机</li><li>端口号:端口号是主机上进程的标识符，可以在网络上查到</li></ul></li></ul><h4 id="3-可供应用程序使用的运输服务"><a href="#3-可供应用程序使用的运输服务" class="headerlink" title="3.可供应用程序使用的运输服务"></a>3.可供应用程序使用的运输服务</h4><ul><li><p>可靠数据传输</p><p>能够保证进程到进程的数据将会被无差错的传递</p></li><li><p>最低限度吞吐量</p><p>能够保证报文在传输过程中的吞吐量至少不会少于某个值</p></li><li><p>定时保证</p><p>能够保证报文能够以较小的时延进入接受进程</p></li><li><p>安全性</p><p>能够对传输的数据进行加密</p></li></ul><h4 id="4-因特网提供的运输服务"><a href="#4-因特网提供的运输服务" class="headerlink" title="4.因特网提供的运输服务"></a>4.因特网提供的运输服务</h4><ul><li><p>TCP服务</p><p>TCP协议提供面向连接服务和可靠数据传输服务</p><ul><li><p>面向连接服务</p><p>在<em>数据包</em>开始流动之前，TCP会让客户和服务器之间互相交换运输层控制信息，被称为<strong>握手过程</strong></p><p>握手阶段结束过后，在发送进程与接收进程之间会建立一条<strong>TCP连接</strong>,双方可以在这条连接上进项数据报的传递</p><p>通信结束过后，会拆除该连接</p></li><li><p>可靠数据传输服务</p></li><li><p>安全性</p><p>TCP本身并不提供安全性服务,但它的加强版SSL提供了安全服务,这种加强是在应用层上实现的</p></li></ul><p>TCP还提供<strong>拥塞控制机制</strong>,当发送方与接收方进行网络通信发生网络拥塞时，TCP的拥塞控制机制会抑制发送进程</p></li><li><p>UDP服务</p><ul><li>面向无连接服务</li><li>缺乏可靠性</li></ul><p>UDP虽然可靠性不佳，但是它能自由调整发送速率，速率更快</p></li></ul><h3 id="二、Web和HTTP"><a href="#二、Web和HTTP" class="headerlink" title="二、Web和HTTP"></a>二、Web和HTTP</h3><h4 id="1-HTTP概况"><a href="#1-HTTP概况" class="headerlink" title="1.HTTP概况"></a>1.HTTP概况</h4><p>Web的应用层协议是HTTP(超文本传输协议)</p><p><strong>Web页面的构成</strong></p><ul><li>Web页面本质上是一个文档，是由各种<strong>对象</strong>组成的</li><li>HTML文件，JPEG图形,小程序,视频等都能被称作对象，并且可以通过URL寻址</li><li>一个页面总是包含一个HTML文件以及各种其他对象</li></ul><p><strong>URL的构成</strong></p><p>以<a href="http://www.someschool.edu/someDepartment%E8%BF%99%E4%B8%AAURL%E4%B8%BA%E4%BE%8B">http://www.someSchool.edu/someDepartment这个URL为例</a></p><ul><li><a href="http://www.someschool.edu是主机名/">www.someSchool.edu是主机名</a></li><li>/someDepartment是路径</li></ul><p><strong>在浏览器中点击超链接会发生什么</strong></p><ol><li>浏览器向Web服务器发出请求该页面中请求对象的HTTP报文</li><li>服务器接受到请求并用这些对象的HTTP响应报文进行响应</li></ol><p><strong>HTTP是无状态协议</strong></p><p>服务器向客户发送被请求的文件，但<strong>并不存储任何关于该客户的状态信息</strong></p><p>加入客户在短时间内请求了两个对象，服务器并不会因为第一次发送了对象第二次就不做出反应，而是重新再发送一次对象</p><h4 id="2-非持续连接与持续连接"><a href="#2-非持续连接与持续连接" class="headerlink" title="2.非持续连接与持续连接"></a>2.非持续连接与持续连接</h4><ul><li><p>非持续连接</p><p>客户每发送一个请求，就会单独建立一个TCP连接</p></li><li><p>持续连接</p><p>所有的请求以及响应经过相同的TCP连接发送</p></li></ul><p>对于HTTP而言，既支持非持续连接，也支持持续连接，默认状态下是持续连接</p><p><strong>三次握手</strong></p><p>当建立TCP连接后，在客户和服务器之间会发生三次握手</p><ol><li>客户向服务器发送一个小的TCP报文段</li><li>服务器接受到该报文段后，在用一个小的TCP报文段做出确认和响应</li><li>客户接收到确认的TCP报文段后，向服务器发送HTTP请求</li></ol><p><img src="1.png" alt="1"></p><p><strong>非持续连接的缺点</strong></p><ul><li>必须为每一个请求的对象建立一个全新的连接，这为Web服务器带来了负担</li><li>每一个对象的传输都会经历三次握手和自身的传输，相对于持续连接有两倍的往返时延(RTT)</li></ul><h4 id="3-HTTP报文格式"><a href="#3-HTTP报文格式" class="headerlink" title="3.HTTP报文格式"></a>3.HTTP报文格式</h4><ul><li><p>HTTP请求报文</p><p><img src="2.png" alt="2"></p></li></ul><ol><li><p><strong>请求行</strong></p><p>报文的第一行被称为请求行，包含三个字段，<strong>方法字段，URL字段和HTTP版本字段</strong></p><ul><li><p>方法字段</p><ul><li><p>GET</p><p>向指定的资源发出“显示”请求,是只读的</p></li><li><p>HEAD</p><p>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的文本部分</p><p>它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）</p></li><li><p>POST</p><p>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求体中。这个请求可能会创建新的资源或修改现有资源，或二者皆有</p><p>注：也可使用GET方法,在包含的URL中加入要输入的数据</p><p>如:<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE,%E5%90%8E%E9%9D%A2%E7%9A%84%60/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%60%E5%B0%B1%E6%98%AF%E9%99%84%E5%8A%A0%E5%86%85%E5%AE%B9">https://zh.wikipedia.org/wiki/超文本传输协议,后面的`/超文本传输协议`就是附加内容</a></p></li><li><p>PUT</p><p>向指定资源位置上传其最新内容。</p></li><li><p>DELETE</p><p>请求服务器删除Request-URI所标识的资源。</p></li><li><p>TRACE</p><p>回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p>OPTIONS</p><p>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p></li><li><p>CONNECT</p><p>HTTP/1.1协议中预留给能够将连接改为隧道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p></li></ul><p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#405">状态码405</a>（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#501">状态码501</a>（Not Implemented）。</p><p><strong>HTTP服务器至少应该实现GET和HEAD方法</strong>，其他方法都是可选的</p></li><li><p>HTTP版本</p><p>目前的HTTP版本有 HTTP/0.9  HTTP/1.0  HTTP/1.1  HTTP/2</p></li></ul><p>一个经典的HTTP请求报文如图所示，注意每一行都必须以<code>rn</code>结尾</p><p><img src="3.png" alt="3"></p><p>注：可以使用<code>telnet</code>工具来进行手动报文发送过程</p></li></ol><ul><li><p>HTTP响应报文</p><p><img src="4.png" alt="4"></p></li></ul><p>所有HTTP响应的第一行都是<strong>状态行</strong>，依次是当前HTTP版本号，3位数字组成的状态代码,以及描述状态的短语，彼此由空格分隔</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF">1xx消息</a>——请求已被服务器接收，继续处理</li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F">2xx成功</a>——请求已成功被服务器接收、理解、并接受</li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91">3xx重定向</a>——需要后续操作才能完成这一请求</li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF">4xx请求错误</a>——请求含有词法错误或者无法被执行</li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">5xx服务器错误</a>——服务器在处理某个正确请求时发生错误</li></ul><p>响应报文例子：</p><p><img src="5.png" alt="5"></p><h4 id="4-cookie"><a href="#4-cookie" class="headerlink" title="4.cookie"></a>4.cookie</h4><p><strong>cookie是什么</strong></p><p>cookie是一种<strong>小型文本文件</strong>”，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据</p><p><strong>为什么需要cookie</strong></p><p>HTTP服务器是无状态协议，无法保存用户的数据，但是Web网站通常希望能够识别用户的身份，因此他们使用Cookie来绕开HTTP的这种无状态协议</p><p><strong>Cookie的使用</strong></p><p>Cookie有四个组件</p><ol><li>HTTP响应报文中有一个Cookie首部行</li><li>HTTP请求报文中有一个Cookie首部行</li><li>用户端系统总有一个Cookie组件，并且由浏览器进行管理</li><li>Web站点的后端数据库中存储了记录用户身份的Cookie</li></ol><p>Cookie的使用过程</p><ul><li><p>当用户第一次访问某个Web站点时，该Web站点会在<strong>响应报文</strong>中的首部行中添加一行<code>Set-cookie:xxxx</code>,</p><p>浏览器接收到响应报文，并读取到这一行时，会在它的cookie文件中添加该Web网站的信息，包含<strong>服务器的主机名和该用户的识别码</strong></p></li><li><p>当用户再一次访问该站点时，浏览器会在请求报文中的是首部行加入cookie: xxxx,此时该Web站点会根据该识别码读取记录在它的后端数据库中的用户信息，此时用户就不用再次验证自己的身份</p></li></ul><p>下面是我的chrome浏览器中保存的cookie</p><ul><li>cookie</li></ul><p><img src="6.png" alt="6"></p><ul><li><p>使用cookie的报文发送过程</p><p><img src="7.png" alt="7"></p></li></ul><h4 id="5-Web缓存"><a href="#5-Web缓存" class="headerlink" title="5.Web缓存"></a>5.Web缓存</h4><p><strong>什么是Web缓存</strong></p><ul><li>Web缓存是一种临时存储Web文档以减少服务器延迟的一种技术</li><li>Web缓存器，也叫作代理服务器(proxy server)，可以保存最近请求过的对象的副本</li></ul><p><strong>Web的使用过程</strong></p><ul><li>用户在浏览器上点击一个超链接</li><li>浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器的对象发送一个HTTP请求</li><li>Web缓存器进行检查，看本地是否存储了该对象的副本，如果有，则Web缓存器用HTTP响应报文返回该对象</li><li>如果没有，他就打开一个与对象的初始服务器的TCP连接，向该服务器发送HTTP请求报文，服务器接受到请求报文后，向该Web缓存器发送一份响应报文</li><li>Web缓存器接收到对象后，在本地存储空间存储一份副本，并向客户的浏览器发送该副本</li></ul><p>从某种意义来说，Web缓存器既是客户也是服务器，它可以大大减少客户请求的响应时间</p><ul><li><p>图示</p><p><img src="8.png" alt="8"></p></li></ul><h4 id="6-条件GET方法"><a href="#6-条件GET方法" class="headerlink" title="6.条件GET方法"></a>6.条件GET方法</h4><p><strong>条件GET方法的作用</strong></p><p>由于Web缓存器中的对象可能是陈旧的，即服务器中的Web文档已经被修改，使用条件GET方法可以证实Web缓存器中的对象是最新的</p><p><strong>条件GET请求报文</strong></p><p>一个请求报文满足以下条件时就被称为<strong>条件请求报文</strong></p><ul><li>请求报文使用GET方法</li><li>请求报文中包含一个<code>If-Modified-Since: xxxx</code></li></ul><p><strong>条件请求报文的使用</strong></p><ul><li>当Web缓存器在本地缓存对象的时候，他也在本地缓存了最后的修改时期</li><li>下一次用户再次访问该Web页面的时候，该Web缓存器会向服务器发送条件请求报文</li><li>如果该Web页面在条件请求报文<code>if-Modified-Since:xxxx</code>所表示日期后没有发生修改，则Web服务器只会向Web缓存器发送一个不包含对象的响应报文</li></ul><p><img src="9.png" alt="9"></p><h3 id="三、因特网中的电子邮件"><a href="#三、因特网中的电子邮件" class="headerlink" title="三、因特网中的电子邮件"></a>三、因特网中的电子邮件</h3><p><strong>电子邮件的组成部分</strong></p><p>电子邮件通信主要由三大部分组成：</p><ul><li>用户代理</li><li>邮件服务器</li><li>邮件协议</li></ul><p>一、用户代理 (user agents)<br>就像我们常常使用的邮箱客户端，我们能直接接触的部分</p><ul><li>允许用户阅读,回复,转发,保存,编辑邮件消息</li></ul><ul><li>例如:Outlook, foxmail等</li></ul><ul><li>发送, 接收邮件消息到/从服务器</li></ul><ul><li>运行邮件协议</li></ul><p>二、邮件服务器 mail servers    </p><ul><li>邮箱mailbox 存放用户接收的邮件消息</li><li>外出报文队列outgoing message queue</li><li>运行邮件协议</li></ul><p>三、邮件协议</p><ul><li>简单邮件传输协议</li><li>邮件接受协议</li></ul><h4 id="一、SMTP简单邮件传输协议"><a href="#一、SMTP简单邮件传输协议" class="headerlink" title="一、SMTP简单邮件传输协议"></a>一、<strong>SMTP简单邮件传输协议</strong></h4><p>SMTP是因特网电子邮件中主要的应用层协议</p><ul><li><p>客户使用TCP来可靠传输邮件消息到服务器</p></li><li><p>端口号<code>25</code></p></li><li><p>直接传送: 发送服务器到接收服务器</p></li><li><p>传输的3个阶段</p><ul><li>握手 (问候)</li><li>邮件消息的传输</li><li>结束</li></ul></li><li><p>命令/应答的交互<br>– 命令: ASCII文本格式</p><p>– 应答: 状态码及其短语</p></li><li><p>邮件消息必须是7-bit ASCII</p></li></ul><p>例子:</p><p><img src="10.png" alt="10"></p><ul><li>Alice使用用户代理编写邮件消息(给<a href="mailto:&#98;&#x6f;&#x62;&#64;&#x73;&#111;&#x6d;&#101;&#115;&#99;&#104;&#x6f;&#x6f;&#x6c;&#46;&#x65;&#100;&#x75;">&#98;&#x6f;&#x62;&#64;&#x73;&#111;&#x6d;&#101;&#115;&#99;&#104;&#x6f;&#x6f;&#x6c;&#46;&#x65;&#100;&#x75;</a>的)</li></ul><ul><li>Alice的用户代理发送邮件消息 到她的邮件服务器;邮件消息存放在邮件消息队列</li></ul><ul><li><p>Alice<strong>邮件服务器</strong>的SMTP客户端发起建立一个到Bob的邮件服务器的SMTP服务器端的TCP连接,经过应用层握手</p><p>注：</p><ul><li>如果此时Bob的邮件服务器没有开机，那么Alice的邮件服务器会在稍后继续进行尝试</li><li>Alice的邮件服务器和Bob的与邮件服务器总是直接连接，他们不使用中间邮件服务器</li></ul></li></ul><ul><li>SMTP客户在这个TCP连接上发送Alice的邮件消息</li></ul><ul><li>Bob服务器存放邮件消息存到 Bob的邮箱</li></ul><ul><li>Bob调用他的用户代理读邮件消息</li></ul><p>下面是一个使用telnet发送邮件的例子</p><p><img src="11.png" alt="11"></p><p><strong>SMTP总结</strong></p><ul><li>SMTP使用持续连接</li><li>SMTP 要求邮件消息 (header &amp; body)必须 是7-bit ASCII</li><li>SMTP服务器使用 CRLF.CRLF (rn.rn)来判断邮件消息的结束</li></ul><h4 id="二、与HTTP对比"><a href="#二、与HTTP对比" class="headerlink" title="二、与HTTP对比"></a>二、与HTTP对比</h4><ul><li><p>HTTP是服务器向Web客户传送报文</p></li><li><p>SMTP是邮件服务器向另一个邮件服务器传送报文</p></li><li><p>HTTP是<strong>拉协议</strong></p><p>在服务器开机的时候，用户使用HTTP从Web服务器上拉取信息,TCP是由想连接文件发起的</p></li><li><p>SMTP是<strong>推协议</strong></p><p>发送邮件服务器使用SMTP把文件推向接收文件服务器,TCP连接是由要发送文件的机器发起的</p></li><li><p>HTTP把每个对象封装到它自己的响应报文中</p><p>SMTP把所有对象都放到一个响应报文中</p></li></ul><h4 id="三、邮件报文格式"><a href="#三、邮件报文格式" class="headerlink" title="三、邮件报文格式"></a>三、邮件报文格式</h4><p><strong>首部行</strong></p><ul><li><p>To: </p></li><li><p>From:</p></li><li><p>Subject:</p><p>…</p><p>首部必须包含From和To,其他的首部行则是可选的</p></li></ul><p><strong>分隔符</strong></p><p>使用回车换行==CRLF==将首部行与body分割</p><p><strong>报文体</strong></p><p>使用ASCII码格式</p><h4 id="四、邮件访问协议"><a href="#四、邮件访问协议" class="headerlink" title="四、邮件访问协议"></a>四、邮件访问协议</h4><p><img src="12.png" alt="12"></p><ul><li>邮件接收方通过POP3(第三版邮局协议)、IMAP(因特网邮件访问协议)、HTTP等协议将邮件从自身的邮件服务器拉取到自己的主机上</li></ul><p><strong>POP3</strong></p><p>当用户代理打开了一个到邮件服务器端口110上的TCP连接后，POP3协议开始发挥作用</p><p>POP3按照三个阶段发挥作用:</p><ul><li><p>授权(authorization)</p><p>用户代理以明文形式向服务器发送用户名(user)以及口令(pass)用来鉴别自身身份</p></li><li><p>事务处理</p><p>用户取得报文(retr)，同时还能进行以下操作</p><ul><li>对报文做删除标记(dele)</li><li>取消删除标记</li><li>获取邮件数量以及各自大小(list)</li></ul></li><li><p>更新</p><p>使用quit指令，POP3对话将会结束，邮件服务器将会是删除那些被标记为删除的报文</p></li></ul><p><strong>IMAP</strong></p><ul><li><p>POP3在服务器上不能为用户创建任何远程文件夹</p></li><li><p>IMAP服务器会把报文和每一个文件夹联系起来，当报文第一次到达服务器时，会被存放到收件人的INBOX文件夹中，</p><p>收件人则能够把邮件移动到一个新的文件夹中(邮件服务器上)，用户能够对邮件进行删除，阅读等操作, IMAP提供了这些命令</p></li><li><p>IMAP还能允许用户代理获取报文的某些部分，比如首部行</p></li></ul><p><strong>HTTP</strong></p><p>当使用Web进行邮件的接受时，用户代理就是普通的浏览器，用户与远程服务之间通过HTTP协议进行通信</p><h3 id="四、DNS"><a href="#四、DNS" class="headerlink" title="四、DNS"></a>四、DNS</h3><p><strong>什么是DNS</strong></p><p>DNS(Domain Name System,<strong>域名系统</strong>)有两重身份</p><ul><li>一个由分层的DNS服务器实现的DNS数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul><p><strong>DNS运行在UDP之上，使用53号端口</strong></p><p><strong>域名与IP地址</strong></p><p>以<a href="http://www.baidu.com为例,baidu.com就是域名,它的ip地址为/">www.baidu.com为例，baidu.com就是域名,它的IP地址为</a> 220.181.38.148</p><p>域名是面向用户的，具有可读性，IP地址是面向网络的，具有规范性</p><h4 id="1-DNS提供的服务"><a href="#1-DNS提供的服务" class="headerlink" title="1.DNS提供的服务"></a>1.DNS提供的服务</h4><ul><li><p>DNS被其他应用层协议，包括HTTP,STMP,FTP等所使用，<strong>将用户提供的主机名(域名)解析为IP地址</strong></p></li><li><p>主机别名</p><p>一台主机只有一个<strong>规范主机名</strong>，但它可能有多个<strong>别名</strong>，应用程序可以调用DNS来取得主机别名对应的规范主机名，以及IP地址</p></li><li><p>邮件服务器别名</p><p>邮件服务器也可以使用别名，甚至一个公共邮件服务器的别名可以和Web服务器使用相同的别名，应用程序可以调用DNS来取得主机别名对应的规范主机名，以及IP地址</p></li><li><p>负载分配</p><p>一个站点(如cnn.com)可以被分布在多台服务器上，一台服务器也可以运行在多台端系统上，因此，一个<strong>IP地址集合</strong>可以与同一个规范主机名相联系,DNS数据库存储这这些IP地址集合</p><p>每次用户总是向IP地址排在第一个的服务器发送HTTP请求报文，DNS在每次回答中都会循环这些地址次序，以此做到循环分配负载</p></li></ul><h4 id="2-DNS工作机理"><a href="#2-DNS工作机理" class="headerlink" title="2.DNS工作机理"></a>2.DNS工作机理</h4><p><strong>域名的分级</strong></p><p><img src="13.png" alt="13"></p><p><strong>分布式、层次数据库</strong></p><ul><li>DNS使用了大量的DNS服务器，以层次的方式在全世界的范围内进行组织</li></ul><table><thead><tr><th>分类</th><th>作用</th></tr></thead><tbody><tr><td>根域名服务器</td><td>最高层次的域名服务器，本地域名服务器解析不了的域名就会向其求助</td></tr><tr><td>顶级域名服务器</td><td>负责管理在该顶级域名服务器下注册的二级域名</td></tr><tr><td>权威域名服务器</td><td>负责一个区的域名解析工作</td></tr><tr><td>本地域名服务器</td><td>当一个主机发出DNS查询请求时，这个查询请求首先发给本地域名服务器</td></tr></tbody></table><p><strong>域名的解析流程</strong></p><p>域名解析总体可分为以下过程：<br>(1)输入域名后, 先查找自己主机对应的域名服务器，域名服务器先查找自己的数据库中的数据.<br>(2) 如果没有， 就向上级域名服务器进行查找， 依次类推<br>(3) 最多回溯到根域名服务器, 肯定能找到这个域名的IP地址<br>(4) 域名服务器自身也会进行一些缓存， 把曾经访问过的域名和对应的IP地址缓存起来, 可以加速查找过程<br>具体可描述如下：</p><ol><li>主机先向本地域名服务器进行<strong>递归查询</strong></li><li>本地域名服务器采用<strong>迭代查询</strong>，向一个根域名服务器进行查询</li><li>根域名服务器根据域名的顶级域名部分，告诉本地域名服务器，<strong>下一次应该查询的顶级域名服务器的IP地址</strong></li><li>本地域名服务器向顶级域名服务器进行查询</li><li>顶级域名服务器告诉本地域名服务器，下一步查询权威服务器的IP地址</li><li>本地域名服务器向权威服务器进行查询</li><li>权威服务器告诉本地域名服务器所查询的主机的IP地址</li><li>本地域名服务器最后把查询结果告诉主机<br>如图所示：</li></ol><p><img src="14.png" alt="14"></p><p><strong>递归查询与迭代查询</strong></p><ul><li><p>递归查询</p><p>本机向本地域名服务器发出一次查询请求，就静待最终的结果，这次查询被称为递归查询。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p></li><li><p>迭代查询</p><p>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询，本地域名服务器进行的三次查询被称为迭代查询</p></li></ul><p><strong>DNS缓存</strong></p><p>DNS缓存可以改善时延性能并减少在因特网上到处传播的DNS报文</p><ul><li><p>工作机理</p><p>当服务器接收到另外一台主机发送的响应报文(包含域名到IP地址的映射)后，会将该映射保存在缓存中，下一次当查询相同域名的请求报文发送到该主机时，可以直接从缓存中拿出并发送</p></li><li><p>DNS服务器一般会在两天后丢弃缓存信息</p></li></ul><h4 id="3-DNS记录和报文"><a href="#3-DNS记录和报文" class="headerlink" title="3.DNS记录和报文"></a>3.DNS记录和报文</h4><p>所有的DNS服务器中都存储了资源记录<strong>RR(Resource Record)</strong></p><p><strong>RR的内容</strong></p><p>RR是一个包含了四个字段的四元组:==(Name,Value,Type,TTL)==</p><ul><li>TTL是该记录的生存时间，它记录了资源记录应当从缓存中删除的时间</li></ul><p>下面详细介绍Name,Value和Type</p><ul><li>Type=A,则Name是主机名，Value是该主机名对应的IP地址</li><li>Type=NS,则Name是域，Value是该域对应的权威DNS服务器的主机名</li><li>Type=CNAME,则Value是别名为Name的服务器的规范主机名</li><li>Type=MX，则Value是个别名为Name的邮件服务器的规范主机名</li></ul><p><strong>DNS报文</strong></p><p><img src="15.png" alt="15"></p><p>DNS的查询报文与响应报文格式相同，均为上表所示</p><ul><li><p>前12个字节是首部区域，包含6个字段</p><ul><li><p>事务ID，也称标识符，用来标记该查询，该标识符会被复制到响应报文中，以便让客户能够匹配它接收到的和请求的回答</p></li><li><p>标志</p><p>常见的标志如下:</p><ul><li><p>查询/回答标志(0/1)</p><p>指出该报文是查询还是回答</p></li><li><p>“权威的”标志</p><p>当该报文是权威DNS服务器的响应报文时，应该在首部行加上”权威的”标志</p></li><li><p>“希望递归”标志</p><p>表明客户希望对该域名进行递归查询</p></li><li><p>“递归可用”标志</p><p>如果递归服务器支持递归查询，会加上”递归可用”标志</p></li></ul></li><li><p>另外四个字段记录了另外最后四个字段的RR数目</p></li></ul></li><li><p>查询问题区域</p><p>包含Name字段和Type字段，用来表明需查询的信息</p></li><li><p>回答问题区域</p><p>包含了回答的信息，即RR</p><p>由于一个服务器可能对应多个IP，所以回答字段可以包含多个RR</p></li><li><p>权威区域</p><p>包含了其他权威服务器的信息</p></li><li><p>附加区域</p><p>如果回答区域有一条RR记录了服务器的规范主机名，则在附加区域会补充一条类型A记录</p></li></ul><p>下面是一个wireshark抓包的例子</p><p><img src="16.png" alt="16"></p><p><strong>在域名数据库中插入记录</strong></p><p>如今购买域名以及设置DNS已经十分简单，下面是我在腾讯云设置DNS解析的例子</p><p><img src="17.png" alt="17"></p><ul><li><p>主机记录: RR中的Name字段</p><ul><li><p>www: 解析后的域名为<code>www.liver0377.xyz</code></p></li><li><p>@: 直接解析主域名, 如liver0377.xyz</p></li><li><p><em>: 泛解析，匹配所有域名, 如</em>.liver0377.xyz</p></li></ul></li><li><p>记录类型： 就是RR中的type字段</p></li></ul><blockquote><p>拒绝攻击服务(DDoS):</p><p>攻击者对DNS服务器发送大量分组，导致大多数合法DNS请求得不到回答</p></blockquote><h3 id="五、P2P"><a href="#五、P2P" class="headerlink" title="五、P2P"></a>五、P2P</h3><p>P2P协议(peer to peer), 与客户-服务器体系不同，资源被分散存储在网络的各个用户上，每个用户既是下载者，也是上传者</p><ul><li>P2P与C/S体系的分发时间对比</li></ul><p><img src="18.png" alt="18"></p><p>最流行的协议是<code>BitTorrent</code>， 可以看看这篇科普博客(<a href="https://zhuanlan.zhihu.com/p/87327257">https://zhuanlan.zhihu.com/p/87327257</a>)</p><h3 id="六、CDN"><a href="#六、CDN" class="headerlink" title="六、CDN"></a>六、CDN</h3><p>对如<code>youtube</code>之类的因特网视频公司，提供视频服务最直接的方法是建立单一大规模数据中心，但是这种方法有三个缺点</p><ol><li>如果客户远离数据中心，时延就会很大</li><li>流行的视频可能会在相同的通信链路上发送很多次，这会浪费网络带宽，同时也会使得公司向ISP服务商提供更高的费用</li><li>如果中心节点故障，将会造成整个链路崩溃</li></ol><ul><li><p>CDN</p><p>如今大多数公司使用<strong>内容分发网(Content Distribution Network, CDN)</strong>, CDN的基本策略就是在世界各地建立服务器集群，当用户发出请求时，会自动将其定向到一个提供最好用户体验的CDN服务器集群</p></li><li><p>分类</p><p>CDN分为<strong>私有</strong>与<strong>第三方</strong>两类，私有即内容提供商私人拥有，如google就拥有很多自己的私人数据中心, 第三方CDN则可以代表多个内容提供商分发内容</p></li></ul><h4 id="1-服务器安置策略"><a href="#1-服务器安置策略" class="headerlink" title="1. 服务器安置策略"></a>1. 服务器安置策略</h4><p>CDN通常有两种不同的服务器安置策略</p><ul><li><p>深入</p><p>在遍及全球的接入ISP部署服务器集群来<strong>深入</strong>到ISP的<strong>接入网</strong>当中，这样做可以更加靠近用户，但缺点是需要很多集群，会带来管理不便</p></li><li><p>邀请做客</p><p>在少量关键位置建造大集群来邀请客户到ISP做客，通常是在因特网交换点(IXP)， 这是如今普遍使用的方式</p><p>注: ISP  &lt;==&gt; IXP &lt;==&gt; CDN服务器</p></li></ul><p><strong>实现</strong></p><p>当用户向服务器发送请求时，CDN通常会截取请求，并:</p><ul><li>确定此时适合该用户的CDN集群</li><li>将用户的请求重定向到适合于该用户的CDN服务器集群</li></ul><p>通常，CDN会与DNS提供商进行合作，来进行用户请求的截获与重定向</p><ul><li><p>例子</p><ul><li><p>用户访问<code>NetCiema</code>的Web网页</p></li><li><p>当用户点击视频链接<code>http://video.netcinema.com/XXXXXX</code>时，用户主机发送了一个对于video.netcinema.com的DNS请求</p></li><li><p>用户的本地DNS服务器(LDNS)将该DNS请求中继到一台用于NetCinema的权威DNS服务器</p><p>NetCinema权威DNS服务器向LDNS<strong>返回一个KingCDN域的主机名，而不是IP地址</strong>，如a1105.kingcdn.com</p></li><li><p>DNS请求进入KingCDN专用DNS基础设施，LDNS发送对a1101.kingcdn.com的DNS请求</p><p>KingCDN的DNS请求进行重定向操作，返回需要的KingCDN内容服务器的IP地址</p></li><li><p>LDNS向用户主机转发IP地址</p></li><li><p>用户主机与指定IP地址的主机创建TCP连接，获取到内容</p></li></ul><p><img src="19.png" alt="19"></p></li></ul><h4 id="2-集群选择策略"><a href="#2-集群选择策略" class="headerlink" title="2. 集群选择策略"></a>2. 集群选择策略</h4><ul><li>地理位置最接近</li><li>实时测量时延</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[计算机网络_自顶向下]:计算机与因特网</title>
    <link href="/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <url>/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h1><h3 id="一、什么是因特网"><a href="#一、什么是因特网" class="headerlink" title="一、什么是因特网"></a>一、什么是因特网</h3><p>因特网有以下两种描述方式</p><ol><li>具体构成描述</li><li>服务描述</li></ol><h4 id="1-具体构成描述"><a href="#1-具体构成描述" class="headerlink" title="1.具体构成描述"></a>1.具体构成描述</h4><p>因特网是一个互联了全世界数十亿计算机设备的网络</p><p><strong>基本术语:</strong></p><ul><li><p>主机/端系统:手机、电脑、电视等一切与因特网相连的终端设备</p></li><li><p>通信链路:网络中两个节点之间的<strong>物理通道</strong>称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波</p></li><li><p>分组交换机</p><ul><li>分组交换机从它的一条入通信线路接受到达的分组，并从它的一条出通信链路转发该分组</li><li>当今最常见的分组交换机有<strong>路由器</strong>和<strong>链路层交换机</strong>两种</li></ul></li><li><p>路径:从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机</p></li><li><p>ISP(因特网服务提供商/Internet Service Provider)</p><ul><li>端系统通过ISP接入因特网</li><li>每个ISP本身就是由多台交换机和通信链路组成的通信网络</li><li>ISP分层级，较低层的ISP通过较高层的ISP完成互联</li></ul></li><li><p>协议</p><ul><li>端系统，交换机和其他因特网部件都要通过运行一系列协议控制因特网中信息的接受与发入</li><li><strong>TCP</strong>(Transmition Controal Protocal):传输控制协议</li><li><strong>IP</strong>(Internet Protocol):网际协议</li></ul></li><li><p>RFC(Request for comment):因特网协议标准文档</p></li></ul><h4 id="2-服务描述"><a href="#2-服务描述" class="headerlink" title="2.服务描述"></a>2.服务描述</h4><p>因特网是为应用程序提供服务的基础设施</p><p><strong>基本术语：</strong></p><ul><li><p>分布式应用程序:运行在端系统上的应用程序</p></li><li><p>套接字接口</p><p>运行在不同端系统上应用程序之间发送数据必须得遵循一套规则，因特网套接字接口就是这样的一套规则集合</p></li></ul><h4 id="3-协议"><a href="#3-协议" class="headerlink" title="3.协议"></a>3.协议</h4><p>协议定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送或接收一条报文或其他时间所采取的的动作</p><h3 id="二、网络边缘"><a href="#二、网络边缘" class="headerlink" title="二、网络边缘"></a>二、网络边缘</h3><p>主机与端系统均位于端系统的边缘，主机又可以细分为<strong>客户</strong>和<strong>服务器</strong></p><h4 id="1-接入网"><a href="#1-接入网" class="headerlink" title="1.接入网"></a>1.接入网</h4><p>指将端系统连接到其<strong>边缘路由器</strong>的网络</p><p><strong>家庭接入:DSL,电缆，FTTH，拨号和卫星</strong></p><ul><li><p>DSL(Digital Subscriber line)</p><p>DSL即<strong>数字用户线</strong>，住户从提供本地电话接入的本地电话公司出获得DSL因特网接入，本地的电话公司即为它的ISP，物理线路使用双绞铜线</p><ul><li>调制解调器:  即俗称的”猫”,将数字信号转变为模拟信号</li><li>DSLAM(数字用户线接入复用器):  位于本地中心局，来自家庭的模拟信号在DSLAM解码为数字信号</li></ul><p>家庭电话线能同时传输数据和传统的电话信号，这两种信号使用不同频率编码</p></li><li><p>电缆网络</p><p>住户从提供有线电视的公司取得电缆因特网接入</p><ul><li><p>HFC:混合光纤同轴系统</p><p>有线电视公司采用光缆将电缆头端连接到地区枢纽，之后采用传统的同轴电缆到达各个家庭</p></li></ul><p>与DSL类似，电缆网络也有类似的调制解调器和端接系统</p><ul><li>电缆调制解调器</li><li>电缆调制解调器端接系统CMTS</li></ul><p>电缆因特网接入的一个重要特征为<strong>共享广播媒体</strong>，如果有多个用户同时经<strong>下行信道</strong>，个人网速将大大下降</p></li><li><p>FTTH(光纤到户)</p><p>从本地中心局直接到家庭提供了一条光纤路径</p><ul><li><p>两种光纤分布体系结构</p><ol><li><p>有源光纤网络(AON)</p></li><li><p>无源光纤网络(PON)</p><p>每个家庭具有一个光纤网络端接器(ONT),由专门的光纤接入到邻近的分配器，一个分配器可连接几十个家庭，把这些家庭的信号通过一根光纤连接到本地电话公司的中心局的光纤线路端接器(OLT),OLT最终与因特网相连接</p></li></ol></li><li><p>光纤网速极快，不同的速率对应不同的花费</p></li></ul></li><li><p>拨号接入</p><p>与DSL模式基本相同，但是速率很慢，只有56kbps</p></li><li><p>卫星</p><p>通过卫星链路与因特网相连</p></li></ul><p><strong>企业接入：以太网和WIFI</strong></p><ul><li><p>LAN:局域网</p></li><li><p>以太网是目前公司，家庭，大学中最流行的网络接入技术</p><p>端设备与以太网交换机相连，以太网交换机再与更大的因特网相连</p></li><li><p>无线LAN(WIFI)</p><p>无线用户从/到一个接入点发送/接受分组，该接入点与企业网相连,企业网再与有线因特网相连</p></li></ul><p><strong>广域无线技术:4G</strong></p><h3 id="三、网络核心"><a href="#三、网络核心" class="headerlink" title="三、网络核心"></a>三、网络核心</h3><p>网络核心，即互联因特网端系统的分组交换机和链路构成的网状网络</p><h4 id="1-分组交换"><a href="#1-分组交换" class="headerlink" title="1.分组交换"></a>1.分组交换</h4><p><strong>基本术语:</strong></p><ul><li>报文:端系统之间彼此发送的信息统称为报文</li><li>分组:原系统将要发送的长报文划分为较小的数据块，称之为分组</li></ul><p><strong>存储转发运输</strong></p><ul><li><p>交换机在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p></li><li><p>已经到达交换机的分组的一部分将作为缓存存储在交换机中</p></li></ul><p><strong>排队时延和分组丢失</strong></p><ul><li><p>分组交换机与多条链路相连，对于每条与之相连的链路，交换机都有一个与之对应的<strong>输出缓存</strong>，也称输出队列</p></li><li><p>如果到达的分组需要传输到某条链路，但该条链路已经被其他分组占满，则该分组必须在输出缓存中等待，产生<strong>排队时延</strong></p></li><li><p>排队时延取决于网路的拥塞程度</p></li></ul><p><strong>转发表和路由选择协议</strong></p><ul><li><p>IP地址</p><p>因特网中的每一个端系统都有一个IP地址</p><p>当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址，每到达一个路由器,路由器都会检查该IP地址的<strong>一部分</strong></p></li><li><p>转发表</p><p>每个路由器都有一个转发表，用来将IP地址映射成输出链路</p></li></ul><h4 id="2-电路交换"><a href="#2-电路交换" class="headerlink" title="2.电路交换"></a>2.电路交换</h4><ul><li>电路交换与分组交换截然不同，在发送方发送信息之前，网络必须得在发送方与接收方之间创建一条连接，创建连接后，发送结束前，该连接上的所有链路都将为这个连接所占用</li><li>使用电路交换的链路上的数据流通速率是恒定的，没有延迟</li></ul><p><strong>电路交换网络的复用</strong></p><p>复用即使一条链路能都被多条连接使用，电路交换的复用主要有两种:<strong>频分复用(FDM)</strong>,<strong>时分复用(TD)</strong></p><p><strong>频分复用</strong></p><ul><li>对于FDM，链路的频谱由跨越网络创建的所有连接共享</li><li>该链路上的每一个连接都拥有一段单独的频谱，频谱的宽度被称为<strong>带宽</strong></li></ul><p><strong>时分复用</strong></p><ul><li>TMD链路的连接过程中，时间被划分为固定的<strong>帧</strong>，每个<strong>帧</strong>又被划分为固定数量的<strong>时隙</strong></li><li>该链路的每一帧的固定位置上的时隙均由特定的连接使用</li><li>对于TDM,一条电路的传输速率等于帧速率乘以一个时隙中的比特速率</li></ul><p><img src="1.png" alt="1"></p><h4 id="分组交换与电路交换的对比"><a href="#分组交换与电路交换的对比" class="headerlink" title="分组交换与电路交换的对比"></a>分组交换与电路交换的对比</h4><ul><li><p>电路交换特点:</p><p>实时性强，时延小，交换设备成本低，同时由于是独占线路，所以不会产生丢包，但同时也会带来线路利用率低，电路接续时间长，通信效率低，不同类型终端用户不能进行通信等缺点</p></li><li><p>分组交换特点:</p><p>效率高，因为不必占用链路，但是当输入信号过多时，会产生延迟</p></li></ul><p>在因特网中，数据的传输具有突发性，某一时刻的数据量可能会突然膨胀，此时如果使用电路交换这种固定分配的策略就不是很适合，所以，因特网使用的是<strong>分组交换</strong></p><p>下面给出一个例子</p><p><img src="2.png" alt="2"></p><p>可以看出，在给定的条件下，采用电路交换只能固定的将链路带宽分为10个用户，而分组交换则可以支持更多的用户，因为仅有0.004的概率下有超过10个用户同时发送报文</p><h3 id="四、时延、丢包和吞吐量"><a href="#四、时延、丢包和吞吐量" class="headerlink" title="四、时延、丢包和吞吐量"></a>四、时延、丢包和吞吐量</h3><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p><strong>时延概述</strong></p><p>分组从源出发沿着路径传输时，会经历不同的时延，具体包括<strong>节点处理时延，排队时延，传输时延，传播时延</strong>，累加起来为<strong>节点总时延</strong></p><ul><li><p>处理时延</p><p>路由器在处理分组时需要检查分组的首部并决定将该分组导向何处，产生处理时延</p></li><li><p>排队时延</p><p>当分组在链路上排队等待传输时，会产生排队时延</p></li><li><p>传输时延</p><p>是指<strong>将所有的比特从路由器中推向链路</strong>产生的时延</p></li><li><p>传播时延</p><p><strong>比特在链路中传播产生的时延</strong>，由于比特在电缆、光纤等物理媒介中的速度接近光速，所以传播时延一般较小</p><p>但如果链路很长，比如通向卫星，传播时延也不能忽略</p></li></ul><p><strong>排队时延</strong></p><p>排队时延很大程度上取决于<strong>流量到达队列的速度，链路的传播速率，到达流量的性质（突发性或周期性）</strong></p><p>记R为传输速率，即将比特从路由器推向链路的速率，分组均为L比特，a表示分组到达队列的平均速率，单位为分组/s</p><ul><li>流量强度: La/R,用来表示流量的大小</li><li><strong>设计系统时流量强度不能大于1</strong>，否则分组到达队列的速率将超过分组出队列的速率，延时将趋向无穷大</li><li>随着流量强度逐渐趋向于1,平均排队时延将迅速增加</li></ul><p><img src="3.png" alt="3"></p><p><strong>丢包</strong></p><p>现实中路由器的缓存是有限的，如果需要排队的分组数量超过了路由器的缓存，余下的分组数据将会被丢失，称之为<strong>丢包</strong></p><p><strong>端到端时延</strong></p><p>设在路径上有N-1个节点(交换机),如不考虑排队延时，则从一个端系统到另一个端系统的总延时为:</p><p>$d<del>end-end</del>=N(d<del>proc</del>+d<del>trans</del>+d<del>prop</del>)$</p><ul><li><p>$dproc:$每台路由器和源主机的处理时延</p></li><li><p>$dprop:$每条链路的传播时延</p></li><li><p>$dtrans:$ 每台路由器的传输时延</p></li></ul><p><strong>其他时延</strong></p><ul><li>向共享媒体传输分组的端系统有可能有意的延迟它的传输</li><li>在IP语音(VoIp)的应用中，发送方在传递分组之前必须先用编码的数字化语音填充分组，产生的时延被称为分组化时延</li></ul><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li><p>瞬时吞吐量: 目的端系统接收到文件的瞬间速率</p></li><li><p>平均吞吐量:将总数据除以总时间可得到平均吞吐量</p></li><li><p>瓶颈链路</p><ul><li><p>通常情况下，网络核心中的传输速率都非常高，所以瓶颈通常在接入网，在源到目的地的路径中,吞吐量为该链接中所有链路中的最小传输速率</p><p>即吞吐量=min{$R_1,R_2,R_3$}</p></li><li><p>如果接入用户非常多，他们都通过网络核心的某一条链路进行传播，此时网络核心链路的传输速率可能会限制整个连接的传输速率</p></li><li><p>在连接中对总吞吐量产生决定影响的链路称为<strong>瓶颈链路</strong></p></li></ul></li></ul><h4 id="五、协议层次及其服务模型"><a href="#五、协议层次及其服务模型" class="headerlink" title="五、协议层次及其服务模型"></a>五、协议层次及其服务模型</h4><p>网络设计者以分层的方式阻止协议以及实现这些协议的软件和硬件，各层的所有协议被称为<strong>协议栈</strong></p><h4 id="因特网协议栈"><a href="#因特网协议栈" class="headerlink" title="因特网协议栈"></a>因特网协议栈</h4><p>因特网协议栈由五个层次组成:应用层，运输层，网络层，链路层，物理层</p><ul><li>应用层<ul><li>应用层是网络应用程序以及他们的应用层协议存留的地方，包括HTTP,SMP,FTP等协议</li><li>应用层的信息分组称之为<strong>报文(message)</strong></li></ul></li><li>运输层<ul><li>运输层在应用程序之间传递应用层报文</li><li>因特网中包含两种运输协议,HTTP,UDP</li><li>运输层的分组被称为<strong>报文段(segment)</strong></li></ul></li><li>网络层<ul><li>网络层解决在一个单一网络上传输数据包的问题</li><li>网际协议IP包含在网络层中</li><li>网络层的分组被称之为<strong>数据包(datagram)</strong></li></ul></li><li>链路层<ul><li>链路层是数据包从一个设备的网络层传输到另外一个设备的网络层的方法</li><li>包括以太网,WIFI,和电缆接入网的DOCSIS等协议</li><li>链路层的分组被称之为<strong>帧</strong></li></ul></li><li>物理层<ul><li>将链路层帧中的一个个比特从一个节点移到下一个节点</li></ul></li></ul><p>下面是五层协议栈的图示以及每层中一些对应的具体协议</p><p><img src="4.png" alt="4"></p><p>下面是实际传输过程中数据时如何被传输的，可以看到交换机中只实现了两层，而路由器中只实现了三层</p><p><img src="5.png" alt="5"></p><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p>国际标准化组织ISO提出计算机网络围绕7层组织，提出了开放系统互联模型(OSI)</p><p>OSI参考模型的7层是:<strong>应用层，表示层，会话层，运输层，网络层，数据链路层和物理层</strong></p><p>同名的5层功能基本下相同，下面介绍表示层和会话层</p><p><strong>表示层</strong></p><ul><li>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式</li></ul><p><strong>会话层</strong></p><ul><li>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</li></ul><p>因特网中并没有该两层，如果应用程序开发者需要这些服务，可自行构建对应功能</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>网络协议中的层级由上至下，会对数据包进行封装，即添加上各种附加信息</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:恢复算法</title>
    <link href="/2022/02/14/CMU15445-%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/14/CMU15445-%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="ARIES"><a href="#ARIES" class="headerlink" title="ARIES"></a>ARIES</h3><p><strong>利用语义的恢复和隔离算法(Algorithms for Recovery and Isolation Exploiting Semantics ,ARIES)<strong>，最早在90年代初由IBM提出，是一种基于</strong>WAL</strong>的故障恢复机制，ARIES的核心思想可以总结为三点：</p><ul><li><p>Write-Ahead Logging(WAL)</p><ul><li>在数据输出到磁盘之前，所有的更新日志必须首先输出到磁盘</li><li>必须使用Steal + No-Force的buffer Pool Policy</li></ul></li><li><p>Repeating History During Redo</p><p>当从崩溃中恢复时，使用redo操作将数据库完全恢复成崩溃之前的样子</p></li><li><p>Logging Changes During Undo</p><p>在undo使同样要把undo操作本身记录到日志当中，以避免undo操作时再次崩溃进而发生重复undo的情况</p></li></ul><h3 id="WAL-Records"><a href="#WAL-Records" class="headerlink" title="WAL Records"></a>WAL Records</h3><p>将缓存在内存中的日志记录称为<strong>WAL Records</strong>, 与此同时，使用**日志序列号(Log Sequence Number, LSN)**来标识每个日志记录，除此之外还有一些特殊的LSN, 下面是其中的一部分</p><table><thead><tr><th>名称</th><th>位置</th><th>含义</th></tr></thead><tbody><tr><td>flushedLSN</td><td>内存中的某个位置</td><td>磁盘日志区域当中所记录的最后一条LSN</td></tr><tr><td>pageLSN</td><td>buffer pool的每个page</td><td>在该page上所做的最后一次更新操作对应的LSN</td></tr><tr><td>recLSN</td><td>buffer pool的每个page</td><td>在该page上所做的首次更新操作对应的LSN</td></tr><tr><td>lastLSN</td><td>每个事务中</td><td>事务所写的最后一条日志记录的LSN</td></tr><tr><td>masterRecord</td><td>磁盘</td><td>最后一次checkPoint对应的LSN</td></tr></tbody></table><ul><li><p>LSN</p><p>LSN本质上是<strong>日志文件 + 文件偏移量</strong>所组合成的一个编号，是单调递增的</p></li><li><p>flushedLSN</p><p>基于WAL机制，当page <code>x</code>想要被刷新到磁盘时，那么就必须得确保：</p><p><img src="1.png" alt="1"></p><p>当日志记录从内存刷新到磁盘时，flushedLSN就会被更新为最新的LSN</p></li><li><p>pageLSN</p><p>当一个page被更新时，该页的pageLSN就得被更新为该更新操作对应的LSN</p></li></ul><p>基本的日志布局大概如图所示</p><p><img src="2.png" alt="2"></p><h3 id="Normal-Execution"><a href="#Normal-Execution" class="headerlink" title="Normal Execution"></a>Normal Execution</h3><p>首先讨论以下在普通执行过程中ARIES是怎么运作的，为了保持简单，首先给出一些前提条件</p><ul><li><p>所有日志记录都能放进一个 page 中</p></li><li><p>写一个 page 到磁盘能保持原子性</p></li><li><p>没有 MVCC，使用严格的 2PL</p></li><li><p>使用 WAL 记录操作日志，buffer pool policy 为 Steal + No-Force</p></li></ul><h4 id="Transaction-Commit"><a href="#Transaction-Commit" class="headerlink" title="Transaction Commit"></a>Transaction Commit</h4><p>正常提交过程如下：</p><ol><li>更新page, 记录日志到内存的WAL区域，同时更新page的pageLSN</li><li>事务提交，记录<COMMIT>日志到WAL区域，将所有<COMMIT>之前的日志记录刷新到磁盘</li><li>事务结束，记录<TXN-END>日志到WAL区域，此时不需要立即刷盘</li></ol><p><img src="3.png" alt="3"></p><h4 id="Transaction-Abort"><a href="#Transaction-Abort" class="headerlink" title="Transaction Abort"></a>Transaction Abort</h4><p>在事务回滚过程中，需要引入一个新的LSN变量<code>prevLSN</code>，每个日志记录都会包含该字段，该字段保存着该日志记录的<strong>同一个事务</strong>的前一条日志记录，事务的首条日志记录的该字段设置为<code>nil</code></p><p><img src="4.png" alt="4"></p><p>事务发生回滚的流程如下：</p><ol><li><p>更新page, 记录日志到内存的WAL区域，同时更新page的pageLSN</p></li><li><p>事务回滚，记录<ABORT>日志记录到内存的WAL区域</p></li><li><p>沿着<code>preLSN</code>构成的链表，从WAL的终止位置开始，向前进行回滚(undo)操作</p><p>在回滚过程中，同样得需要记录回滚操作本身的日志，这些日志被称为<strong>补偿日志记录(Compensation Log Record, CLR)</strong></p><p>这些日志记录只会在redo操作中使用到，因此也被称为<code>redo-only</code>日志记录</p><p>在CLR中还有一个额外的字段，被称为<code>UndoNextLSN</code>字段，该字段记录了事务被回滚时，下一个需要被撤销的日志记录的LSN</p><p><img src="5.png" alt="5"></p></li><li><p>直到prevLSN为<code>nil</code>为止，回滚结束，在WAL上记录<TXN-END>日志记录</p><p><img src="6.png" alt="6"></p></li></ol><h3 id="Checkpointing"><a href="#Checkpointing" class="headerlink" title="Checkpointing"></a>Checkpointing</h3><p>接下来介绍几种不同的<code>checkpoint</code>机制</p><h4 id="Blocking-Checkpoints"><a href="#Blocking-Checkpoints" class="headerlink" title="Blocking Checkpoints"></a>Blocking Checkpoints</h4><p>之前所讨论过的checkpoint就是这种方法，该方法具体会分为几个步骤</p><ul><li>阻止新事务产生</li><li>等待当前的活跃事务做完他们正在执行的更新操作</li><li>将脏页刷新回磁盘</li></ul><p>该方法会在第二个步骤中产生较长的间断，在该间断时间内数据库是不会有任何更新的，这是不能接受的</p><h4 id="Slightly-Better-Blocking-Checkpoints"><a href="#Slightly-Better-Blocking-Checkpoints" class="headerlink" title="Slightly Better Blocking Checkpoints"></a>Slightly Better Blocking Checkpoints</h4><p>可以使用一些优化策略来对上面的checkpoint机制进行改进，改进后的方法如下</p><ul><li>阻止新事物产生</li><li>暂停所有处于活跃状态的事务</li></ul><p>这样做就不会产生间断，但是需要系统额外的维护一些信息，具体就是两个table</p><p><strong>活跃事务表(Active Transaction Table, ATT)</strong></p><p>当DBMS执行checkpoint时，会将此事系统中所有处于活跃的事务都记录在该表中，具体包含以下字段</p><ul><li><p>事务ID(txnId)</p></li><li><p>事务状态(Status)</p><p>可取的状态如下:</p><p><img src="7.png" alt="7"></p></li><li><p>lastLSN:事务最后执行的更新操作对应的LSN</p></li></ul><p>在checkpoint执行完之后，每当事务提交或中止，就会将事务从该表中移除</p><p><strong>脏页表(dirty page table, DPT)</strong></p><p>该表的作用是跟踪buffer pool中那些正处于dirty状态的page,具体包含以下字段</p><ul><li>dirty page id</li><li>recLSN: 导致page变为dirty的第一次更新操作对应的LSN</li></ul><p>下面是一个该机制下checkpoint的例子</p><p><img src="8.png" alt="8"></p><h4 id="Fuzzy-CheckPoint"><a href="#Fuzzy-CheckPoint" class="headerlink" title="Fuzzy CheckPoint"></a>Fuzzy CheckPoint</h4><p>Fuzzy CheckPoint是ARIES协议中使用的checkPoint机制，该机制允许任何事务在checkPoint线程在进行dirty page刷盘时同时进行自己的更新操作，其将checkPoint表示成了一个区间</p><p><img src="9.png" alt="9"></p><ul><li>&lt;CHECKPOINT-BEGIN&gt;: 表示系统开始刷盘</li><li>&lt;CHECKPOINT-END&gt;：表示checkPoint刷盘结束，此时会将&lt;CHECKPOINT-BEGIN&gt;对应的LSN刷新到磁盘的<code>masterRecord</code>当中</li></ul><p>注意，在&lt;CHECK-BEGIN&gt;与&lt;CHECK-END&gt;之间的任何新开始的事务都不会被添加到ATT,而DPT则正常</p><h3 id="Recovery-Phases"><a href="#Recovery-Phases" class="headerlink" title="Recovery Phases"></a>Recovery Phases</h3><p>ARIES的恢复算法分为三步：</p><ul><li>分析阶段(analysis)：从 WAL 中读取最近一次 checkpoint，找到 buffer pool 中相应的脏页以及故障时的活跃事务</li><li>重做阶段(redo)：从正确的日志点开始重做所有操作，包括将要中止的事务</li><li>撤销阶段(undo)：将故障前未提交的事务的操作撤销</li></ul><p>下面是整个的流程框图</p><p><img src="10.png" alt="10"></p><h4 id="Analysis-Phase"><a href="#Analysis-Phase" class="headerlink" title="Analysis Phase"></a>Analysis Phase</h4><ul><li>从最近的&lt;CHECKPOINT-BEGIN&gt;开始(从masterRecord中读取)，向下遍历WAL<ul><li>如果发现&lt;TXN-END&gt;, 将该事务从ATT中移除</li><li>否则将其添加进ATT(如果之前ATT中不存在的话)<ul><li>如果记录的类型为&lt;COMMIT&gt;, 那么将ATT中事务状态设置为<code>commit</code></li><li>如果记录类型为其它，那么将ATT中事务状态设置为<code>undo</code></li></ul></li><li>特别的，如果发现记录类型为&lt;UPDATE&gt;, 并且DPT中没有该page, 那么将该page添加进DPT, 然后将其recLSN = LSN</li></ul></li></ul><p><img src="11.png" alt="11"></p><p><img src="12.png" alt="12"></p><p>注意这里是分析阶段而不是checkpoint，可以将T96加入ATT</p><p><img src="13.png" alt="13"></p><p>当分析阶段结束时</p><ul><li>ATT 告诉 DBMS 在发生故障时，哪些事务是活跃的</li><li>DPT 告诉 DBMS 在发生故障时，哪些脏数据页可能尚未写入磁盘</li></ul><h4 id="Redo-Phase"><a href="#Redo-Phase" class="headerlink" title="Redo Phase"></a>Redo Phase</h4><p>该阶段的目的是将数据库恢复成crash之前的状态，所以需要进行重复历史(包括CLRS)，ppt中可能会进行冗余redo的情况，即数据已经被刷新回磁盘但是再次刷新，教材中给出了避免冗余的方法</p><p>从 DPT 中找到最小的 recLSN，从那里开始重做更新记录和 CLR</p><p> <img src="14.png" alt="14"></p><p>redo的具体操作包括：</p><ul><li>将数据项设置为新值</li><li>将page的<code>pageLSN</code>设置为LSN</li></ul><p>在<code>Redo Phase</code>的最后，为ATT表中的每个状态为<code>commiting</code>的事务追加上<COMMI>日志记录，然后将它们从ATT表中移除</p><h4 id="Undo-Phase"><a href="#Undo-Phase" class="headerlink" title="Undo Phase"></a>Undo Phase</h4><p>该阶段的目的在于回滚那些在crash时仍然处于活跃状态的事务，即ATT中那些状态为<code>U</code>的事务</p><p>利用lastLSN,倒序进行undo操作，每次进行undo操作，同样需要进行CLR的记录</p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p><strong>一些问题</strong></p><ul><li><p>如果 DBMS 在故障恢复的 Analysis Phase 崩溃怎么办？</p><p>再执行一次故障恢复算法就好</p></li><li><p>如果 DBMS 在故障恢复的 Redo Phase 崩溃怎么办？</p><p>再执行一次故障恢复算法就好</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:日志恢复系统</title>
    <link href="/2022/02/13/CMU15445-%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/02/13/CMU15445-%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="Crash-Recovery"><a href="#Crash-Recovery" class="headerlink" title="Crash Recovery"></a>Crash Recovery</h3><p><strong>崩溃恢复</strong>是数据库中必不可少的组成部分，它用于将数据库恢复至故障发生之前的一致性状态，为了确保数据库的一致性，原子性以及持久性，就必须要使用<strong>恢复算法</strong>，恢复算法由两部分组成</p><ul><li>在进行普通事务处理时，需要维护额外的数据，如日志，这样可以在后续崩溃时的恢复操作中使用到  ——&gt;(接下来的内容)</li><li>在数据库发生崩溃时，为了维护数据库的一致性、原子性、持久性，所采取的动作</li></ul><p>在崩溃恢复操作中需要使用到的两个关键步骤被称为<strong>redo(重做)<strong>和</strong>undo(撤销)</strong></p><ul><li><p>redo</p><p>将事务更新过的值都重新置为<strong>新值</strong></p></li><li><p>undo</p><p>将事务更新过的值都置为<strong>旧值</strong></p></li></ul><h3 id="Failure-Classification"><a href="#Failure-Classification" class="headerlink" title="Failure Classification"></a>Failure Classification</h3><p>系统中可能会发生多种故障</p><ul><li><p>事务故障</p><p>有两种错误可能造成事务执行失败</p><ul><li><p>逻辑错误</p><p>如事务违反了完整性约束</p></li><li><p>系统错误</p><p>如系统进入了死锁</p></li></ul></li><li><p>系统崩溃</p><ul><li><p>软件错误</p><p>如内部发生的除0的操作，系统必须停止运行</p></li><li><p>硬件错误</p><p>如系统断电了，同样会引起系统的停止</p></li></ul><p>上面的错误会到导致系统停止运行，进而导致内存中的数据丢失，在这里我们做出假设，认为这些错误不会导致磁盘上面的数据丢失，这也被称作<code>fail-stop</code>假设</p></li></ul><p>上面两种故障均可以进行恢复</p><ul><li><p>磁盘故障</p><p>磁盘发生了故障，那么这种故障就是不可恢复的</p></li></ul><h3 id="Buffer-Pool-Management-Policies"><a href="#Buffer-Pool-Management-Policies" class="headerlink" title="Buffer Pool Management Policies"></a>Buffer Pool Management Policies</h3><p>接下来将会介绍DBMS在进行事务处理时有关buffer pool的一些细节</p><ul><li><p>抢占策略</p><p>如果一个<strong>未提交(活跃)<strong>状态的事务修改过的块可以被写入到磁盘，那么就称该策略为</strong>抢占(steal)策略</strong>,否则被称为<strong>非抢占策略</strong></p><p><img src="1.png" alt="1"></p></li><li><p>强制策略</p><p>如果事务在提交时会强制将所有修改过的块都输出到磁盘，那么该策略被称为<strong>强制(force)策略</strong>，否则被称为<strong>非强制策略</strong></p><p><img src="2.png" alt="2"></p><p>当使用强制策略时，进行崩溃恢复操作时比较简单，因为不需要考虑<em>提交后数据丢失</em>的情况，但是使用强制策略会导致<strong>频繁的块的输出操作</strong>，使得其在运行时的效率比较低，大多数系统采用的是非强制策略</p></li><li><p>No-Steal + Force</p><p>最简单的崩溃恢复方法就是采用: <strong>No-Steal + Force</strong>策略来实现，下面给出例子</p><p><img src="3.png" alt="3"></p><p>上面是初始状态，经过两次write操作(A=3, B=8)之后变为了下面这样</p><p><img src="4.png" alt="4"></p><p>下一步是T2的commit操作，但是<code>Force</code>策略与<code>No-Steal</code>策略在此产生了矛盾，<code>No-Steal</code>策略要求不能将T1修改过的块写入到磁盘，而<code>Force</code>策略则要求必须将T2修改过的块在此时输出到磁盘，此时就会发生下面这种情况</p><p><img src="5.png" alt="5"></p><p>DBMS会拷贝一个新的tuple，其中只包含T2事务修改的数据，然后将其写回磁盘</p><ul><li>优缺点分析<ul><li>不需要使用<code>undo</code>操作，因为未提交的数据根本就没有输出到磁盘</li><li>不需要使用<code>redo</code>操作，因为所有提交的数据都被写入到了磁盘</li><li>限制1：如果一个事务所需要的数据不能够全部放入内存当中，那么该事务在这种策略下就不能够执行，因为该策略要求在事务提交之前不能够将脏page写回磁盘</li><li>限制2：如果事务更新了多个page(假设为4个), 由于操作系统无法为我们保证多个page写回磁盘这步操作的原子性，因此假设在将2个page写回磁盘过后系统崩溃，那么就会发生更新撕裂的问题</li></ul></li></ul></li></ul><h3 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h3><p><strong>影子分页</strong>计数采用页表拷贝的方式来保证数据库的崩溃可恢复性，这是一个No-Steal + Force策略的实现</p><p>在该技术当中，有两个页表:<strong>master page table, shadow page table</strong>，还有一个单独的<strong>DB Root</strong> page, 指向<code>master page table</code>整体布局如图所示</p><p><img src="6.png" alt="6"></p><p><code>shadow page table</code>是<code>master page table</code>的一分拷贝，当事务对page进行修改的时候，DBMS就会拷贝一份新的page, 并修改<code>shadow page table</code>上的指针，对这份拷贝page应用事务的修改，当事务的write操作结束并且执行commit之后，就会更改<code>DB Root</code>， 使之指向<code>shadow page table</code>, 即<code>shadow page table</code>代替了原来的<code>master page table</code></p><p><img src="7.png" alt="7"></p><ul><li><p>综合分析</p><ul><li><p>当发生崩溃时回滚十分简单</p><p>undo: 移除所有的shadwo page</p><p>redo: 不需要</p></li><li><p>缺点</p><ol><li><p>拷贝整个<code>page table</code>的代价比较昂贵</p></li><li><p>commit代价过高</p><p><code>DB Root</code>, <code>shadow page table</code>, 被更新的所有page，都需要被刷新回磁盘</p></li></ol></li></ul></li></ul><h3 id="Journal-File"><a href="#Journal-File" class="headerlink" title="Journal File"></a>Journal File</h3><p>SQLite在2010年之前使用过一种被称作<strong>Journal File</strong>的方案，该方案中，当事务修改一个page的时候，首先将其拷贝到磁盘中一个被称作<code>journal file</code>的地区，如果事务执行过程中发生了崩溃，就会检查<code>journal file</code>中是否有page存在，如果有，就会使用这些page来进行undo操作</p><p><img src="8.png" alt="8"></p><p><img src="9.png" alt="9"></p><p><img src="10.png" alt="10"></p><p><img src="11.png" alt="11"></p><h3 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h3><p><strong>先写日志(WAL)<strong>协议要求在主存中的数据块输出到数据库磁盘</strong>之前</strong>，与该数据块有关的所有日志记录必须首先输出到磁盘(稳定存储器)上, 通常是一个<code>log file</code>, 这是一个Steal + No-Force的例子</p><p><strong>几乎所有的主流数据库系统都在使用这个协议</strong>，因为该协议具有最快的运行时速度，但是WAL恢复的时长要比<code>Shadow Paging</code>稍微慢一点</p><ul><li><p>日志记录</p><p>一个日志记录具有一些字段</p><ul><li>Transaction Id (事务 id)</li><li>Object Id (数据记录 id)</li><li>Before Value (修改前的值)，用于 undo 操作</li><li>After Value (修改后的值)，用于 redo 操作</li></ul><p>故一条日志记录看起来像这样<code>&lt;Ti, Xj, V1, V2&gt;</code></p><p>与此同时还有一些其他的日志记录：</p><ul><li>&lt;Ti start&gt;: 事务开始</li><li>&lt;Ti commit&gt;: 事务提交 </li><li>&lt;Ti abort&gt;: 事务中止</li></ul></li><li><p>例子</p><p><img src="12.png" alt="12"></p><ul><li>当事务执行时，每执行一条语句对数据项进行修改，就会在<code>WAL Buffer</code>中保存指定的记录，然后再修改buffer pool中数据项的值</li><li>当事务执行到commit语句的时候，就会将<code>WAL Buffer</code>中的内容写到磁盘的<code>log file</code>中,此时整个事务就算是提交了</li><li>尽管数据项还没有被刷新会磁盘，但是磁盘中已经有相应的日志了，即使发生了崩溃，也能够根据log file进行恢复</li></ul></li><li><p>group commit</p><p>在上面的方案中，每次有一个事务进行提交时就会将<code>WAL Buffer</code>中的内容刷新回<code>log file</code>中，可以使用一种被称为<strong>group commit</strong>的优化策略，在该策略当中，<code>WAL Buffer</code>设置为两个，刷盘的时机变为：</p><ol><li><p><code>WAL Buffer</code> 满时刷盘</p><p>当一个<code>WAL Buffer</code> 满了的时候，就会将其刷盘，与此同时，日志记录都保存在另一个<code>WAL Buffer</code>中</p><p><img src="13.png" alt="13"></p></li><li><p>超过指定时间</p><p>有时<code>WAL Buffer</code>可能还没有满，但是所有的事务都在处于等待状态，此时如果超过了一定的时间段，<code>WAL Buffer</code>也会自动刷新</p></li></ol></li><li><p>效率分析</p><p><img src="14.png" alt="14"></p><p>大部分数据库更看重运行时效率，因此几乎所有 DBMS 使用 No-Force + Steal 的 buffer pool policy</p></li></ul><h3 id="Logging-Scheme"><a href="#Logging-Scheme" class="headerlink" title="Logging Scheme"></a>Logging Scheme</h3><p>在这里我们会介绍关于日志记录的不同形式，通常有两种日志记录的方案：<strong>physical logging</strong>, <strong>logical logging</strong></p><ul><li><p>physical logging</p><p>在该模式下的日志记录记录的是底层数据的修改</p></li><li><p>logical logging</p><p>该模式下记录的是SQL语句逻辑上的修改</p></li></ul><p>下面是一个例子</p><p><img src="15.png" alt="15"></p><p>注意到上面的例子中还有关于索引信息的日志，事实上，大多数数据库系统也会为索引的修改记录日志</p><ul><li><p>优缺点</p><p><code>Logical Scheme</code>所记录的字节数更少，但是一个问题就是假设使用一个update语句更新了大量tuple,那么在进行redo的时候就必须重新执行一遍该update语句，因为我们不知道update语句的实际更新究竟写入了多少数据到磁盘，而使用<code>Physical Scheme</code>就不会有这种情况 </p></li></ul><p>当今大多数数据库使用的是一种混合模式，被称为<strong>Physiological Scheme</strong></p><p><img src="16.png" alt="16"></p><p>可以看到，该模式下记录了一些底层的<code>page_id</code>, 但使用了<code>slot_id</code>这种逻辑单位而不是<code>offset</code></p><h3 id="Check-Point"><a href="#Check-Point" class="headerlink" title="Check Point"></a>Check Point</h3><p>如果放任 WAL 增长，它可以随着新的操作执行而无限增长。如此这般，在故障恢复时，DBMS 需要读取更多的日志，执行更多的恢复和回滚操作。为了避免这种情况出现，DBMS 需要周期性地记录 checkpoint，即将所有日志记录和数据页都持久化到存储设备中，然后在日志中写入一条 <code>&lt;CHECKPOINT&gt;</code> 记录，举例如下：</p><p><img src="17.png" alt="17"></p><p>当 DBMS 发生崩溃时，所有在最新的 checkpoint 之前提交的事务可以直接忽略，如 T1。T2 和 T3 在 checkpoint 前尚未 commit。其中，T2 需要 redo，因为它在 checkpoint 之后，crash 之前提交了，即已经告诉用户事务提交成功；T3 需要 undo，因为它在 crash 之前尚未 commit，即尚未告诉用户事务提交成功。</p><p>实现 checkpoints 有需要要考虑的问题：</p><ol><li>在于要保证 checkpoint 的正确性，我们需要暂停所有事务</li><li>故障恢复时，扫描数据找到未提交的事务可能需要较长的时间</li><li>如何决定 DBMS 执行 checkpoint 的周期，太频繁将导致运行时性能下降；等太久将使得 checkpoint 的内容更多，更耗时，同时数据恢复也要消耗更长的时间</li></ol><p><strong>Conclusion</strong></p><p>WAL几乎总是最佳选择</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:多版本并发控制</title>
    <link href="/2022/02/12/CMU15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/02/12/CMU15445-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Multi-Version-Concurrency-Control"><a href="#Multi-Version-Concurrency-Control" class="headerlink" title="Multi-Version Concurrency Control"></a>Multi-Version Concurrency Control</h3><p><strong>多版本并发控制机制(MVCC)<strong>当今被广泛应用于数据库当中，使用该机制的DBMS会为每个数据项维护多个</strong>版本</strong>，当对数据项进行操作时，遵循两个基本原则</p><ol><li>当事务对数据项进行read操作的时候，DBMS会返回该事务开始执行时数据库中最新的数据项版本</li><li>当事务对数据项进行write操作的时候，DBMS会创建一个新的数据项版本</li></ol><p>该机制的一个重要特性就是<strong>读写操作互不阻塞</strong>，而这个特性与<strong>快照隔离</strong>机制分不开</p><p>当事务进入数据库的时候，会获得一份数据库的<strong>快照(snapshot)<strong>，而这个快照是一份数据库中</strong>已经提交</strong>的事务所写的值的拷贝，这意味着事务不会读取到其他未提交事务对数据项所做的修改，事务在这个快照上以<strong>完全隔离</strong>的方式和其他事务进行操作，对于只读事务来说，就完全不需要进行等待(试想在2PL中，为了保证可串行化, read操作需要首先获取共享锁)</p><p>由于写写(WW)操作可能会引发冲突，所以在事务提交之前，同样需要进行有效性检查，如果有效性检查通过，那么就</p><ol><li>将事务变为提交状态</li><li>然后写入数据库</li></ol><p>这两步是一个原子操作</p><h3 id="Version-Storage"><a href="#Version-Storage" class="headerlink" title="Version Storage"></a>Version Storage</h3><p>接下来将会介绍数据库是是怎样存储数据项的物理版本</p><p>通常DBMS会为每一个tuple设置一个**版本列表(version chain)**，所有索引的指针(叶子结点上的指针)指向的都是链表的头部，总共有三种可选的存储方法</p><ul><li><p>Append-Only-Storage</p><p>在该方法当中，所有tuple的版本都会被存储在一个表当中</p><p><img src="1.png" alt="1"></p><p>链表存储版本的顺序也有一些区别</p><ul><li><p>Oldest-To-Newest(OTN)</p><p>每次将新版本附加在链表尾部，这样做的话当每次获取最新版本时都得遍历一遍链表</p></li><li><p>Newest-To-Oldest(NTO)</p><p>每次将新版本放在链表头部，这样做每次更新版本是都被更新所有指向该链表的索引的指针</p></li></ul></li><li><p>Time-Travel-Storage</p><p>该方法中维护了两个表，一个表(<strong>main table</strong>)放当前数据项版本，另一个表(<strong>time-travle table</strong>)放之前的旧版本，每次更新版本时，就将当前版本拷贝到<code>time-travle table</code>当中，将新版本放入<code>main table</code>中</p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p></li><li><p>Delta-Storage</p><p>该方法中同样也使用了两个表，一个表中存储当前的最新版本，另一个表中存储版本之间的差异</p><p><img src="4.png" alt="4"></p><p>该方法在大数据量的表中有不错的优化效果</p></li></ul><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><p>由于每次使用write操作都会创建新版本，因此随着时间的推移，版本数目也会越来越多，势必要进行旧版本的清除操作</p><ul><li><p>tuple级的垃圾回收</p><p>该方法通过直接查看page中的tuple来检查这些tuple的版本，具体有两种方案</p><ul><li> Background Vacuuming</li></ul><p>  使用一些定时执行的清除线程来扫描表，清除那些可以回收的版本，该方法适用于所有的存储模型</p><p>  <img src="5.png" alt="5"></p><p>  <img src="6.png" alt="6"></p><p>  一种可选的优化方法是使用一个<code>dirty page map</code>,当page中的tuple的旧版本需要被清除时，就将该map中的指定page设置为<code>dirty</code>, 当<code>dirty page map</code>中的<code>dirty page</code>到达一定比例之后，DBMS就会开启清除线程对这些page进行清理操作</p><ul><li><p>Cooperative Cleaning</p><p>该方法中那些worker threads在对版本链表进行遍历的时候，顺便找出那些可以被回收的旧版本，该方法仅适用于O2N</p><p><img src="7.png" alt="7"></p><p><img src="8.png" alt="8"></p><p><img src="9.png" alt="9"></p></li></ul></li><li><p>事务级别的垃圾回收</p><p>每个事务都会维护<code>write set</code>和<code>read set</code>, 在事务进行提交的时候，垃圾回收器会通过事务的<code>write/read set</code>来进行垃圾回收的判断 </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:基于时间戳的协议</title>
    <link href="/2022/02/09/CMU15445-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/02/09/CMU15445-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="Timestamp-Ordering-Concurrency-Control"><a href="#Timestamp-Ordering-Concurrency-Control" class="headerlink" title="Timestamp Ordering Concurrency Control"></a>Timestamp Ordering Concurrency Control</h3><p><strong>基于时间戳的并发控制协议</strong>是一个<strong>乐观</strong>的并发控制协议，这意味着该协议不需要锁来保护底层数据结构，在该协议当中，DBMS使用时间戳来决定事务的冲突事务的调度</p><ul><li><p>时间戳</p><p>在该协议当中，每个事务都会被分配一个时间戳，通常使用函数<code>TS()</code>来计算一个事务的时间戳，这个时间戳有以下特征</p><ul><li>是单调递增的</li><li>是独一无二的</li></ul><p>如果<code>TS(T_i)</code> &lt; <code>TS(T_j)</code>，那么DBMS就必须确保事务的调度与<code>T_i</code>排在<code>T_j</code>之前的串行调度冲突等价</p><p>时间戳不一定非要根据系统时间来定，可以使用多种方法来计算一个事务的时间戳</p><ol><li><p>系统时钟</p><p>系统时钟是最简单的方法，但是有着一些缺点</p><ul><li>分布式数据库中，无法确保不同机器的系统时钟完全同步</li><li>系统的时钟可以回调(如国外的夏令时)，可能会导致时间戳发生混乱</li></ul></li><li><p>逻辑计数器</p><p>在系统内部维护一个计数器，每当创建一个新的事务时，计数器就会递增</p><p>这种方法的问题是如果使用一个<code>int</code>型数据来保存这个计数器，事务量大的话就会导致数据移溢</p></li><li><p>以上两种方法混合</p><p>这是现代数据库常用的方法</p></li></ol></li></ul><h3 id="Basic-Timestamp-Ordering-BASIC-T-O"><a href="#Basic-Timestamp-Ordering-BASIC-T-O" class="headerlink" title="Basic Timestamp Ordering (BASIC T/O)"></a>Basic Timestamp Ordering (BASIC T/O)</h3><p>基本时间戳协议为每个数据项<code>X</code>维护一对时间戳：</p><ul><li><p>W-TS(X)</p><p>成功执行<code>Write(X)</code>的任意事务的最大时间戳</p></li><li><p>R-TS(X)</p><p>成功执行<code>Read(X)</code>的任意事务的最大时间戳</p></li></ul><p>该协议的基本思想就是: <strong>如果事务即将访问的数据项”来自未来”, 那么该事务回滚</strong>，具体协议如下</p><p><img src="1.png" alt="1"></p><p>注意每次回滚的时候会赋予新的时间戳，这样可以避免<strong>饥饿问题</strong></p><ul><li><p>例</p><p>下面例子中,T1的时间戳是1，T2的时间戳是2</p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p></li><li><p>Thomas写规则</p><p>该规则是一种基于基本时间戳协议的一种优化，考虑如下情况, 假设TS(T27) &lt; TS(T28)</p><p><img src="4.png" alt="4"></p><p>在该例子当中，在基本时间戳协议下，T27的<code>write(Q)</code>操作会发生回滚，如果数据库直接将该操作忽略，最终在数据库中呈现的效果也是一样的，即Q的值是T28所写，综上，Thomas写规则如下</p><p><img src="5.png" alt="5"></p><p>可以看出，只是第二条规则发生了变化而已</p><p>Thomas写规则允许<strong>非冲突可串行化</strong>但是正确的调度，这为调度增加了更多选择</p></li></ul><p><strong>基本时间戳排序协议</strong>有以下优缺点</p><ul><li><p>优点</p><ul><li><p>确保了可串行化</p></li><li><p>避免了死锁，因为没有事务会发生等待</p></li></ul></li><li><p>缺点</p><ul><li><p>可能会造成长事务的<strong>饥饿问题</strong></p></li><li><p>需要拷贝数据到事务的工作空间</p></li><li><p>需要不断更新时间戳</p></li><li><p>可能会产生<strong>不可恢复</strong>的调度</p><ul><li><p>可恢复事务</p><p>当一个事务仅在它所依赖的所有事务都提交之后才提交时，那么就称该事务为可恢复事务，下面是一个不可恢复事务的例子</p><p><img src="6.png" alt="6"></p><p>T2依赖于T1,但是其却在T1之前提交，如果T1在此之后终止了，那么T2的操作就无法恢复了，上面给出的也是一个脏读的例子</p></li></ul></li></ul></li></ul><h3 id="Optimistic-Concurrency-Control-OCC"><a href="#Optimistic-Concurrency-Control-OCC" class="headerlink" title="Optimistic Concurrency Control (OCC)"></a>Optimistic Concurrency Control (OCC)</h3><p><strong>乐观并发控制</strong>协议使用于冲突比较少的数据库当中，在该协议当中，DBMS为每一个事务都创建了一个<strong>私有工作空间(private worksace)</strong>, 在该空间当中</p><ol><li>所有的修改都会在这个空间进行</li><li>任何被事务所读的数据项都会被拷贝到私有工作空间</li><li>私有工作空间中的数据只有事务本身能够读</li></ol><p>在OCC中，整个事务被分为了三个阶段</p><ul><li><p>Read Phase</p><p>该阶段中，事务会将所有需要的数据拷贝到私有工作空间当中，然后对其应用自己的修改操作，各个事务之间互不影响</p></li><li><p>Validation Phase</p><p>该阶段中，会进行有效性检查，检查该事务是否与其它事务发生了冲突，<strong>在该阶段事务会获取到他们的时间戳</strong></p></li><li><p>Write Phase</p><p>如果没有冲突的话，在事务私有空间中的所有修改应用到数据库上，否则，终止并且重启事务</p></li></ul><p>三个阶段的重点在于第二阶段</p><p><strong>Validation Phase</strong></p><p>在该阶段当中，需要保证事务的调度是冲突可串行化的，DBMS通常会具有一个全局的视野，以获取所有事务的状态</p><p>通常有两种方式来进行这种有效性的检查</p><ol><li>Backward Validation</li><li>Forward Validation</li></ol><ul><li><p>Backward Validation</p><p><img src="7.png" alt="7"></p><p>该方法中，在每个事务进行提交的时候，会找到与自己并行并且已经提交过的事务</p><p>在上面的例子中，<code>Txn #1</code>先Commit, 所以<code>TS(#1) &lt; TS(#2)</code>, 即在串行化顺序当中，<code>Txn #1</code>应该比<code>Txn #2</code>先执行，但是在他们的并行执行过程中，假设<code>Txn #2</code>执行完Read(X)操作之后，<code>Txn #1</code>执行Write(X), 那么<code>Txn #2</code>读到的就是一个无效的数据，因此需要进行检查</p></li><li><p>Forward Valdation</p><p>Froward Valdation与Backward Valdation十分相似, 只不过方向相反而已</p><p><img src="8.png" alt="8"></p></li></ul><p>注意: 在Valdation 阶段要么统一使用<code>Backward Valdation</code>要么统一使用<code>Forward Valdation</code></p><ul><li><p>两个事务之间进行有效性检查的具体方法</p><p>令<code>TS(Ti) &lt; TS(Tj)</code>,那么仅当下面三个条件的其中一个满足时Validation Phase才能通过</p><ol><li><p>Ti在Tj开始之前就已经完成所有三个阶段</p><p><img src="9.png" alt="9"></p><p>很显然这样做满足串行化</p></li><li><p>Ti在Tj的<code>Write Phase</code>开始之前就已经完成，并且Ti的write set与Tj的read set在此时交集为空集</p><p><img src="10.png" alt="10"></p><ul><li><p>例子</p><p><img src="11.png" alt="11"></p><p>在上面的例子中，T1先进行有效性检查，此时T1的<code>write set</code>是{A}, T2的<code>read set</code> 是{A}, 交集不为空，所以T1中止</p></li></ul></li><li><p>Ti的Read阶段比Tj的Read阶段先完成，并且Ti的<code>write set</code>与Tj的<code>write set</code>以及Tj的<code>read set</code>的交集均为空集</p><p><img src="12.png" alt="12"></p><ul><li><p>例子</p><p><img src="13.png" alt="13"></p><p>在这个例子当中，T1的有效性检查阶段的<code>write set</code>为{A}, T2的有效性检查阶段的<code>read set</code>为{B}, <code>read set</code>为空，故有效性检查通过</p></li></ul></li></ol></li><li><p>性能分析</p><p>OCC适用于冲突较少的数据库中，在这些数据库中它工作的很好，但其仍有着一些性能上的问题</p><ul><li><p>将数据拷贝到每个事务的私有工作空间导致大量工作负载</p></li><li><p>Validation/Write 阶段的工作瓶颈</p><p>实际上，尽管在OCC中没有使用到lock，但是仍然会使用到物理上的latch, 当每个事务进行有效性检查的时候，都会去查看当前正与自己并行的事务的<code>write set</code>以及<code>read set</code>，这个过程仍然需要使用物理上的latch</p></li><li><p>回滚现象出现的更加频繁</p></li><li><p>时间戳的获取瓶颈</p></li></ul></li></ul><h3 id="Partition-Based-T-O"><a href="#Partition-Based-T-O" class="headerlink" title="Partition-Based T/O"></a>Partition-Based T/O</h3><p>该协议的基本思想是：<strong>将数据库分割为不相交的子集，称为分区(shards)，然后只检查在同一分区中运行的事务之间的冲突</strong></p><ul><li><p>每个分区都有一把单独的锁，同时也维护了一个事务<strong>队列</strong>，当事务需要访问该分区中的数据的时候，它需要进入该队列进行排队</p></li><li><p>在队列中是基于时间戳进行排队的，而时间戳是在事务请求被发送到数据库是获取的，只有时间戳最小的事务能够获取到分区的锁</p></li><li><p>一旦它获取到该分区上的锁，它就能够访问该分区上的所有数据，此时只有一个事务线程，不需要考虑并发，即没有lock和latch</p></li><li><p>但是一个事务可能不仅需要获取一个分区上的数据，所以仅当其获取到需要分区上的所有的锁的时候，事务才会开始执行</p></li><li><p>如果事务想要获取到分区上的数据，但是其并未拥有该分区上的锁，那么它就会终止然后重新启动</p></li></ul><p><img src="14.png" alt="14"></p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><ul><li><p>性能分析</p><p>当大部分事务只访问一个分区时，该方法会比较快速，当很多事务跨分区访问时，就会导致很多分区闲置</p><p>如果DBMS能够提前获知事务需要获取哪些分区上的lock,同样也能加快速度</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:两阶段锁</title>
    <link href="/2022/02/08/CMU15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81/"/>
    <url>/2022/02/08/CMU15445-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Two-Phase-Locking-Protocol"><a href="#Two-Phase-Locking-Protocol" class="headerlink" title="Two-Phase Locking Protocol"></a>Two-Phase Locking Protocol</h3><p>当一个调度遵循<strong>两阶段锁协议</strong>的时候，它就一定是冲突可串行化的，该协议将一个事务分成了两个阶段</p><ol><li><p>增长阶段(growing phase)</p><p>该阶段中一个事务可以获得锁，但不能释放任何锁</p></li><li><p>缩减阶段(shrinking phase)</p><p>该阶段中一个事务可以释放锁，但是不能获得任何新锁</p></li></ol><p>一个事务一开始时是处于增长阶段，一旦事务释放了锁，它就进入了缩减阶段，故一个事务的生命周期中锁的数量如图</p><p><img src="1.png" alt="1"></p><blockquote><p>封锁点：</p><p>一个事务最后获得锁的位置被称为封锁点</p></blockquote><ul><li><p>优点</p><p>两阶段锁保证了一个调度是冲突可串行化的，如今的数据库基本都支持两阶段锁协议</p></li><li><p>缺点</p><p>两阶段锁协议并不能避免<strong>脏读</strong>以及<strong>死锁</strong>的问题</p><ul><li><p>脏读</p><p><img src="2.png" alt="2"></p><p>上图所示的调度完全遵循两阶段锁协议，但是依旧发生了脏读现象，这就导致了如果$T_1$终止的话就会发生级联回滚，即$T_2$也得终止</p><ul><li>解决方案: Strong Strict 2PL</li></ul></li><li><p>死锁</p><p><img src="3.png" alt="3"></p><p>上图就是一个死锁的例子，同样也遵循两阶段锁协议</p></li></ul><p>除了以上两个调度外，一些不满足该协议但是满足冲突可串行化的调度就无法使用，可能会降低系统的并发性</p></li></ul><h3 id="Strong-Strict-Two-Phase-Locking-Protocol"><a href="#Strong-Strict-Two-Phase-Locking-Protocol" class="headerlink" title="Strong Strict Two-Phase Locking Protocol"></a>Strong Strict Two-Phase Locking Protocol</h3><p><strong>Strong Strict 2PL(SSPL)<strong>是2PL的变种，在该协议当中，</strong>仅当事务提交之后才会释放其拥有的锁</strong></p><p><img src="4.png" alt="4"></p><p>当称一个协议**严格(Strict)**时，那么在事务当中，如果一个数据项的值被修改，那么在该事务提交之前，不允许任何其它事务对该数据项</p><p>进行<strong>读</strong>写操作， 这避免了脏读，简化了级联回滚的过程，这样只需要将数据项恢复为旧值即可</p><h3 id="2PL-DeadLock-Handling"><a href="#2PL-DeadLock-Handling" class="headerlink" title="2PL DeadLock Handling"></a>2PL DeadLock Handling</h3><p>在数据库当中可能会发生死锁，有两种方法可以用于处理死锁问题: <strong>死锁检测与恢复</strong>，<strong>死锁预防</strong>，如果系统陷入死锁状态的概率较高，通常采用死锁预防机制，否则一般采用检测与恢复机制</p><ul><li><p>死锁检测</p><p>可以使用一种被称作**等待图(wait-for graph)**的有向图来判断是否发生了死锁，图中的每一个节点都是一个事务，若有$T_i$–&gt;$T_j$,那么$T_i$正等待$T_j$释放一个数据项，当等待图中出现了环时即表明出现了死锁</p><p><img src="5.png" alt="5"></p><p>在真实的数据库系统中，可以使用一个单独的线程，每个一段时间就利用系统系统的元数据来生成等待图，然后使用检测算法来判断是否有死锁，即等待图是否有环，检测的周期取决于两个因素</p><ol><li>死锁发生的频率如何</li><li>有多少事务将收到死锁影响</li></ol></li><li><p>死锁恢复</p><p>解除死锁最有效的方式就是进行事务回滚，通常会进行几个动作</p><ol><li><p>选择牺牲者</p><p>当多个事务之间产生死锁时，系统会根据以下要素来决定回滚哪个事务</p><ul><li>事务的执行进度</li><li>事务使用数据项的数量</li><li>事务使用锁的数量</li><li>回滚操作需要牵涉多少事务</li></ul></li><li><p>回滚</p><p>回滚可以选择<strong>全部回滚</strong>，即终止事务之后重新启动它，还可以使用<strong>部分回滚</strong>，即回滚到不会发生死锁的地方，当这样做需要系统维护额外的元数据</p></li><li><p>饥饿问题</p><p>回滚时还需要考虑事务饥饿问题，通常会将回滚次数也作为选择牺牲者的因素</p></li></ol></li><li><p>死锁预防</p><p>死锁预防的思想就是确保数据库不会发生死锁，这里有两种<strong>基于时间戳</strong>的死锁预防机制，这两种机制都基于同一个事实: <strong>越老优先级越高</strong></p><ol><li><p>wait-die(老的等待年轻的)</p><p>当事务$T_i$申请的数据项当前被$T_j$持有时，如果$T_i$的时间戳更小($T_i$更老), 那么$T_i$就可以等待，否则$T_i$直接回滚</p></li><li><p>wound-wait(年轻的等待老的)</p><p>当事务$T_i$申请的数据项当前被$T_j$持有时，如果$T_i$的时间戳更小($T_i$更老)，那么$T_j$直接回滚, $T_i$抢占其锁， 否则$T_i$等待</p></li></ol><p>当事务回滚时，处于<strong>饥饿问题</strong>的考虑，事务的时间戳应该和回滚前是一样的</p></li></ul><h3 id="Lock-Granularities"><a href="#Lock-Granularities" class="headerlink" title="Lock Granularities"></a>Lock Granularities</h3><p>接下来介绍一种关于数据库管理<strong>锁粒度</strong>的机制，被称为<strong>多粒度封锁协议</strong>，可以使用<strong>粒度树</strong>来展示系统中所用锁的粒度</p><p><img src="6.png" alt="6"></p><p>在上面这张图中，最上层是数据库级，第二层是area级，第三层是文件级，最后一层是record级，可以在这些节点上的任意一个节点上加锁，考虑通常模式的锁模式，在粒度树中，当给一个节点加锁的时候，所有子节点都会同时加上<strong>隐式锁</strong>，但这样会导致一个问题，假设<code>Fb</code>节点加上了互斥锁，那么当给<code>A1</code>加共享锁的时候就会失败，因为锁不相容，而这必须得靠数据库扫描整棵树才能知道能不能加锁，这样做反而失去了粒度树的意义，因此引入一种新的<strong>意向锁模式(intention lock mode)</strong></p><p>使用<strong>意向锁模式</strong>的意义是<strong>暗示子节点拥有的是怎样的锁</strong>，该模式中增加了新的三种锁</p><ol><li><p><strong>意向共享模式锁(IS)</strong></p><p>当一个节点加上该锁时，表明所有的字节点都显式加上了共享锁</p></li><li><p><strong>意向排他模式锁(IX)</strong></p><p>当一个节点加上该锁时，表明所有的子节点都显式加上了排他锁</p></li><li><p><strong>共享意向排他模式锁(SIX)</strong></p><p>当一个节点加上该锁时，所有的字节点都<strong>隐式</strong>加上了共享锁，其中某些子节点<strong>显式</strong>加上了排他锁</p></li></ol><p>下面是锁的相容矩阵</p><p><img src="7.png" alt="7"></p><p>当对一个节点加锁时，有很多限制</p><p><img src="8.png" alt="8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:并发控制理论</title>
    <link href="/2022/02/07/CMU15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
    <url>/2022/02/07/CMU15445-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="ACID-Atomic"><a href="#ACID-Atomic" class="headerlink" title="ACID: Atomic"></a>ACID: Atomic</h4><p>DBMS会保证事务的执行时原子的，即事务要么全部执行，要么全部不执行</p><p>有两种方法可以保证原子性：</p><ol><li><p>Shadow Paging</p><p>当DBMS需要修改page的时候，就会拷贝一份这些需要被改动的page的副本，然后在这些副本上应用事务进行修改，当事务提交之后，这些修改后的副本就会代替原来的page，该方法的成本很高，因此没有人使用</p></li><li><p>Logging</p><p>DBMS可以对所有的操作进行日志记录，这样就可以很方便的进行回滚，几乎所有的现代数据库系统都在使用日志</p></li></ol><h4 id="ACID-Isolation"><a href="#ACID-Isolation" class="headerlink" title="ACID: Isolation"></a>ACID: Isolation</h4><p>数据库提供给事务一种假象，让他们以为当前系统中只有自己一个事务正在运行，他们看不见其他正在并发执行的事务，而这，需要<strong>并发协议</strong>的帮助</p><ul><li><p>并发协议</p><p>并发协议有两种：</p><ol><li><p>悲观</p><p>认为事务总是会发生冲突，因此在这些事务执行之前，会首先要求他们获取锁</p></li><li><p>乐观</p><p>任务事务的冲突很少发生，所以一开始不加锁，当它们进行提交的时候，会检查在执行期间是否发生了事务冲突，仅当发生了冲突才会进行处理</p></li></ol></li><li><p>冲突可串行化(conflict serializability)</p><p>在介绍冲突可串行化之前需要了解一些概念</p><ul><li><p>指令冲突</p><p>如果<code>I</code>和<code>J</code>是由不同事务在<em>相同数据项</em>上执行的操作，并且其中至少有一条指令是write操作，那么我们说<code>I</code>和<code>J</code>是<strong>冲突</strong>的</p><p><img src="1.png" alt="1"></p><p>上图中，$T_1$的<code>write(A)</code>指令与$T_2$的<code>read(A)</code>指令就是冲突的</p></li><li><p>冲突等价</p><p>如果<code>I</code>和<code>J</code>是来自不同事务的指令并且他们并不冲突，那么就可以<em>交换</em>他们的次序来产生一个新的调度， 称这两个调度<strong>冲突等价</strong></p><p><img src="2.png" alt="2"></p><p>上图中的调度就与之前的调度等价</p></li><li><p>冲突可串行化</p><p>如果调度S和一个<em>串行调度</em>是冲突等价的，那么就称调度S是<strong>冲突可串行化</strong>的</p><p>上面的调度就是冲突可串行化的</p></li></ul><p>还可以使用**优先图(precedence graph)/依赖图(Dependency Graphs)**判断一个调度是否是冲突可串行化的</p><ul><li>每个顶点是一个事务，当两个事务之间有冲突的指令时，就在两个顶点之间连上一条边</li></ul><p><img src="3.png" alt="3"></p><p>指向的判断根据下面的三条法则确定$T_i$—-&gt;$T_j$</p><p><img src="4.png" alt="4"></p><ul><li>如果优先图中存在一条$T_i$–&gt;$T_j$的边，那么在等价于S的任何调度S’中，$T_i$都必须出现在$T_j$前面</li><li><strong>如果关于S的优先图有环，那么调度S是非冲突可串行化的，如果无环，那么S是冲突可串行化的</strong></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[数据库系统概念]:事务</title>
    <link href="/2022/02/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/02/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="事务-amp-ACID"><a href="#事务-amp-ACID" class="headerlink" title="事务 &amp; ACID"></a>事务 &amp; ACID</h3><ul><li><p>事务</p><p>事务是一个访问并可能更新数据项的一个程序执行单元，在SQL语句中，由<code>begin transaction</code>和<code>end transaction</code>之间的全部操作组成</p></li><li><p>ACID</p><p>数据库有着四大特性，被称为<strong>ACID特性</strong></p><p><img src="1.png" alt="1"></p></li></ul><h3 id="原子性与持久性"><a href="#原子性与持久性" class="headerlink" title="原子性与持久性"></a>原子性与持久性</h3><ul><li><p>事务状态机</p><p><img src="2.png" alt="2"></p><ul><li><p>活跃(active)</p><p>当一个事务开始执行时，就处于active状态</p></li><li><p>部分提交(partially commited)</p><p>当事务中的最后一条语句被执行之后，事务处于部分提交状态</p></li><li><p>失效(failed)</p><p>当事务不能继续正常执行时</p></li><li><p>中止(aborted)</p><p>当事务已经回滚并且数据库已经恢复到它在事务开始前的状态</p></li><li><p>提交(commited)</p><p>事务执行成功</p></li></ul><p>当事务处于中止状态或者提交状态时，也被称为**终止(terminated)**状态</p></li><li><p>回滚</p><p>当一个中止的事务造成的变更已经被撤销，我们就说该事务已<strong>回滚(roalled back)</strong>,通常是通过维护日志来达到这一个目的</p><p>当事务处于中止状态时，有两种方式对其进行处理</p><ul><li><p>重启</p><p>当引起事务中止的原因是由于硬件错误，就可以重启事务，重启的事务被看成一个新事务</p></li><li><p>杀死</p><p>如果事务中止的原因是由于内部的逻辑错误，那么就只能杀死事务了，因为重启之后依旧会导致事务中止</p></li></ul></li></ul><h3 id="事务的隔离性与原子性"><a href="#事务的隔离性与原子性" class="headerlink" title="事务的隔离性与原子性"></a>事务的隔离性与原子性</h3><p>允许多个事务并发地执行会引起许多数据一致性的复杂问题，如果坚持事务是<strong>串行</strong>执行的话将简单的多，但是并发执行可以很大程度上提高<strong>吞吐量</strong>，减少<strong>延迟</strong>，这导致有些数据库放弃了隔离性，允许事务并发执行</p><ul><li><p>调度</p><p>在允许并发执行的系统当中，如果一个事务$T_i$失效了，原子性要求依赖于$T_i$的任何事务$T_j$也要终止</p><p>为了确保这一点，需要控制系统中所允许调度的类型</p><ul><li><p>可/不可恢复调度</p><p>考虑如下调度</p><p><img src="3.png" alt="3"></p><p>如果在$T_6$执行完<code>read(B)</code>之后$T_6$终止，由于$T_7$读取了$T_6$所写入的数据，即$T_7$依赖于$T_6$,因此$T_7$也需要被终止，但是$T_7$已经commit,所以他不能够再终止，即这是一个<strong>不可恢复调度</strong></p><p>下面给出<strong>可恢复调度</strong>的定义:</p><p><strong>对于每对事物$T_i$和$T_j$,如果$T_j$读取了由$T_i$之前所写过的数据项，则$T_i$的提交操作应该出现在$T_j$的提交操作之前</strong></p></li><li><p>无级联调度</p><p>有时可能会发生多重依赖的情况</p><p><img src="4.png" alt="4"></p><p>在上面的例子当中，$T_8$终止导致$T_9$终止，$T_9$终止导致$T_10$终止，这种由于单个事务失效导致一系列事务回滚的现象被称为<strong>级联回滚</strong>，这在数据库中时不希望发生的，因为要消耗大量的工作</p><p>下面给出<strong>无级联调度</strong></p><p><strong>对于每对事物$T_i$和$T_j$都满足如果$T_j$读取了之前由$T_i$所写的一个数据项，则$T_i$的提交操作必须出现在$T_j$的这一读操作之前</strong></p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p></li></ul></li><li><p>并发执行中可能产生的问题</p><ul><li><p>脏读</p><p><strong>脏读</strong>指一个事务读取了另一个事务<em>未提交</em>的数据</p><p><img src="5_.png" alt="5"></p></li><li><p>不可重复读</p><p><strong>不可重复读</strong>指在一个事务内读取表中的某一行数据，多次读取结果不同。 不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据</p><p><img src="6_.png" alt="6"></p></li><li><p>幻读</p><p><strong>幻读</strong>指读取到了别的事务插入的数据，导致前后数据量不一致</p></li></ul></li><li><p>隔离级别</p><p>SQL标准定义了四个隔离级别</p><ul><li><p>Read Uncommited(未提交读)</p><p>允许读取未提交数据，可能会引发<code>脏读</code>,<code>不可重复读</code>,<code>幻读</code></p></li><li><p>Read Commited(已提交读)</p><p>只允许读取已经提交的数据，可能会引发<code>不可重复读</code>,<code>幻读</code></p></li><li><p>Repeatable Read(可重复读)</p><p>只允许读取已经提交的数据，并且进一步要求在一个事务两次读取一个数据项期间，其他事务不得更新该数据项，可能会引发<code>幻读</code></p></li><li><p>Serializable(可串行化)</p><p>保证串行化的执行，但是一些数据库可能会使用并行方式执行，不会产生上面的任何一个问题</p></li></ul><p><img src="5.png" alt="7"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:查询优化1</title>
    <link href="/2022/01/30/CMU15445-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%961/"/>
    <url>/2022/01/30/CMU15445-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%961/</url>
    
    <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>查询优化是数据库中最难的部分，由于SQL是声明式语言，用户只需要给出SQL语句，DBMS负责给出最优的查询方案</p><p>这里有两种查询优化的策略: <strong>启发式方法(heuristic)/静态规则</strong>、<strong>基于代价的优化</strong></p><ul><li><p>启发式方法</p><p>在教科书上给出了两个启发式方法的例子  </p><ol><li>尽早执行选择</li><li>尽早执行投影</li></ol><p>当然还有更多的启发式方法，当使用该策略时，不需要取检查真正的数据，通常只需要获取一些元数据即可</p></li><li><p>基于代价的优化</p><p>通过使用等价规则来穷举出所有或者部分查询计划，从中筛选出效率最高的查询方法，但该策略需要访问真实数据，比较耗时</p></li></ul><p>下面是一个查询</p><p><img src="1.png" alt="1"></p><ol><li><p>SQL Rewriter</p><p>该步骤是一个可选步骤，在该步骤当中，可以通过某些转换规则让我们以某种方式对SQL进行重写，通常是一些标记</p></li><li><p>SQL Parser</p><p>该步骤负责将SQL字符串解析成SQL语法树</p></li><li><p>BInder</p><p>该步骤负责将查询对象转换为一些内部标识符，如将一个表名转换为磁盘的物理地址等，该步骤会利用系统的catalog</p></li><li><p>Tree Rewriter</p><p>该步骤会对语法树进行重写，使用的是<strong>静态规则</strong>，不会去使用实际数据，使用系统的catalog</p></li><li><p>Optimizer</p><p>该步骤会使用<strong>成本模型</strong>，需要真正访问数据，计算出最优的查询计划</p></li></ol><p>最终，会得到一个实际的物理查询计划，数据库使用此查询计划进行查询</p><p><strong>Logical Plan Vs. Physical Plan</strong></p><p><strong>逻辑计划</strong>是从高层次上来说的，如一个查询计划的树，逻辑计划规定了各个运算之间是以怎样的关系被组织的</p><p><strong>物理计划</strong>则是具体化的逻辑计划，如一个join是使用hash join还是sort-merge join, 该计划也是最终会执行的计划</p><p><img src="2.png" alt="2"></p><h3 id="Relational-Algebra-Equivalence"><a href="#Relational-Algebra-Equivalence" class="headerlink" title="Relational Algebra Equivalence"></a>Relational Algebra Equivalence</h3><p>如果两个关系代表达式在每个合法的数据库实例上都会产生相同的tuple集合，那么就称它们为<strong>等价的</strong></p><p>这种将关系代数使用等价规则进行转换的技术也被称为<strong>查询重写</strong>，在上图中的<code>tree rewriter</code>步骤中就使用了该技术</p><p>实际上，有一套通用的等价规则，这些规则建立在数学基础之上，下面是教材中给出的一些规则</p><p><img src="3.png" alt="3"></p><p><img src="4.png" alt="4"></p><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><h3 id="Logical-Query-Optimization"><a href="#Logical-Query-Optimization" class="headerlink" title="Logical Query Optimization"></a>Logical Query Optimization</h3><ul><li><p>选择操作的优化</p><ul><li><p>尽早开始过滤(谓词下移)</p><p><img src="7.png" alt="7"></p></li><li><p>重新排序谓词，以便DBMS首先应用最具选择性的谓词</p><p><img src="8.png" alt="8"></p></li><li><p>将复杂谓词分解并将其下移</p><p><img src="9.png" alt="9"></p></li></ul></li><li><p>投影操作的优化</p><ul><li><p>尽早开始投影以便减少操作间传递的中间结果的规模</p></li><li><p>移除所有非必要的属性，只投影我们需要的</p><p><img src="10.png" alt="10"></p></li></ul></li><li><p>谓词的优化</p><ul><li><p>移除一些根本无意义的谓词</p><p><img src="11.png" alt="11"></p></li></ul></li></ul><h3 id="Cost-based-Query-Optimization"><a href="#Cost-based-Query-Optimization" class="headerlink" title="Cost-based Query Optimization"></a>Cost-based Query Optimization</h3><p>DBMS优化器会使用内部的成本模型来评估一个特定查询计划的执行成本，这使得它们不用真实的去执行查询来获取这个查询的执行成本</p><p>各个数据库内部的成本模型不一样，但是总的来说是基于以下几点来考虑的</p><ul><li>CPU</li><li>DISK</li><li>Memory</li><li>Network</li></ul><p>在数据库的内部，会维护一些统计数据，不同的系统会在不同时刻更新这些数据，如每当表中的数据有20%发生改变时触发更新操作，或者是每天定时触发更新操作</p><h3 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h3><p>接下来使用数学关系分析成本，首先定义一些变量</p><ul><li><p>N<del>R</del>: 关系R所拥有的的tuple数量</p></li><li><p>V(A, R): 表R在A属性上中非重复值的数量</p></li><li><p>**选择基数SC(A, R)**：关系R中的A属性上平均每个非重复值对应的元组数量, 即N<del>R</del> / V(A, R)</p><p>使用该基数即意味着假设所有非重复值都是均匀分布的，那么必然就会产生<strong>不准确</strong>的结果</p></li></ul><h4 id="Complex-Predicates"><a href="#Complex-Predicates" class="headerlink" title="Complex Predicates"></a>Complex Predicates</h4><ul><li><p>一个谓词的<strong>选择率</strong>的值为在表中满足该谓词的元组所占整个表的元组的<strong>百分比</strong></p><p>这个百分比的计算依赖于谓词的类型</p><ol><li><p>等值</p><p><img src="12.png" alt="12"></p></li><li><p>范围</p><p><img src="13.png" alt="13"></p></li><li><p>取反</p><p><img src="14.png" alt="14"></p></li><li><p>合取</p><p><img src="15.png" alt="15"></p></li><li><p>析取</p><p><img src="16.png" alt="16"></p></li></ol><p>实际上，上面这些数学公式全部是基于一些基本的假设得到的，尽管这些假设可能与现实差距很大</p><ul><li>假设1： 数据均匀分布</li><li>假设2： 谓词之间是独立的</li><li>假设3：当对两个表进行join时，一张表中每一个tuple在其它表中都有另一个tuple与之对应</li></ul></li></ul><h4 id="Statistics-Storage"><a href="#Statistics-Storage" class="headerlink" title="Statistics Storage"></a>Statistics Storage</h4><p><strong>直方图</strong></p><p>如果想要获取精确的数据，那么一种方法就是为表中的每一列维护一个哈希表，建立值–&gt;出现次数的映射，这样做被称为<strong>heavy-hitter</strong></p><p><img src="17.png" alt="17"> </p><p>但这样做的弊端也十分明显，就是<strong>空间消耗太大</strong>，因为需要为表中的每一列都维护一个哈希表，在现实中是不可取的</p><p>不过，可以对上面这种做法稍微做一点改进，将几个值合并在一个形成一个bucket</p><p><img src="18.png" alt="18"></p><p>如当查询2的时候，就会找到bucket1 , 然后将12 / 5 = 2.4, 得到一个估计值，这样做当然也是不准确的，但是空间消耗会减少很多</p><p>另一种改进方案是每个bucket的值的数目不固定，但是保持每个bucket的数值个数总和大致相等，这样做会取到更为精确的结果</p><p><img src="19.png" alt="19"></p><p><img src="20.png" alt="20"></p><p><strong>样本</strong></p><p>现代的DBMS也使用<strong>抽样</strong>的方法来计算每个谓词的选择率，所谓抽样即从整个表中取出部分数据作为样品表，然后计算这个样品表中谓词的选择率</p><p><img src="21.png" alt="21"></p><p>高端的数据库会同时采用这两种方式</p><h3 id="Search-Algorithm"><a href="#Search-Algorithm" class="headerlink" title="Search Algorithm"></a>Search Algorithm</h3><p>对于不同类型的查询计划，有着不同的优化方法</p><ul><li><p>单个关系</p><p>对于访问单个关系的查询计划来说，我们只需要选择最优的访问方法即可</p><ul><li>循序扫描</li><li>二分搜索(基于聚簇索引)</li><li>索引扫描</li></ul><p>通常情况下使用简单的启发性方法就可以了，而对于OLTP来说，经常就是单表查询，因此优化比较简单</p><p>有些查询计划在查询的时候总是有索引能够选择，它只需要选择一个最优的索引即可，这类查询被称作<strong>sargable(Search Argument able)</strong>, OLTP的连接也几乎总是在基数很小的外键关系上</p></li><li><p>多关系</p><p>当多关系发生join运算时，可以有很多种join的顺序，当有n个表进行join的时候，进行join的顺序是一个卡特兰数，大约是4^n, 很显然不可能对它们进行穷举</p><p>在IBM的<code>system R</code>当中，会将多表连接全部转换为<strong>左深连接树</strong>(join运算交换律)</p><p><img src="22.png" alt="22"></p><p>这样做可以达到流水线的效果，每一个join运算的输出都直接作为下一个join运算的输入</p></li></ul><p><strong>查询优化的通用步骤</strong></p><ul><li>穷举出所有的操作顺序</li><li>穷举出每个运算所使用的操作(Hash join, sort-merge join, nested loop join)</li><li>穷举出对每张表所使用的穷举方法(index scan, squential scan)</li></ul><p>IBM使用了一种<strong>dynamic programming</strong>方法，思想有点像动态规划，先求出局部的最小值，在求出全局的最小值</p><p><img src="23.png" alt="23"></p><p>先列出所有join的顺序，然后给出所有可能的join操作</p><p><img src="24.png" alt="24"></p><p>选出到达各个不同状态的最短的路径</p><p><img src="25.png" alt="25"></p><p>重复上面的步骤一直到最终目标</p><p><img src="26.png" alt="26"></p><p><img src="27.png" alt="27"></p><p>最终，从全部找到最短的路径</p><p>在Postgres的查询优化器中，他们使用了两种方法，当表的规模比较小的时候，他们会使用和System R一样的方案，当表的规模比较大的时候，他们就会使用<strong>基因遗传算法</strong></p><p><img src="28.png" alt="28"></p><p>首先随机选出几个优种的组合，这种组合在顺序，操作算法，访问表的方面上面都是随机的，然后排除掉最差的，选择最优，并将其特征与其他的个体融合形成新个体，在经过多代筛选之后，选择出最优的</p><p>其中，每个个体的消耗也是根据直方图或者抽样给出来的</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:中级SQL</title>
    <link href="/2022/01/30/CMU15445-%E4%B8%AD%E7%BA%A7SQL/"/>
    <url>/2022/01/30/CMU15445-%E4%B8%AD%E7%BA%A7SQL/</url>
    
    <content type="html"><![CDATA[<h3 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式"></a>连接表达式</h3><p>当在SQL查询语句中使用<code>from</code>子句包含多个表的时候，默认会使用<strong>笛卡尔乘积</strong>对多个表中的元组进行连接</p><p>对于这样一个查询来说</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> A1, A2, ...<br><span class="hljs-keyword">from</span> r1, r2, ...<br></code></pre></td></tr></table></figure><p>迭代过程类似于下图</p><p><img src="1.png" alt="1"></p><p>如果后面还使用了<code>where</code>子句的话，就会在此表的基础上进行过滤</p><p>一个典型的笛卡尔积关系如图</p><p><img src="2.png" alt="2"></p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>自然连接的关键字是<code>natural join</code>，当两个表有着相同的属性名时，就可以对这两个表使用自然连接，自然连接仅会输出<strong>在这些相同属性上面有着相同取值的元组的连接</strong>，注意，是<strong>所有有着相同属性名的属性都必须完全相同</strong></p><p>假设有如下SQL查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> student, takes<br><span class="hljs-keyword">where</span> students.Id <span class="hljs-operator">=</span> takes.Id;<br></code></pre></td></tr></table></figure><p>其中students表与takes表仅有相同的属性ID，那么上面的语句就可以被下面的自然连接语句所代替</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> students <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> takes<br></code></pre></td></tr></table></figure><ul><li>join…using</li></ul><p>仅当不同表中的元组在所有共同属性上的取值都相等时自然连接才会将其输出，可以使用<code>join...using</code>运算符来指定连接的属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> `name`, title<br><span class="hljs-keyword">from</span> (student <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> takes) <span class="hljs-keyword">join</span> course <span class="hljs-keyword">using</span> (course_id);<br></code></pre></td></tr></table></figure><p>上面的例子中会输出<code>student</code>与<code>takes</code>自然连接产生的中间结果与<code>course</code>在<code>course_id</code>连接产生的表</p><ul><li><p>on子句</p><p>使用<code>on</code>运算符可以在参与连接的关系上设置通用的谓词</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student, takes<br><span class="hljs-keyword">where</span> student.Id <span class="hljs-operator">=</span> takes.Id;<br></code></pre></td></tr></table></figure><p>上述查询与下面的查询等价</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> student <span class="hljs-keyword">join</span> takes <span class="hljs-keyword">on</span> student.Id <span class="hljs-operator">=</span> takes.Id<br></code></pre></td></tr></table></figure></li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>假设我们拥有两个表A, B, 它们拥有共同属性ID, A表中存在一些元组，它们与B表中的所有元组在ID属性上都匹配不上，同理，B表也是一样</p><p><img src="3.png" alt="3"></p><p><img src="4.png" alt="4"></p><p>如果对这两个表使用自然连接，那么就只会有一个条目</p><p><img src="5.png" alt="5"></p><p>使用<strong>外连接会创建默认的空值</strong>，下面分别介绍几种外连接</p><ul><li><p>左外连接(left join):只保留出现在左外连接运算之前的关系中的元组</p><p>即如果左边关系中有某些元组无法和右边任意一个元组匹配，那么为它添加一个空的右边的元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> A <span class="hljs-keyword">natural</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B; <span class="hljs-comment">-- from A natural outer left join B</span><br></code></pre></td></tr></table></figure><p>下面是输出结果</p><p><img src="6.png" alt="6"></p></li><li><p>右外连接(right join)：只保留出现在右外连接之前的关系中的元组</p><p>即如果右边关系中有某些元组无法和左边任意一个元组匹配，那么为它添加一个空的左边的元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> A <span class="hljs-keyword">natural</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B; <span class="hljs-comment">-- from A natural outer right join B</span><br></code></pre></td></tr></table></figure><p><img src="7.png" alt="7"></p></li><li><p>全外连接(full join):是左外连接和右外连接的并集</p><p>貌似在mySql中没有实现</p></li></ul><p>与其相对应，平时使用的普通连接又被称之为<strong>内部连接</strong>，也有一个<code>inner</code>关键字与其对应，只不过平时都直接省略了而已</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> A <span class="hljs-keyword">natural</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B <span class="hljs-comment">-- from A natural join B</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:查询处理2</title>
    <link href="/2022/01/29/CMU15445-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%862/"/>
    <url>/2022/01/29/CMU15445-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%862/</url>
    
    <content type="html"><![CDATA[<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><strong>为什么使用并行执行</strong></p><ul><li>可以增加吞吐量并且减少延迟</li><li>从客户的角度可以提高响应性以及可用性</li><li>降低<strong>TCO(total cost of ownership)</strong></li></ul><h3 id="Parallel-vs-Distributed-Databases"><a href="#Parallel-vs-Distributed-Databases" class="headerlink" title="Parallel vs Distributed Databases"></a>Parallel vs Distributed Databases</h3><p>在并行以及分布式数据库当中，一个数据库会被分配到很多**资源(resource)*<em>上，这样做可以提高并行性，这里所指的资源包括</em>CPU, 磁盘, Socket, GPU, 主机*等等</p><p><strong>并行DBMS和分布式DBMS的区别</strong></p><ul><li><p>并行DBMS</p><p>在并行DBMS当中，各个<em>资源</em>，或者说<em>节点</em>, 在物理上是紧密连接的，它们之间的交互不仅要快速而且代价也十分的低，并且它们之间的连接是可靠的</p></li><li><p>分布式DBMS</p><p>在分布式DBMS当中，各个<em>资源</em>可能相距很远，之间的通信速度也比较慢，比如通过网络进行通信，连接也同样是不可靠的</p></li></ul><p>即使一个数据库可能被分为多个节点，但是对于应用程序来说，只有一个数据库实例，因此，无论是单节点还是多节点，一个SQL查询返回的结果应该都是一样的</p><p>接下来，我们重点关注<strong>并行DBMS</strong></p><h3 id="Process-Models"><a href="#Process-Models" class="headerlink" title="Process Models"></a>Process Models</h3><p><strong>处理模型</strong>决定了数据库是怎样从怎样支持多用户的并发环境的</p><p>一个数据库由很多<code>worker</code>构成，由他们进行实际的数据处理，当数据库一次性接受大量用户请求的时候，那么这些任务就会被分派到这些<code>worker</code>手上进行处理</p><p>下面介绍三种不同的处理模型</p><h4 id="Process-per-Worder"><a href="#Process-per-Worder" class="headerlink" title="Process per Worder"></a>Process per Worder</h4><p>该模型是最古老的模型了，基于<strong>进程</strong>而不是<strong>线程</strong>，原因就是在那时线程API还没有规范化</p><p>在该模型当中，每一个<code>Worker</code>就是一个单独的操作系统的<strong>进程</strong>，当用户发出请求的时候，会有一个**调度员(dispatcher)**来接受这个请</p><p>求，同时由它<code>fork</code>出一个进程来单独处理这个请求</p><p><img src="1.png" alt="1"></p><ul><li><p>优点</p><p>当一个进程崩溃时，整个数据库不会崩溃</p></li><li><p>缺点</p><p>由于每个进程都有一个自己的<code>buffer pool</code>, 他们都要从磁盘上取出page, 这就可能导致一个page在多个<code>buffer pool</code>上重复出现，无疑会浪费内存</p><p>一个解决方案是采用操作系统的<strong>共享内存</strong>, 这样多个进行就可以共享同一个数据结构</p></li></ul><h4 id="Process-Pool"><a href="#Process-Pool" class="headerlink" title="Process Pool"></a>Process Pool</h4><p>在该模型当中，依旧是基于<strong>进程</strong>来进行请求的处理，不过不再是每有一个请求就创建一个新的进程了，而是采用了一个<strong>进程池</strong>来进行处理，这个进程池中维护者一些进程，每当有查询请求连接到数据库的时候，就会由<strong>调度器</strong>从进程池当中找出适合的进程来对查询进行处理注意，在该模型当中，由于这些进程都被统一维护在进程池中，所以这些进行之间<strong>可以相互协助</strong>，即一个进程的部分任务可以分配给其他进程</p><p><img src="2.png" alt="2"></p><h4 id="Thread-per-Worker"><a href="#Thread-per-Worker" class="headerlink" title="Thread per Worker"></a>Thread per Worker</h4><p>该模型是当今主流数据库系统基本上都会采用的模型，整个数据库系统只有一个进程，将每个请求分摊到多个Worker线程上</p><p><img src="3.png" alt="3"></p><ul><li><p>优点</p><ul><li><p>减少了上下文切换所带来的的开销</p><p>在线程之间切换比在进程之间切换容易的多，开销更小</p></li><li><p>整个数据库能够对Worker线程能够进行自己的调度，不再需要操作系统</p></li><li><p>不在需要维护共享内存，线程之间的内存本身就是共享的</p></li></ul></li><li><p>缺点</p><p>线程的崩坏可能会造成整个数据库进程的崩溃</p></li></ul><p>尽管实现了Therad per Worker,但是这并不意味着该DBMS就能够做到查询内并行</p><h4 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h4><p>对于每个查询计划，DBMS必须得去决定在哪，在什么时候，怎样去执行，一些相关的问题包括</p><ul><li>应该将该查询计划分成多少个Task</li><li>应该使用多少个CPU核</li><li>某个Task应该放在哪个CPU 核上</li><li>一个Task应该将它的输出保存在哪</li></ul><p>不管怎样，当执行查询计划的时候，DBMS知道的都应该比操作系统更多</p><h3 id="Inter-Query-parallelism"><a href="#Inter-Query-parallelism" class="headerlink" title="Inter-Query parallelism"></a>Inter-Query parallelism</h3><p>在<strong>查询间并行</strong>的数据库当中，数据库会并发执行多个查询，这毫无疑问提高了吞吐量并且降低了延迟，但做到查询间并行并且保证数据不出错则很有挑战，将会在后面进行说明</p><h3 id="Intra-Query-parallelism"><a href="#Intra-Query-parallelism" class="headerlink" title="Intra-Query parallelism"></a>Intra-Query parallelism</h3><p><strong>查询内并行</strong>是本篇文章的重点，支持查询内并行的DBMS会并行执行一个查询计划中的运算，这会降低那些需要长时间运行的查询的延迟</p><p>各种运算操作可以被看成是生产者/消费者，每个运算都是一个生产者，同时它们也是一个消费者，消费来自底层运算的数据</p><p>对于每个运算来说都有它们的并行版本，它们既可以使用多线程来访问同一个中心数据结构，也可以将它们的工作分区</p><p>接下来介绍一些关系运算的并行算法，他们之间<strong>不是</strong>互斥的，即DBMS可以将它们一起使用以达到最优性能</p><h4 id="Intra-Operator-Parallelism-Horizontal"><a href="#Intra-Operator-Parallelism-Horizontal" class="headerlink" title="Intra-Operator Parallelism (Horizontal)"></a>Intra-Operator Parallelism (Horizontal)</h4><p>在<strong>运算内并行</strong>当中，查询计划被分为不同的<strong>段(fragements)</strong>, 即多个线程，它他们会在一整个数据集合上的不同部分并行执行相同的函数，DBMS使用一种被称为<strong>exchange</strong>的操作符来将不同<strong>fragements</strong>的输出结果合并在一起</p><p><strong>exchange</strong>操作符大体分为三种</p><ul><li>Gather: 将多个输入流组合成一个输出流</li><li>Distribute:将一个输入流分解成成多个输出流</li><li>Repartition: 将多个输入流组合，然后重新分配成多个输出流</li></ul><p><img src="4.png" alt="4"></p><ul><li><p>例子</p><p><img src="5.png" alt="5"></p><p>在该例子当中，一个选择操作被分为了三个<strong>fragement</strong>,然后使用Gather类型的<code>exchange operator</code>进行输出</p></li></ul><h4 id="Inter-Operator-Parallelism-Vertical"><a href="#Inter-Operator-Parallelism-Vertical" class="headerlink" title="Inter-Operator Parallelism (Vertical)"></a>Inter-Operator Parallelism (Vertical)</h4><p>在<strong>操作间并行</strong>当中，DBMS会将不同操作产生的中间结果进行重叠，以达到流水线效果了，所以该方法有时又被称为<strong>pipeline parallelism</strong></p><p>这种方法广泛应用于流处理系统中，l流处理系统即连续地在输入tuple流上执行查询的系统</p><p><img src="6.png" alt="6"></p><h4 id="Bushy-Parallelism"><a href="#Bushy-Parallelism" class="headerlink" title="Bushy Parallelism"></a>Bushy Parallelism</h4><p>该操作是操作内并行和操作间并行的混合体，即既有单个操作被并发执行，并且多个操作也在并发执行</p><p><img src="7.png" alt="7"></p><p>DBMS会使用<code>exchange operator</code>来存储中间结果</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:查询处理1</title>
    <link href="/2022/01/28/CMU15445-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%861/"/>
    <url>/2022/01/28/CMU15445-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%861/</url>
    
    <content type="html"><![CDATA[<h3 id="Query-Plan"><a href="#Query-Plan" class="headerlink" title="Query Plan"></a>Query Plan</h3><p><strong>查询计划</strong>指的是一系列查询操作的序列，通常使用一棵树来表示</p><p><img src="1.png" alt="1"></p><p>查询过程中的输入从叶子节点开始，沿着路径向上，在进入每层时会进行各种运算，最终在根节点产生输出结果</p><p>下面顺便介绍一些查询树中会出现的一些算子的含义</p><ul><li><p>连接运算</p><p><img src="2.png" alt="2"></p><p>该运算之前有所介绍，代表着连接运算，右下角的下标给出了连接的表以及属性</p></li><li><p>投影(Projection)运算</p><p><img src="3.png" alt="3"></p><p>该运算用来过滤输出结果，右下角的下标表明了最终产生的关系中会出现的属性</p></li><li><p>选择运算</p><p><img src="4.png" alt="4"></p><p>该运算对应着Sql语句中的where子句，其下标表明了选择的条件</p></li></ul><h3 id="Processing-Model"><a href="#Processing-Model" class="headerlink" title="Processing Model"></a>Processing Model</h3><p><strong>处理模型</strong>决定了DBMS怎样去执行一条查询计划，比如操作的执行顺序以及数据是怎样在各个操作之间进行传输的</p><p>下面介绍几种常见的处理模型</p><h4 id="Inerator-Model"><a href="#Inerator-Model" class="headerlink" title="Inerator Model"></a>Inerator Model</h4><p>该模型也被称为<strong>Pipeling Model</strong>, 即<strong>流水线模型</strong>，是数据库中最常用的处理模型</p><p>在该模型中，一个运算的结果会被传递给下一个运算，这延长了同一条数据在内存中的存在时间，提高了查询执行的效率</p><p>该模型中一个重要的函数被称为<strong>Next()</strong>,下面给出一个简单的图例</p><p><img src="5.png" alt="5"></p><p>可以看出，沿着根节点自上而下，每个内部节点需要实现获取到其子节点处理后的tuple，然后再执行自己的运算，迭代到最后，即到达了叶子节点，叶子节点就会扫描整个表, 一个个地返回tuple</p><p>下面给出流程关系图</p><p><img src="6.png" alt="6"></p><p><img src="7.png" alt="7"></p><p><img src="8.png" alt="8"></p><p><img src="9.png" alt="9"></p><p><img src="10.png" alt="10"></p><p><strong>Pipeline Breaker</strong></p><p>在流水线执行过程中，有些运算必须得等到他们的孩子输出所有的tuple, 这些运算被称为<strong>阻塞运算</strong>，如<code>Join</code>,<code>GroupBY</code>,<code>Subqueries</code>等等</p><h4 id="Materlalization-Model"><a href="#Materlalization-Model" class="headerlink" title="Materlalization Model"></a>Materlalization Model</h4><p>该模型被称为<strong>物化模型</strong>，每次运算执行的结果，都会被**物化(Materlized)**到一个临时的关系中以备后用，这些临时关系必须被写回磁盘</p><p>该模型与<code>Iterator Model</code>最大的区别在于，每个运算会一次性将所有的tuple全部输出，比如如果要选择value &gt; 100的tuple,那么他就</p><p>会将value &gt; 100的所有tuple全部输出，而不是像<code>Iterator Model</code>那样每输出一条tuple就要向子节点索要一条tuple</p><p>该方法的问题是某个操作可能会产生过量输出，即<strong>输出了一些上层节点所不需要的数据</strong>，为了避免这点，上层节点可以向下层节点传递一些限制信息，如<code>Limit</code></p><p><img src="11.png" alt="11"></p><p>如图所示，在该模型中使用<code>Output()</code>API来输出所有tuple</p><ul><li><p>适用情况</p><p>该方法对于OLTP来说很棒，OLTP意味着小而多的操作，如果这些数据全部在内存当中，并且使用<code>Iteartor Model</code>的话，那么多次迭代执行next()函数就需要比较大的开销，因为每次执行next()需要加锁</p><p>如果使用该模型，就可以一次向将所有数据传输到内存并读取，不需要进行多次迭代</p><p>相反，该方法则不适用与OLAP,因为在各个操作之间传递巨量数据非常耗时</p></li></ul><h4 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h4><p>该模型是对<code>Iterator Model</code>的增强版，其内部也实现了<code>Next()</code>函数，但是不再是一次性传递一个tuple了，而是一次性传递多个tuple</p><p><img src="12.png" alt="12"></p><p>其中这个tuple的数量可以根据系统自行调整，这也是当前业界主流的执行模型</p><h3 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h3><p><strong>访问方法</strong>指的是DBMS是怎样获取存储在table中的数据的，通常情况下，数据要么是从表中直接获取，要么是使用循序扫描从索引中获取</p><h4 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h4><p>循序扫描即遍历table的所有page上面的所有tuple, 无疑是最差的一种方案，但是使用一些优化方案来加快访问速度</p><ul><li><p>Prefetching</p><p>在取出一个page时顺便取出接下来的几个page</p></li><li><p>Buffer Pool ByPass</p><p>在扫描操作取出page的时候并不将page放进缓冲池，而是将其单独放入一个小的内存空间，避免污染缓冲池，这种方法适用于循序扫描，因为循序扫描过程中的page只使用一次，放入buffer pool也没有用</p></li><li><p>Parallelization<br>并行地对table进行读取</p></li><li><p>Zone Map</p><p>该技术会为每个page创建一个<strong>Zone Map</strong>,记录着该page的一些<strong>聚合量</strong></p><p><img src="13.png" alt="13"></p><p>这样，当执行扫描操作时，可以首先查看当前page的Zone Map, 然后再判断要不要扫描该page</p><p>如当需要获取最大值的时候，如果没有Zone Map,就需要扫描整个page, 找到其中的最大值，如果提前维护了聚合量的话，就没有必</p><p>要进行扫描了</p><p>该技术如今正在被广泛使用</p></li><li><p>Late Materialization</p><p>该技术的基本思想是<strong>尽量延迟真正传输数据的时机</strong>，在上层需要数据的时候，可以仅传递一些必要数据，如RID, 数据在列中的偏移量</p></li></ul><p><img src="14.png" alt="14"></p><p>在上面这个例子中，在执行选择操作(a &gt; 100)时，可以仅传递a &gt; 100的tuple在列中的偏移量，在执行根节点时会发现，根本不需要a列的数据，这样做无疑节省了开销</p><ul><li><p>Heap Culsting</p><p>如果需要的属性在聚簇索引中出现，就可以直接通过索引来访问</p></li></ul><h4 id="Index-Scan"><a href="#Index-Scan" class="headerlink" title="Index Scan"></a>Index Scan</h4><p>如果查询计划中的某些属性出现在索引当中，那么就可以借助索引来获取表中的数据</p><p>由于查询条件的不同，有时有多个索引可以选择</p><p><img src="15.png" alt="15"></p><p>在上面这个索引当中，就有dept 以及 age两种索引可以选择，根据不同的情况选择最优的索引</p><ul><li><p>使用索引的方式</p><p>就拿最常见的B+树索引来说，如果查询计划中进行的是点查询，那么很显然就应该从树顶沿着路径向下查询</p><p>如果是范围查询，那么就应该从最左边的叶子节点开始进行遍历</p></li></ul><p><strong>Multi Index  Scan</strong><br>在上面的例子中，由于有两个选择条件，我们也可以同时使用两个索引，然后对它们的结果取交集</p><p>如果给定的选择条件是<code>AND</code>的话就应该求交集，如果给定条件是<code>OR</code>的话就应该求并集</p><p><img src="16.png" alt="16"></p><h3 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h3><p>在SQL中可以出现一些表达式，如<code>Where B.value = A.value + 1</code>, 对于DBMS来说，会将其解释成一棵表达式树</p><p><img src="17.png" alt="17"></p><p>DBMS会维护一些元数据，比如当前的tuple等等以便使得表达式树能够正确执行</p><p>如果想要评测表达式树的执行效率的话会比较慢，因为需要遍历整个树，才能够知道真正想要做的操作是什么，更好的方法是直接进行计算</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:Join算法</title>
    <link href="/2022/01/27/CMU15445-Join%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/27/CMU15445-Join%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="joins"><a href="#joins" class="headerlink" title="joins"></a>joins</h4><p>一个好的数据库设计的目标是尽量减少信息的重复，因此，需要连接来重构原始表。</p><p>本课程将介绍用于合并两个表的内部<strong>等值连接</strong>(<strong>inner equal-join</strong>)算法, 等值连接可以被修改以支持其他种类的连接，并且</p><p>等值连接也是实战中使用的最多的连接方式</p><p>等值连接使用记号</p><p><img src="1.png" alt="1"></p><p>表示</p><p><strong>操作的输出</strong></p><p>假设有两个表R, S, 它们其中的tuple分别为r, s, 那么join操作在逻辑上的结果就是将两个表中某个属性上相同的tuple  r, s组合起来，形成一个新的tuple</p><p>事实上，实际的join操作的输出结果根据数据库<code>存储模型</code>、<code>查询计划</code>的不同也有所不同，主要的输出结果有<strong>Data</strong>和<strong>Record Id</strong>两种</p><ul><li><p>Data</p><p><img src="2.png" alt="2"></p><p>该方式中，join操作的结果返回的就是将两个表中的的tuple组合在一起，形成一个新的更长的tuple作为中间结果,该方法被称为<strong>early materialization</strong></p><ul><li><p>优点</p><p>在查询的后续操作中，就不需要回头继续取数据了，因为数据已经全部拿过来了</p><p><img src="3.png" alt="3"></p><p>在该查询树中，如果输出结果为Data那么就不需要回头，从叶子节点可以一直走到根节点处</p></li><li><p>缺点</p><p>该方法缺点页十分明显，就是在查询过程中取出了很多的无用数据，比较占用内存空间</p></li></ul></li><li><p>Record Id</p><p>该方法中，只拷贝那些<code>join</code>操作需要的key以及匹配tuple的<code>record Id</code>,join操作形成的结果如下所示</p><p><img src="4.png" alt="4"></p><p>之所以需要存储RID是因为在后续操作中如果查询计划需要别的属性就可以通过它们来找到相应tuple的位置，该方法被称为<strong>late materialization</strong></p><ul><li><p>优点</p><p>该方法对于<strong>列存储</strong>来说十分理想，因为如果join操作输出结果为data,那么列存储就需要访问很多page来获取那些可能不需要的属性，而在该方法中，只需要访问4列即可，很显然能够节省开销</p></li></ul></li></ul><p><strong>Cost Analysis</strong></p><p>在这里，当评判一个join算法的优劣时，只考虑他们在进行joins时所需的磁盘I/O次数，不需要考虑计算输出结果的的开销，这是由于在不同算法中计算输出结果的开销与算法本身无关</p><blockquote><p>接下来会使用到的变量</p><p> • M:外表R中的page数目, m:外表R中的tuple总数</p><p> • N:内标S中的page数目，n:内标S中的tuple总数</p></blockquote><h4 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h4><p>该方法是最慢的方法，即<strong>嵌套循环</strong></p><p><img src="5.png" alt="5"></p><ul><li><p>复杂度分析</p><p>对于外表R中的每一个tuple, DBMS都需要扫描一遍内表S，即取出其所有的page, 将整个表的tuple与R的tuple进行比对</p><p>故对内表S来说，需要的I/O次数为<code>m * N</code></p><p>而遍历一遍外表R也需要取出其所有的page, 故总I/O次数为:</p><p><strong>M + m * N</strong></p></li><li><p>例子</p><p><img src="6.png" alt="6"></p><p>如果将tuple量更小的表S作为内表，能够稍微减少一点join所需要的时间</p><p><img src="7.png" alt="7"></p><p><strong>Block Nested Loop Join</strong></p><p>该算法是对<strong>Nested Loop Join</strong>算法的改进, 其基本思想是:<strong>对于外表R中的每个page, 依次取出内表S中的Page, 两个Page之间再进行join操作</strong></p><p><img src="8.png" alt="8"></p></li><li><p>复杂度分析</p><p>外表R的每个Page都需要和内表S的所有Page进行配对，需要<code>M * N*</code>次I/O</p><p>取出外表R的所有Page,需要M次I/O, 故最终的I/O次数为:</p><p><strong>M + M * N</strong></p></li><li><p>例子</p><p><img src="9.png" alt="9"></p><p>可以看到时间由一个小时缩短到了50s, 但还是很慢</p><p>在此基础之上，如果能够充分利用内存，假设内存能够容纳的下B个Page, 最好情况下，使用B-2个作为外表R的buffer page, 使用1个作为内表S的buffer page, 使用一个作为输出buffer page, 那么，时间复杂度可以重新计算为；</p><p><strong>M + ($lceil M / (B- 2) rceil$ *  N)</strong></p><p><img src="10.png" alt="10"></p></li><li><p>最好情况下的例子</p><p><img src="11.png" alt="11"></p><p>同样的数据量，现在被缩短为了0.15秒</p></li></ul><p><strong>Indexed Nested Loop Join</strong></p><p>之前的几种join算法表现都不是很好，是因为他们他们都采用了扫描的方式，如果DBMS在跟定的属性上已经建立了索引，那么就可以使用索引来进行查找，这样可以节约很大的开销</p><p><img src="12.png" alt="12"></p><p>在该算法中，DBMS可以利用已有的索引或者临时建立一个索引用于给<strong>内表进行查找</strong>，每次内表进行查找的时间就可以缩短为常数时间C,</p><p>如果是Hash Index的话最好情况时O(1), 最坏情况时O(n), 如果B+树的话就是O(lg(n)), 这里的n的索引中数据的规模</p><ul><li><p>复杂度计算</p><p>使用了索引之后，需要进行的I/O次数为</p><p>**M + (m * C) **</p></li></ul><p><strong>Nested Loop Join总结</strong></p><ul><li>永远使用较小的表作为外表</li><li>设置尽可能多的buffer page</li><li>内表最好使用索引，否则就只能按序扫描</li></ul><h4 id="Sort-Merge-join"><a href="#Sort-Merge-join" class="headerlink" title="Sort-Merge join"></a>Sort-Merge join</h4><p>该算法的基本思想是对两个表的指定key进行排序，排序算法可以使用之前的外归并排序，然后使用两个游标分别对两个表进行扫描</p><p><img src="13.png" alt="13"></p><p>上面的算法只是简写，在扫描过程中有可能会发生回溯现象，下面这张图是教材中的算法描述</p><p><img src="14.png" alt="14"></p><ul><li><p>例子</p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p><img src="17.png" alt="17"></p><p>下面发生了回溯</p><p><img src="18.png" alt="18"></p></li><li><p>复杂度分析</p><p>最坏情况下，即两张表中所有的key完全相同，那么每次内表都得从头回溯，比较次数为 <code>M * N</code></p><p>最好情况下，一次回溯都没有，那么比较次数为<code>M + N</code></p><p>下面给出排序加上merge操作的总复杂度</p><p><img src="19.png" alt="19"></p></li><li><p>例子<br><img src="20.png" alt="20"></p></li></ul><h4 id="Hash-join"><a href="#Hash-join" class="headerlink" title="Hash join"></a>Hash join</h4><p>Hash join是最快的方法，它的基本思想是<strong>通过join上的key的哈希函数的值，将一个表分成多个块存储在不同的bucket当中，另一张表也通过相同的哈希函数，对表中的每一行进行映射，每映射到一个桶，就在该桶中进行匹配，如果发现了相同的key,那么就可以输出</strong></p><p><img src="21.png" alt="21"></p><p>该方法思想十分简单，并且速度也十分快</p><p>具体来说可以分为两个阶段：</p><ul><li><p>Phase #1 build</p><p>扫描外表R，将join所需的attribute作为哈希函数的输入进行映射，哈希表的value则依赖与具体实现</p></li><li><p>Phase #2 Probe</p><p>对内表S中的每个条目，使用相同的哈希函数进行映射，映射到某个bucket 之后，将其attribute与该bucket的所有条目进行比对，如果key相同则输出</p></li></ul><p>如果DBMS已知外表的大小，那么就可以使用静态哈希表，如果外表大小未知的话，那么可以采用动态哈希表或者使用overflow pages</p><p>有些实现还使用了<code>布隆过滤器</code>作为辅助，用于在Phase #2中快速进行判断attribute是否在bucket中</p><p>下面是一个关于布隆过滤器的连接</p><p><a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p><p><strong>Grace Hash join</strong></p><p><code>Grace Hash join</code>是基本hash join的拓展，其不仅将外表属性映射到哈希表中，同时还将内表映射到哈希表中</p><p>该方法适用于hash join方法下bucket不能够全部放入内存的情况</p><p>同样，Grace Hash join也分为两个阶段:</p><ul><li><p>Phase  #1 Build</p><p>DBMS会扫描两个表，使用相同的哈希函数填充哈希表</p><p><img src="22.png" alt="22"></p><p>由于可能会发生哈希碰撞，所以可能会产生overflow pages, 当overflow pages到达一定阙值时，可以采用<strong>recursive partitioning</strong>的策略，即将这些overflow pages进行重新分区，采用不同的哈希函数进行映射</p><p><img src="23.png" alt="23"></p><p>原本多个overflow pages可以减少为较少的分区，这样就可以递归的执行直到所有的bucket都能够被放进内存</p></li><li><p>Phase #2 Probe</p><p>对于同一层级的bucket, 对它们使用nested Loop join, 进而找出所有匹配的tuple, 由于所有的bucket 都在内存当中,所以nested Loop Join也十分快速</p><p><img src="24.png" alt="24"></p></li><li><p>复杂度分析</p><p><img src="25.png" alt="25"></p></li></ul><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p><img src="26.png" alt="26"></p><p><strong>总结</strong></p><p>Hash Join 在绝大多数场景下是最优选择，但当查询包含 ORDER BY 或者数据极其不均匀的情况下，Sort-Merge Join 会是更好的选择，DBMSs 在执行查询时，可能使用其中的一种到两种方法</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:排序与聚合</title>
    <link href="/2022/01/26/CMU15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E5%90%88/"/>
    <url>/2022/01/26/CMU15445-%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="sorting"><a href="#sorting" class="headerlink" title="sorting"></a>sorting</h3><p>排序在数据库中发挥着重要作用，首先SQL会指明对输出进行排序(DESC…), 有些关系运算，比如连接运算，如果对输入关系进行排序，那么会得到更高效的实现</p><ul><li><p>算法的选择</p><p>如果所有的数据都能够放入内存当中，那么当然是复杂度越低的排序算法越好，但是如果数据并不能够一次性全部放入内存，那么就需要考虑磁盘I/O, 如复杂度最低的<strong>快排</strong>，此时就需要进行大量的随机I/O, ,时间反而消耗比较高</p></li></ul><h3 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h3><p>对于不能够全部放入内存中进行的排序称之为<strong>外排序(external sorting)</strong>, 而最常用的外排序算法就是<strong>归并排序</strong></p><p>归并算法将表中的数据分为多个归并段，一次性将部分归并段放入内存当中进行排序，当排序完成之后将他们写回磁盘再进行下一批次的</p><p>排序，最终可以得到多个有序的<strong>归并段(runs)</strong>, 再递归地对归并段进行排序就能得到最终的排序结果</p><ul><li><p>二路归并</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><ul><li><p>buffer page问题</p><p>在<code>Pass #</code>0中，内存中的所有<code>page</code>都被使用到，假设内存大小为B个<code>page</code>, 总共有N个<code>page</code>, 那么在<code>pass #0</code>中就会得到$lceil B/N rceil$个<code>run</code></p><p>在Pass #1, 2, 3…中，在内存只使用3个page, 每次读出两个<code>page</code>进行比较，即输入page, 留出一个<code>page</code>用做输出<code>page</code>, 注意到归并到后面是，一个归并段可能包含多个page, 此时的策略是对同一个<code>buffer page</code>进行复用，当输出结果填满一个page后，将其内容读回磁盘，再重新填充该page</p></li><li><p>复杂度以及I/O分析</p></li></ul><p><img src="3.png" alt="3"></p><ul><li>缺点<br>二路归并每次只会用到3个page, 即使buffer pool还没有满，其余的page也用不上，因此不能够充分利用整个buffer pool</li></ul></li><li><p>Double Buffering Optimization</p><p>在上面的二路排序中，page的排序过程是线性的，即取出一个page, 排序，再取出一个page, 排序，如果使用<strong>预取</strong>技术，在一个page自身进行排序时，另一个线程能够提前将下一步所需要的page读取到内存当中，就能够减少磁盘I/O带来的阻塞</p><p><img src="4.png" alt="4"></p></li><li><p>General (K-way) Merge Sort</p><p>即K路排序，假设内存大小为M,那么排序过程如下</p><p><img src="5.png" alt="5"></p></li></ul><h3 id="Using-B-Tree"><a href="#Using-B-Tree" class="headerlink" title="Using B+ Tree"></a>Using B+ Tree</h3><p>有时要想排序的属性可能已经作为B+树的key了，那么此时可以尝试使用B+树索引来加速排序</p><ul><li><p>聚簇索引</p><p>在聚簇B+树索引当中，叶子节点的顺序就是磁盘中tuple的顺序，那么此时就可以直接利用B+树索引，以达到顺序访问的效果</p><p><img src="6.png" alt="6"></p></li><li><p>非聚簇索引</p><p>费聚簇索引当中，叶子节点的顺序和磁盘中tuple的顺序并不对应，就无法直接使用，因为这样会产生大量随机I/O</p><p><img src="7.png" alt="7"></p></li></ul><h3 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h3><p><strong>聚合</strong>对应着SQL中的关键字，<em>聚合函数(MIN(), COUNT()…), GROUP BY</em>等等，实现方式有两种: <strong>Sorting, Hashing</strong></p><ul><li><p>Sorting</p><p>通过对table中的数据进行排序，进而得到我们想要的结果</p><p><img src="8.png" alt="8"></p></li><li><p>Hashing</p><p>使用哈希函数来将tuple映射到磁盘上的不同分区中</p><ul><li>Phase #1 分区</li></ul><p><img src="9.png" alt="9"></p><p>注意，假设内存有B个page,那么我们只能有B-1个page,因为必须得留一个page用做输入</p><p><strong>当某个page</strong>满了之后，就将它的值重新刷新回磁盘</p><ul><li><p>Pahse #2 重新哈希</p><p>对于磁盘上的每个分区，将其页面读入内存，并基于第二个哈希函数h2(h2 != h1)构建内存中的哈希表。然后遍历这个哈希表的每个bucket，将匹配的元组放在一起来计算聚合。注意，这里假设每个分区中的内容都能在内存中放得下</p><p><img src="10.png" alt="10"></p></li><li><p>Hashing Summarization</p><p>在第二步rehash时，我们可以得到一些{GroupKey, RunningValue}的pair, 这里的RunningValue是一些中间值，取决于所做的绝活操作,比如在AVG()聚合操作时，这个值就可以是总和，这样每有一个值rehash到该位置时，这个值就会增加，最终利用该和求出平均值</p><p><img src="11.png" alt="11"></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:索引并发控制</title>
    <link href="/2022/01/22/CMU15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/01/22/CMU15445-%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="Index-Concurrency-Control"><a href="#Index-Concurrency-Control" class="headerlink" title="Index Concurrency Control"></a>Index Concurrency Control</h4><p>DBMS通过使用并发控制协议来确保在对一个共享的对象上进行并发操作能够得到正确的结果</p><p>一个协议的正确性可以分为两种</p><ul><li><p>逻辑正确性</p><p>一个线程应该能够获取到他期望获取到的值</p></li><li><p>物理正确性</p><p>这意味着在我们的数据结构中没有指针指向非法的内存区域</p></li></ul><p>在数据库中，我们关心的仅仅是逻辑正确性</p><h4 id="Lock-amp-Latch"><a href="#Lock-amp-Latch" class="headerlink" title="Lock &amp; Latch"></a>Lock &amp; Latch</h4><p>在之前已经介绍过Lock和Latch的区别，但只是宏观的讲了一下Lock位于事务层面，而Latch位于数据结构层面，接下来仔细分析一下他们之间的区别</p><table><thead><tr><th></th><th>Lock</th><th>Latch</th></tr></thead><tbody><tr><td>隔离级别</td><td>用户事务</td><td>线程</td></tr><tr><td>保护的内容</td><td>整个数据库</td><td>内存中的数据结构</td></tr><tr><td>持续时间</td><td>整个事务处理期间</td><td>某些关键点</td></tr><tr><td>死锁处理</td><td>检测恢复机制</td><td>手动避免</td></tr><tr><td>模式</td><td>共享锁，排它锁，Update, Intension</td><td>读者锁，写者锁</td></tr><tr><td>存储位置</td><td>Lock管理器</td><td>受保护的数据结构</td></tr></tbody></table><h5 id="Read-Latch-和-Write-Latch"><a href="#Read-Latch-和-Write-Latch" class="headerlink" title="Read Latch 和 Write Latch"></a>Read Latch 和 Write Latch</h5><p>下面是线程对锁的持有情况</p><p><img src="1.png" alt="1"></p><ol><li><p>Read Latch</p><p>多个线程可以同时持有Read Latch</p></li><li><p>Write Latch</p><p>多个线程同时访问数据时，只有一个线程能拿到Write Latch, 如果一个线程想要拿到Write Latch, 只有等其他所有线程</p><p>释放他们所拥有的锁才行</p></li></ol><h5 id="Latch-Implementations"><a href="#Latch-Implementations" class="headerlink" title="Latch Implementations"></a>Latch Implementations</h5><p>实现锁的基本方法还是通过现代CPU提供的<code>compare-and-swap</code>指令，这个指令的伪代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ptr,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> <span class="hljs-keyword">new</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> actual=*ptr;<br>    <span class="hljs-keyword">if</span>(actual==expexted)<br>    *ptr=<span class="hljs-keyword">new</span>;<br>    <span class="hljs-keyword">return</span> actual;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果原有值是我们所期望的值，那么就将它交换成新值，这个指令是原子的</p><p>下面介绍几种数据库中使用的Latch的实现方法</p><ul><li><p>操作系统 mutex</p><p>使用操作系统内置的锁，如<code>std::mutex</code>. 在这里简单介绍一下<code>futex</code>的概念</p><p><strong>futex</strong></p><p>futex的全称是<code>fast user-space mutex</code>，其基本思想是<strong>在进程的用户地址空间中开辟一个共享的内存区域，如一个bit,线程访问共享资源的时候，通过对该内存区域进行+1, -1等操作来模拟实现latch, 进而减少信号量的使用，因为使用信号量即意味着要进入内核空间，需要开销</strong></p><p>在数据库中，如果DBMS能够获得用户空间的latch, 那么就代表它获取到了共享资源，如果获取用户空间latch失败了，那么它就会尝试使用系统mutex, 如果再次失败，那么就会陷入阻塞</p><p><img src="2.png" alt="2"></p><p>使用操作系统mutex不是一个好方法，因为锁的调度完全由操作系统来管理，不可控</p></li><li><p>Test-And-Set 自旋锁</p><p>该方法的思想与futex十分相似，也是在用户空间设置一个共享区域来模拟latch, 但是当线程尝试获取latch失败的时候，线程就会进行自旋或者是一些自定义的操作</p><p><img src="3.png" alt="3"></p><p><code>test-and-set</code>的伪代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TestAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ptr,<span class="hljs-keyword">int</span> <span class="hljs-keyword">new</span>)</span></span>&#123;<br><span class="hljs-keyword">int</span> old=*ptr;<br>*ptr =<span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">return</span> old;<br>&#125;     <span class="hljs-comment">//将旧值改为指定新值，并返回旧值</span><br></code></pre></td></tr></table></figure></li><li><p>Reader-Writer Latches</p><p>上面的方法没有区分读和写操作，如果多个线程进行读操作的话，还是要进行逻辑的调度，使用读写锁就不会有这种问题</p><p><img src="4.png" alt="4"></p></li></ul><h4 id="Hash-Table-Latching"><a href="#Hash-Table-Latching" class="headerlink" title="Hash Table Latching"></a>Hash Table Latching</h4><p>接下来介绍哈希表中Latch的使用. </p><p><strong>静态哈希表</strong></p><p>在使用哈希表建立索引时，访问数据的方法非常少，拿最常用的线性探查法进行举例，由于所有的线程都是按照page0, page1, page2…的顺序对哈希表进行探查，那么就不可能有两个线程拥有互斥的latch, 即<strong>不可能发生死锁</strong></p><p><strong>动态哈希表</strong></p><p>动态哈希表中的情况略微复杂一些，因为有更多共享区域需要更新，但是总体来说也比较简单</p><p><strong>锁的粒度</strong></p><p>哈希表中，Latch通常可以取两种粒度</p><ul><li><p>Page Latch</p><p>在每个Page中安置一个Latch, 当线程访问该page时需要获取该锁</p></li><li><p>Slot Latch</p><p>在page的每个slot中安置一个Latch, 当线程访问该slot时获取该锁</p></li></ul><h4 id="B-Tree-Latching"><a href="#B-Tree-Latching" class="headerlink" title="B+ Tree Latching"></a>B+ Tree Latching</h4><p>在B+树，一种常见的B+树并行访问技术被称为<strong>蟹行协议(crabbing protocol)</strong>,下面是该协议的具体流程</p><ul><li><p>搜索</p><ol><li>首先在根节点处加上Read Latch</li><li>沿着树向下遍历，首先在孩子节点上获得Read Latch, 然后释放掉在父节点上的锁，重复这个过程直到它到达一个叶节点</li></ol><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><p><img src="7.png" alt="7"></p><p><img src="8.png" alt="8"></p></li><li><p>插入或删除</p><ol><li>在根节点上加上Write Latch</li><li> 沿着根节点向下，对子节点加Write Latch, 紧接着判断该子节点是否<strong>安全</strong></li></ol><p><strong>安全</strong>在插入和删除下有着不同的语义：</p><ul><li><p>插入</p><p>当节点再插入一个pair不会发生分裂，即表明该节点安全</p></li><li><p>删除</p><p>当节点删除一个pair后不会和兄弟节点发生合并或者重新分配，即表明该节点安全</p></li></ul><ol start="3"><li><p>如果子节点安全，那么释放当前当前所处节点的所有父亲节点上面的锁</p><p>如果子节点不安全，则继续保持Write Latch状态</p></li></ol><p><img src="9.png" alt="9"></p><p><img src="10.png" alt="10"></p><p><img src="11.png" alt="11"></p><p><img src="12.png" alt="12"></p><p><img src="13.png" alt="13"></p></li></ul><p><strong>Improved Lock Crabbing Protocal</strong></p><p>这里有一种对Crabbing Protocal方法的改进算法，该算法的基本思想是<strong>假设接下来的操作不会触发节点合并，重新分配，分裂等操作，从根节点开始一直向下都采用和Crabbing Protocal中的Search操作一样的流程，即只加Read Latch，在叶子节点上设置Write Lathch, 等到触发合并、重新分配，或者分裂操作的时候，再从根节点开始重新应用Crabbing Protocal</strong></p><p><img src="14.png" alt="14"></p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p><img src="17.png" alt="17"></p><p><img src="18.png" alt="18"></p><p><strong>B+树中的死锁</strong></p><p>在叶子节点单向连接的情况下，对B+树进行并发访问是不会发生死锁的，因为对单向B+树进行访问总共只有两种方式</p><ol><li><p>从根节点自上而下进行访问</p><p>由于所有线程都是自上而下进行访问的，所以如果一个线程尝试获取一个latch，但是该latch正在被占有，那么线程只需要简单等待其他线程释放latch就可以，不会发生死锁</p></li><li><p>沿着叶子节点单向访问</p><p>同理，由于访问方向相同，所以不会发生死锁</p></li></ol><p>但是，如果叶子节点是双向连接，那么就可能发生死锁</p><p><img src="19.png" alt="19"></p><p>此时，一方必须选择放弃它当前的操作，从头访问，以打破死锁</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:树索引2</title>
    <link href="/2022/01/17/CMU15445-%E6%A0%91%E7%B4%A2%E5%BC%952/"/>
    <url>/2022/01/17/CMU15445-%E6%A0%91%E7%B4%A2%E5%BC%952/</url>
    
    <content type="html"><![CDATA[<h4 id="Duplicate-keys"><a href="#Duplicate-keys" class="headerlink" title="Duplicate keys"></a>Duplicate keys</h4><p>在B+树中，当插入重复的key时，通常有两种方案</p><ul><li><p>Append Record ID</p><p>Record ID即一个tuple的page id + offset, 代表了其物理位置，是唯一的，该方法的思想是<strong>将record ID添加到key的后面作为key的一部分</strong>，这样就能够的到唯一的key</p><p>该方法基本上不需要修改B+树的数据结构，实现起来较为简单，大多数厂商都是采用这种方法</p></li></ul><p><img src="1.png" alt="1"></p><p>在上图中，添加了record ID，即(Page, Slot)作为key的后缀，树中已有的6与即将插入的6将会拥有不同的key, 所以和普通的B+树插入过程是一样的</p><p><img src="2.png" alt="2"></p><ul><li><p>Overflow leaf nodes</p><p>在该方法中不再存储record id,而是将重复的key存储在另一个page之上，这个page被称为<strong>overflow page</strong>, 在该page上的数据不同于普通的叶子节点，可以是无序的，还可以是重复的</p><p><img src="3.png" alt="3"></p><p><img src="4.png" alt="4"></p></li></ul><p>如果需要在<code>overflow page</code>上搜索数值，就只能采取线性查找，因为其中的数据是未排序的</p><h4 id="索引相关技术"><a href="#索引相关技术" class="headerlink" title="索引相关技术"></a>索引相关技术</h4><ul><li><p>Implicit Index</p><p>当今许多DBMS为了保证完整性约束(integrity constraints)会自动地在某些列上建立索引，如主键等，这些列的共同特性就是它们一定是唯一的</p><p><img src="5.png" alt="5"></p></li></ul><p>这里的SERIAL是一个PostgreSQL中的关键字，可以看看下面这个链接</p><p><a href="https://www.postgresqltutorial.com/postgresql-serial/">https://www.postgresqltutorial.com/postgresql-serial/</a></p><p>上面的图片中，id和val2都是唯一的，所以DBMS会自动地给他们建立索引，此外， val1并不能确保唯一性，所以并不会给它建立索引</p><p><img src="6.png" alt="6"></p><ul><li><p>paritial Index</p><p>部分索引，有时我们只需要对表中的部分数据建立索引，比如下面的sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_foo <br>ON foo (a, b) <br>WHERE c = &quot;WuTang&quot;<br></code></pre></td></tr></table></figure><p>只会在c = “WuTang”的行上以a, b两列建立索引</p><p>部分索引的好处：</p><ol><li>减少很多不必要的数据，以防他们污染缓冲池</li><li>减小了索引树的高度，可以更快的查询数据</li></ol></li><li><p>覆盖索引</p><p>当进行一次查询所需要的全部数据都在索引当中时，这种情况就被称为覆盖索引</p><p><img src="7.png" alt="7"></p><p>覆盖索引的优点在于减少了磁盘I/O的次数，由于所需要的数据都在索引当中，索引又在内存当中，所以不需要进行磁盘I/O, 但缺点是</p><p>索引会占据缓冲池的空间</p></li><li><p>Index Include Column</p><p>该技术思想是在B+树的叶子节点中加上额外的列数据，比如有如下查询</p><p><img src="8.png" alt="8"></p></li></ul><p>当通过a, b 构成的索引找到叶子节点时，可以顺带获得c中所需要检查的c数据，但该技术支持的厂商比较少</p><p>注：<strong>附加的数据只存储在叶子节点当中，内部节点并不改变，所以附加数据并不影响search key, 也并不需要占据多少额外的内存空间</strong></p><ul><li><p>functional/expression index</p><p>建立索引时，不仅仅可以基于某些列建立索引，还可以基于他们衍生出的表达式建立索引</p><p><img src="9.png" alt="9"></p><p>上面的<code>EXTRACT (dow FROM login)</code>就是login列衍生出的表达式，如果仅使用login列建立索引，对于上面这个查询来说就没有什么用处</p><p>事实上，该方法与partial index有着异曲同工之妙</p><p><img src="10.png" alt="10"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:树索引1</title>
    <link href="/2022/01/13/CMU15445-%E6%A0%91%E7%B4%A2%E5%BC%951/"/>
    <url>/2022/01/13/CMU15445-%E6%A0%91%E7%B4%A2%E5%BC%951/</url>
    
    <content type="html"><![CDATA[<p>在数据库中，通过索引来达到快速检索数据的目的，之前的哈希表就是一种索引的数据结构，哈希表在单值查询时十分快速，最好能够到O(1)的时间复杂度，但是确不支持范围查询，在工业中，最常被使用的还是接下来将要介绍的B+树索引结构</p><h4 id="B-树原理"><a href="#B-树原理" class="headerlink" title="B+树原理"></a>B+树原理</h4><p>关于B+树的各种操作网上给出的很多，并且十分繁琐，可以参考下面的链接</p><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p><strong>B树(B-树)与B+树的区别</strong></p><p>在B树中，每个节点都保存了key 和 value, 而在B+树中，仅仅在叶子节点中才保存, 叶子节点中只包含value与指向子树的指针</p><p>一棵B+树看起来就像这样</p><p><img src="1.png" alt="1"></p><p>其中叶子节点存的value，可以是page id,也可以存储真实的tuple, Oracle采用了前一种做法，MySQL采用了后一种做法</p><h4 id="Selection-Condition"><a href="#Selection-Condition" class="headerlink" title="Selection Condition"></a>Selection Condition</h4><ul><li><p>搜索码</p><p>在文件中查找记录的属性或者属性集合被称为<strong>搜索码(Search Key)</strong></p></li></ul><p>B+树相对于哈希表来说的另一个优点在于<strong>可以使用搜索码中的部分属性</strong></p><p><img src="2.png" alt="2"></p><p>在上图中，搜索码为{a, b, c},那么采用B+就可以采用部分搜索码就能完成搜索，而对于哈希表来说，必须需要完整的搜索码才能够产生一个正确的哈希值</p><p>假设搜索码有两个，执行查询<code>select key=A</code>, 那么只需要沿着叶子节点，找到第一个属性为A的所有节点即可</p><p><img src="3.png" alt="3"></p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引，即culsted Index,是属于顺序存储中的一种特殊索引，<strong>其搜索码的逻辑顺序存储在磁盘中的真实数据的顺序相对应</strong></p><p>通常情况下，搜索码的逻辑顺序就是主键的顺序，实际上，如果未设置主键，有些数据库就会生成默认的主键，并按照该主键进行排序，</p><p>如MySql</p><p>聚簇索引对于范围查询来说很有利，因为相同前缀的数据会聚集在一起，可以减少I/O的次数</p><h4 id="重复搜索码"><a href="#重复搜索码" class="headerlink" title="重复搜索码"></a>重复搜索码</h4><p>可以通过修改B+树的结构用以支持重复搜索码，常见的实现方案有两种</p><ul><li>一个搜索码在叶子节点中只有一个，为每个搜索码维护一个list,如果有重复搜索码的value被插入，那么接在list之后</li><li>在叶子节点中支持重复的搜索码，重复的搜索码可以放在不同色叶子结点中</li></ul><h4 id="B-树的设计"><a href="#B-树的设计" class="headerlink" title="B+树的设计"></a>B+树的设计</h4><ul><li><p>节点大小</p><p>如果索引空间足够小，那么他就可以被存放于内存当中，如果太大，就只能放于磁盘当中，依赖于存储的介质，B+树的节点大小页有所不同</p></li></ul><p><img src="4.png" alt="4"></p><ul><li><p>Merge时机</p><p>B+树为了保持平衡，需要不断进行节点之间的merge,但是这样做往往需要空间开销，可以采取<strong>延迟Merge</strong>的方式，</p><p>如果每次进行插入或者删除操作时都对索引进行更新，这样浪费大量的时间，因为对树进行更新就意味着对树进行加锁</p></li></ul><h4 id="可变长度的key"><a href="#可变长度的key" class="headerlink" title="可变长度的key"></a>可变长度的key</h4><p>serarch key中可能包含了varchar之类的属性，因此key的长度可能是不固定的，对于可变长度的key，有以下几种解决方案</p><ul><li><p>在key中存储指向属性的指针</p><p>这样做可以节省空间，实际上在早期内存不足的时候才使用这种做法，因为tuple存储在磁盘中,所以根据指针访问属性即意味着磁盘I/O, 太慢了，现在没人使用</p></li><li><p>直接存储变长key</p><p>这种方法一般不会使用，因为处理可变长度key的开销太大了</p></li><li><p>填充</p><p>选取最大的key,将其他key填充至和其长度一样长</p></li><li><p>key映射</p><p>在内存当中存储key-value的pair构成的字典结构,而在node当中存储对应的key在字典当中的下标</p><p><img src="5.png" alt="5"></p><p>还可以在node中存储key的前缀，用于加快字典查找</p><p><img src="6.png" alt="6"></p></li></ul><h4 id="节点内部访问"><a href="#节点内部访问" class="headerlink" title="节点内部访问"></a>节点内部访问</h4><p>节点内部保存着很多关键码，在一个节点内部查找出我们所需要的key也有几种方法</p><ul><li><p>线性</p><p>线性查找的时间复杂度为O(n)</p></li><li><p>二分</p><p>该方法的时间复杂度为O(lg(n))，是一种比较高效且简单的方法</p></li><li><p>interpolation</p><p>该方法的思想是利用Node中存储的元数据来推测出我们需要查找的key在node中的大概位置</p></li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p>前缀压缩</p><p>该技术的思想是在每个内部节点可以不用存储整个key, 如果key是字符串类型的话，可以取出这些字符串的公共部分，只要存储的内容能够将其区分即可</p><p><img src="7.png" alt="7"></p></li><li><p>去除重复</p><p>在key可以重复的情况下，可以让一个key紧跟多个value</p><p><img src="8.png" alt="8"></p></li><li><p>批量加载</p><p>有时，在构建B+树之前，我们就已知了所有的key，那么就不需要每插入一个数据就更新一次B+树索引，可以直接提前构建好B+树索引，这样可以减少更新所带来的的维护<br><img src="9.png" alt="9"></p></li></ul><h4 id="B-树操作伪代码"><a href="#B-树操作伪代码" class="headerlink" title="B+树操作伪代码"></a>B+树操作伪代码</h4><p>下面是《数据库系统概念》中关于B+树的各种操作的伪代码</p><ul><li>点查询</li></ul><p><img src="10.png" alt="10"></p><ul><li><p>插入</p><p><img src="11.png" alt="11"></p></li><li><p>删除</p><p><img src="12.png" alt="12"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:哈希表</title>
    <link href="/2022/01/12/CMU15445-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/01/12/CMU15445-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在数据库中，散列这种数据结构在构建索引时被广泛使用，虽然散列没有B+树使用的广泛，但是仍然很值得学习</p><ul><li><p>桶(bucket)</p><p>bucket表示可以存储一条或多条tuple的存储单元，可以在内存中也可以在磁盘中，对于内存中的哈希表来说，bucket可以是tuple的链表，对于磁盘中的哈希表来说，bucket可以是磁盘块的链表</p></li><li><p>桶的溢出(overflow)</p><p>由于一个bucket只能容纳一定数量的记录，因此，当不断有key被映射到同一个bucket，bucket就会发生溢出</p></li></ul><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数是哈希表的核心部分，哈希函数建立了key到bucket之间的映射，如果选择了一个好的哈希函数，效率的提升将是飞跃的</p><p>通常哈希函数用<code>h()</code>来表示，一个优秀的哈希函数会满足以下两个特征</p><ul><li><p>分布均匀</p><p>理想情况下，每个bucket中都保存相同数量的tuple</p></li><li><p>分布随机</p><p>哈希函数的值应该是接近随机的，不应该发生某些bucket上有大量tuple,而其他bucket上tuple非常少甚至没有</p></li></ul><p>当前性能比较高的的哈希函数如下(crc除外)</p><p><img src="1.png" alt="1"></p><p>他们的性能比较如下图</p><p><img src="2.png" alt="2"></p><p>注:当今比较有名的哈希函数还包含<code>sha-256, md5</code>等，但他们注重与安全性，效率很低，不适合在数据库中使用</p><h4 id="Hashing-Scheme"><a href="#Hashing-Scheme" class="headerlink" title="Hashing Scheme"></a>Hashing Scheme</h4><p>Hashing Scheme主要分为两种，静态哈希(Static Hashing), 动态哈希(Dynamic Hashing)</p><p><strong>静态哈希</strong></p><p>在创建基于静态哈希的散列索引的时候，有一个前提条件，即<strong>能够大体估计出总的record数目</strong></p><p>哈希表的长度应该是固定的，一旦确定下来之后就不能够变更，事实上，随着数据库中记录的不断增加，静态哈希的效率将会逐渐降</p><p>低，因为当记录的数量远大于桶的时候，就不得不在溢出桶上进行查找，而这种查找是线性的</p><p>此时一种可行的解决方案是<strong>增长桶的数量</strong>，常常是增大一倍，但这往往意味着数据库的暂时中断，会带来性能上的瓶颈</p><p>根据是否使用溢出链表可以将散列的寻址方式分为<strong>开寻址</strong>与<strong>闭寻址</strong></p><p>下面介绍几种开寻址中的寻址方法</p><ul><li><p>线性探查法(Linear Probe Hashing)</p><p>线性探查法的基本思路就是当遇到哈希冲突，即不同key被映射到同一个bucket的时候，采用向bucket周围探查的方法寻找新的bucket</p><p><img src="3.png" alt="3"></p><p>在上图中，当插入D时发现该bucket已经有值了，所以向下探查，找到一个空的slot，并将数据存在该slot中</p><p><strong>该方法是最简单，最快速，也是被使用的最多的方法</strong>，该方法在查找或者插入元素时都表现的比较好，但是在删除元素时会比较棘手，来看看下面的例子</p><p><img src="4.png" alt="4"></p><p>当删除C之后，如果我们想要找到D，由于D第一次映射的位置被C所占据，其当前位置是经过探查得到的，所以，当删除C之后，当查找D时，D就会被直接映射到一个空的slot，即查找失败，可以采用<strong>tomb 标志位</strong>来标志该情况</p><p><img src="5.png" alt="5"></p><p>当读取到tomb标志位之后，就意味着应该要继续探查</p><p>还有一种方法是将与删除元素有联系的元素向上移动，但是比较麻烦，就不多介绍了</p><ul><li><p>重复key</p><p>如果key是primary key,那么其对应的value一定唯一，如果key不是primary key的话，就可能发生一个key对应多条记录的情况，此时有两种解决方案</p><ol><li><p>使用value list来存储重复key所对应的value</p><p><img src="6.png" alt="6"></p></li><li><p>在hash table中，存储key|value，这样虽然比较浪费空间，但是影响不大，业界比较常用</p><p><img src="7.png" alt="7"></p></li></ol></li></ul></li></ul><ul><li>Robin Hood Hashing(罗宾汉探查法)</li></ul><p>  该方法旨在减少产生冲突后探查到的位置与原始位置之间的距离，在该探查法中，为每一个hash table中的条目维护一个<code>distance</code>,表示它与原始映射位置的距离，距离越高，表明其越<code>poor,</code>在探查过程中，如果发现某个entry的distance更少，即更<code>rich</code>,那么就会顶替它的位置</p><p>  <img src="8.png" alt="8"></p><p>  上图中,E经过两次探查之后，发现D比其更加贫穷，因此顶替它的位置</p><p>  <img src="9.png" alt="9"></p><ul><li>Cuckoo Hashing</li></ul><p>  该方法使用两张哈希表，大大缩短了查找的时间</p><p>  两张哈希表使用相同的哈希函数，通过不同的hasheeds来形成不同的哈希值，下面简单的描述一下该方法的查找流程</p><ol><li><p>当插入一个记录时，该key会在两张表中形成两个映射的位置，此时选择一个空闲的slot</p><p>如果两个slot均为空闲，那么随机选一个，结束</p></li><li><p>如果两个slot均不为空闲，那么随机选择一个将其当前位置替代，进入步骤3</p></li><li><p>将替换出来的记录的key作为新的key,在另一张表中进行映射，进入步骤1</p></li></ol><p>  该方法的优势在于缩短了查找的流程，实际上最多只需要两次查找即可，但在极少情况下会陷入自循环，此时需要进行重新哈希</p><p>  或者建立更大的hash table</p><p><img src="10.png" alt="10"></p><p><strong>动态哈希</strong></p><p>动态哈希的一大优势在于可以持续进行hash table的扩充，而不需要进行额外的中断</p><p>下面将会介绍几种动态哈希的例子</p><ul><li><p>Chained Hashing</p><p>该方法最简单，只需要在每一个hash table的slot中维护一个bucket链表即可，每当遇见哈希冲突，就将新的record接在对应位置的链表后面</p></li><li><p>可扩充散列(Extendible Hashing)</p><p>哈希函数产生的哈希值可以转换为二进制整数，记其位数为b, b的一个典型的值为32</p><p>该方法中，维护着一个<code>bucket address table</code>,通过使用哈希值的前i为来建立key 与 bucket之间的映射关系</p><p><img src="11.png" alt="11"></p><p>上图中，hash table(bucket address table)左上角的数字为<code>global count</code>, bucket上面的数字为<code>local count</code></p><p>其中间有一套复杂的规则</p><ul><li>查找与插入</li></ul><p><img src="12.png" alt="12"></p><ul><li><p>删除</p><p><img src="13.png" alt="13"></p></li></ul><p>可以看一下这个链接</p><p><a href="http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing.html">http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing.html</a></p></li><li><p>linear Hashing</p><p>Linear Hashing维护了一个<code>split pointer</code>,每次bucket产生溢出的时候，不管split pointer所指向的bucket有没有溢出，均将</p><p>其分裂，即在hash table中添加新的slot，使其指向新的hash table, 然后将split pointer向下移动, 同时还要产生一个新的哈希函</p><p>数, 如果哈希的bucket的值比<code>split pointer</code>要小，那么就应用新的哈希函数</p><p><img src="14.png" alt="14"></p><p>不过该方法使用的比较少</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:缓冲池</title>
    <link href="/2022/01/07/CMU15445-%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <url>/2022/01/07/CMU15445-%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>DBMS的职责就是管理数据在磁盘和内存之间的传输，因为对数据的修改必须在内存中进行</p><p>磁盘，内存以及执行引擎之间的交互关系大概如图</p><p><img src="1.png" alt="1"></p><p>注意到当一个Page被拷贝到内存时，它的内容与磁盘中是完全一样的</p><p>最终的实现效果可以从两个角度来评判</p><ul><li><p>空间控制(spatial control)</p><p>从空间角度来看，对于那些在查询中需要连续访问的page, 理想的效果是将这些连续查询的page放置在从磁盘的连续空间中，这样就可以做到依序I/O，避免随机访问，减少I/O时间</p></li><li><p>时序控制</p><p>时序控制的目的主要是减少从磁盘读取的次数</p></li></ul><h4 id="Lock-amp-Latch"><a href="#Lock-amp-Latch" class="headerlink" title="Lock &amp; Latch"></a>Lock &amp; Latch</h4><p>首先要区分一下Lock 和 Latch的区别</p><ul><li><p>Lock</p><p>Lock是一种高级的逻辑原语，它保护数据库的内容(例如元组、表、数据库)不受其他事务的影响, 事务将在整个期间持有一个锁, 数据库系统可以向用户公开在运行查询时持有哪些锁。Lock需要能够回滚更改</p></li><li><p>Latch</p><p>Latch是DBMS用于其内部数据结构(例如，哈希表，内存区域)的关键部分的一种低级保护原语。Latch仅在操作期间保持。</p><p>Latch不需要能够回滚更改</p></li></ul><p>简单地说，Lock是一种高层次的保护，和事务相关，属于应用层面，Latch则比较底层，是属于mutex那一类数据内部的锁</p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><ul><li>Buffer Pool manager</li></ul><p>​            <code>Buffer Pool manager</code>负责管理缓冲池，当数据库上的程序需要磁盘上的块的时候，它就会向Buffer Pool manager发出请求，</p><p>​            如果当前的Buffer Pool中存放着所需要的page, 那么就直接将该数据块传递给程序，否则就从磁盘中拷贝一份</p><ul><li><p>page, block, frame</p><p>这三者其实意思差不多，只不过在数据库中，我们将硬盘上的block称为page, 将Buffer Pool中的block称为frame</p><p><img src="2.png" alt="2"></p></li><li><p>page table</p><p>page table的作用是记录当前的Buffer Pool中存有哪些page, 即page table与Buffer Pool是一对一的</p><p>page table维护着page id–&gt;frame id的映射关系，具体是page id —-&gt; frame 指针的哈希表</p><p><img src="3.png" alt="3"></p><p>如上图所示，page table除了page id 到frame id的映射，还维护了一些其它的元数据</p><ol><li><p>脏位(Dirty Flag) 用于判断缓冲池中的内容与磁盘是否同步</p></li><li><p>Pin/Reference Counter</p><p>在这里介绍一下Pin的概念，当线程访问Buffer Pool中的Page的时候，必须得对缓冲池中的page进行<code>Pin</code>操作，通常就是对该</p><p>page的Pin Counter + 1, 当一个page的Pin Counter大于1的时候，如果想要对page进行操作就必须得等待，其实就是互斥量的概念</p></li></ol></li><li><p>缓冲池分配策略</p><p>通常有两种策略</p><ul><li><p>global policies</p><p>指所有的查询都是用同一个缓冲池的替换策略</p></li><li><p>local policies</p><p>指针对不同的查询可以使用不同的替换策略</p></li></ul><p>实际上，现在大多数系统都混合使用这两中策略</p></li></ul><h4 id="缓冲池优化"><a href="#缓冲池优化" class="headerlink" title="缓冲池优化"></a>缓冲池优化</h4><ul><li><p>多重缓冲池</p><p>DBMS为了达到不同的目的可以建立多个缓冲池，如一个数据库一个缓冲池，或者一个缓冲池存储一种page类型</p><p>然后每个缓冲池可以采取适合他们自己的策略，这样可以减少latch的竞争并且改善空间局部性</p><p>将tuple映射到缓冲池通常有两种映射方法</p><ol><li><p>Object Id 映射</p><p>Object Id是对记录Id的拓展，其包括关于每个缓冲池管理的数据库对象的元数据</p><p><img src="4.png" alt="4"></p></li><li><p>哈希表映射</p><p>采用简单的哈希映射将tuple映射到不同的Buffer Pool</p><p><img src="5.png" alt="5"></p></li></ol></li><li><p>预取技术</p><p>在取一个page的时候，可以顺便将该page后面的多个page同时取到Buffer Pool,以此来减少I/O</p><p>这种技术常应用于依序查询和索引查询</p><ul><li><p>依序查询</p><p><img src="6.png" alt="6"></p></li><li><p>索引查询</p><p>数据库中的索引通常采用B+树进行组织，当访问到叶子节点的时候，就可以预取出叶子节点后面的节点，尽管这些节点在物理上可能并不连续</p><p><img src="7.png" alt="7"></p></li></ul></li><li><p>Scan sharing</p><p>该技术适用于并发查询，见下面的例子</p><p>假设有如下两个查询</p><p><img src="8.png" alt="8"></p><p>Q1进行Sum计算，需要遍历所有的page，当其遍历到page 3时，另一个查询Q2开始，它进行AVG运算，也需要遍历所有的page</p><p>如果采用scan sharing技术，那么Q2的cursor就可以直接调到Q1的cursor处，它们两个一起进行查询</p><p><img src="9.png" alt="9"></p></li></ul><p>在Q1查询完毕之后，Q2已经遍历了page3 page4 page5，所以Q2需要回到首部继续查询</p><p><img src="10.png" alt="10"></p><p>scan sharing的思想就是<strong>一个查询使用另一个查询的中间过程值，即使这两个查询并不完全相同</strong></p><p>顺便解释一下result cashing的概念</p><p><strong>result cashing</strong></p><p>将查询的结果缓存下来，仅当再一次进行相同的查询时才有用</p><ul><li><p>微扫描(light scan)</p><p>微扫描是指当进行查询时，绕过<strong>缓冲池</strong>，直接为该次查询在内存中开辟一个新的空间，用于存放从磁盘中读取的page，当查询结束的时候，再将这些page从内存中释放</p><ul><li>优点<ol><li>当读取很多数据页时，可以绕过缓冲池的开销</li><li>当单次查询会读取很多page的时候，可以避免污染缓冲池，使得缓冲池的page被挤出去</li></ol></li></ul></li></ul><h4 id="OS-页缓存"><a href="#OS-页缓存" class="headerlink" title="OS 页缓存"></a>OS 页缓存</h4><p>大多数磁盘操作都通过OS API进行。除非有明确的说明，否则操作系统维护自己的文件系统缓存。</p><p>大多数DBMS使用<code>direct I/O</code>,这是操作系统的I/O选项，绕过操作系统的缓存，直接将文件复制进数据库缓冲，而不用首先将文件复制</p><p>进文件缓冲</p><p>但有些厂商，如PostgreSQL,他们就采用了文件缓存，因为这样当发生page fault的时候，就可以直接从文件缓冲区中读取，而不用从磁盘进行I/O</p><h4 id="缓存替换策略"><a href="#缓存替换策略" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h4><ul><li><p>LRU</p><p>即最近最少使用(Least Recently Used)策略，需要追踪每个page, 每次移除最近最少使用的page</p></li><li><p>Clock</p><p>Clock算法是对LRU算法的近似，该算法不需要追踪每个page的时间戳，具体思想是将缓冲池中的page当做一个循环的数组</p><p><img src="11.png" alt="11"></p><p>同时，每个page都附加一个额外的<code>reference bit</code>,</p><p>当指针(clock hand)指向page时，如果该page的reference bit 为1，那么将其置为0，否则将其从缓冲池中去除</p></li></ul><p>这两种算法都有一个<strong>缺点</strong>，就是当进行大量顺序访问时效率很低</p><p>因为进行顺序访问时，刚刚访问完的page往往是之后就不在需要的page</p><ul><li><p>LRU-K</p><p>LRU-K是对LRU以及Clock算法的改进，可以看看下面的文章</p><p><a href="https://segmentfault.com/a/1190000022558044">LRU进阶之LRU-K和2Q - SegmentFault 思否</a></p></li><li><p>优先级提示(Priority Hint)</p><p>优先级提示允许事务根据查询执行期间每个页面的上下文告诉缓冲池页面是否重要</p><p>这里给出一个B+树索引的例子</p><p><img src="12.png" alt="12"></p><p>当执行Q1查询的时候，根据查询我们可以直到每次查询的id都是上一次查询的id+ 1，因此我们就可以将page0, page1, page24加入缓存，因为他们在树中进行查找会需要</p></li></ul><h4 id="Dirty-page"><a href="#Dirty-page" class="headerlink" title="Dirty page"></a>Dirty page</h4><p>当缓存中存在Dirty Page，而此时缓冲区已满，需要进行替换时，此时有两种选择</p><ul><li><p>fast</p><p>直接将那些非dirty的页面替换出去，但这些页面可能将来会需要</p></li><li><p>slow</p><p>对那些dirty page进行更新，将他们写回磁盘，然后再将他们进行体寒</p></li></ul><p>实际上，这两种做法非常难以权衡，所以，数据库的底层通常会有一个专门的线程，用以将这些dirty page定时刷新到磁盘</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:数据库存储</title>
    <link href="/2022/01/06/CMU15445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    <url>/2022/01/06/CMU15445-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="基于日志的page组织"><a href="#基于日志的page组织" class="headerlink" title="基于日志的page组织"></a>基于日志的page组织</h4><p><img src="1.png" alt="1"></p><p>在某些数据库中，page中放置的并不是单纯的tuple, 而是包含了对于数据库的改动，比如插入、删除、更新等</p><ul><li><p>优点</p><p>当使用日志文件组织数据库时，进行的I/O都是顺序的，只需要在page后面不断追加记录即可</p><p>如果使用slot array方式存储tuple, 那么当tuple分散在不同的page时，就需要访问多个page，效率就会降低</p></li></ul><p>​        此外，使用日志对数据库文件进行组织，便于回滚到以前的某一个状态，只需要沿着记录还原出原来的tuple即可</p><ul><li><p>缺点</p><p>读取tuple时会比较慢，因为记录的是日志，如果想要获取某个tuple的状态，就必须要找到所有对这个tuple有改动的日志记录，</p><p>如果日志数量比较庞大，就会比较慢</p><p><strong>解决方法</strong></p><p>一种常见的优化方法是索引和压缩技术</p><p>首先使用索引快速找到针对于某一个tuple的修改记录</p><p><img src="2.png" alt="2"></p><p>事实上，与一条tuple有关的所有记录，都可以被压缩成一条记录，采用压缩技术可以节省很大空间同时加快查找速度</p><p>上面的page可以被压缩成如下</p><p><img src="3.png" alt="3"></p></li></ul><h4 id="sql中的数值存储类型"><a href="#sql中的数值存储类型" class="headerlink" title="sql中的数值存储类型"></a>sql中的数值存储类型</h4><p>在sql中，小数可以使用定点存储也可以采用浮点存储，不同的厂商有不同的选取，但有两个结论是不变的</p><ul><li><strong>定点运算比浮点运算慢</strong></li><li><strong>定点运算的精度往往比较低，但是数值一定是准确的，浮点运算的精度比较高，但是数值可能不准确</strong></li></ul><p>sql中定点的数据类型如<code>decimal</code>, 浮点的数据类型如<code>float, real/double</code></p><p>看下面的例子就知道了</p><p><img src="4.png" alt="4"></p><p>原因是由于如今计算机中对于浮点运算只需要采用一条指令即可，而对于定点运算则需要进行一些程序运算</p><p><img src="5.png" alt="5"></p><h4 id="大对象存储"><a href="#大对象存储" class="headerlink" title="大对象存储"></a>大对象存储</h4><p>有时一个tuple中的某个属性可能无法完整的和其他tuple属性存储在一个page中，此时可以将其额外存储在一个page上，我们将其称为</p><p><code>overflow page</code></p><p><img src="6.png" alt="6"></p><p>不同厂商对overflow page大小也有着不同规定，可以看上面的图片</p><ul><li><p>在原tuple的对应位置可以存储overflow page的指针，这样当访问大对象时，可以通过指针来找到这些大对象</p><p>有的对象可能一个page 都放不下，此时可以采用链表的形式，在overflow page中留下一些位置来指向下一个overflow page，在其</p><p>它overflow page中继续存储</p></li></ul><h4 id="external-vaule-storage"><a href="#external-vaule-storage" class="headerlink" title="external vaule storage"></a>external vaule storage</h4><p>这个词不大好翻译，姑且将其称之为外部存储</p><p>外部存储指的是将文件全部存储在外部磁盘中，这些磁盘不属于数据库，数据库只对他们有读取的权利，在数据库中只存放这些文件在操作系统文件系统中的位置，比如说相对路径</p><p><img src="7.png" alt="7"></p><p>这个技术主要是针对于那些超大文件，比如视频网站中的视频文件，将那些视频文件放在数据库磁盘中无疑是浪费空间，因为</p><p>我们需要的往往是高性能数据库，数据库中的磁盘容量十分宝贵</p><ul><li><p>blob</p><p>这些大型的文件通常被称之为<strong>blob(binary large object)</strong></p></li></ul><h4 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h4><p>数据库中有着两种不同的负载，下面主要介绍两种</p><ul><li><p>OLTP(Online Transcation Processing)</p><p>OLTP指那些访问数据量小的操作，常见的电商交易中对订单以及交易记录的更新，更多情况下是对数据库中的文件进行写操作</p></li><li><p>OLAP( Online Analytical Processing)</p><p>这种操作往往意味着复杂的查询，更多的是读取操作</p></li><li><p>HTAP( Hybrid Transaction + Analytical Processing)</p><p>该情况指的是在一个数据库上同时使用OLAP和OLTP</p><p>它们对应的查询情况的复杂度以及读写情况如下图</p><p><img src="8.png" alt="8"></p></li></ul><h4 id="数据库存储模型"><a href="#数据库存储模型" class="headerlink" title="数据库存储模型"></a>数据库存储模型</h4><ul><li><p>N-ary model(NSM)</p><p>在该模型中，DBSM将一个tuple中的所有元素连续地存储在一个单独的page中，即“行存储”</p><p><img src="9.png" alt="9"></p><ul><li><p>优点</p><ul><li><p>快速的删除，更新，插入</p></li><li><p>对于需要整个tuple的查询友好</p></li></ul></li><li><p>缺点</p><ul><li><p>对于需要某一列或者几列的一次大量地查询不友好</p><p>因为如果想要拿到tuple中的某一列，在该模型中，就得取一整个tuple,那么大量的不需要的tuple属性就会被拿到buffer </p><p>pool，污染缓冲池</p></li></ul></li></ul><p>对于OLTP来说，它往往需要次数密集地整个tuple的插入或者删除，这正好是NSM的适用场景，</p><p>相反，这种场景不适用于OLAP</p></li><li><p>分解存储模型(Decomposition Storage Model, DSM)</p><p>在该模型中，DBSM会将tuple中的属性连续地放在page中，即”列存储”</p><p><img src="10.png" alt="10"></p><ul><li><p>优点</p><ul><li><p>在查询时减少了无用功，因为它仅仅读取那些需要的数据</p></li><li><p>空间被更好地压缩</p><p>因为一个page中存储的都是相同类型的数据，所以可以只存储数据与某个数据的差值，而没必要存储整个数据</p></li></ul></li><li><p>缺点</p><p>在进行完整查询，删除，更新时都非常慢，因为tuple被分散在各个page，如果想要对一个tuple进行操作，就必须要要访问很多page</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概念:数据存储结构</title>
    <link href="/2022/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="page的组织"><a href="#page的组织" class="headerlink" title="page的组织"></a>page的组织</h4><p>一个数据库会被映射为多个不同的文件，一个文件在逻辑上会被组织为tuple的序列，这些tuple被映射到磁盘块上</p><p>一个文件可以被细分为<strong>页</strong>，页是数据传输的单位，一个页包含若干条tuple</p><ul><li><p>数据库的page</p><p>数据库的页与操作系统的页有所不同，通常不同的厂商会指定不同的数据库页大小</p><p><img src="1.png" alt="1"></p></li><li><p>heap file</p><p>heap file是pages的集合，在heap file中，page内的tuple都是以随机次序存储的，heap file满足以下功能</p><ol><li>create/get/write/delete page</li><li>遍历所有的页</li></ol><p>通常heap file有两种实现方式:Linked List, Page Directory</p><ul><li><p>Linked List</p><p>该方式中，在文件的首部有一个header page,其中，该page记录了两个指针</p><ol><li>free page list</li><li>date page list</li></ol><p><img src="2.png" alt="2"></p><p>但这种方式进行页查找时效率很低，所以使用厂商很少</p></li><li><p>Page Directory</p><p>page directory 是一种比较常见的方式, 它提供了一种映射：<code>page id -&gt; offset in file</code>, 这样我们可以通过 page id 找到对应的数据</p><p><img src="3.png" alt="3"></p></li></ul></li></ul><h4 id="tuple的组织"><a href="#tuple的组织" class="headerlink" title="tuple的组织"></a>tuple的组织</h4><p>tuple的组织有两种方法</p><ol><li>存储一种固定长度的tuple</li><li>使用变长的tuple</li></ol><ul><li><p>定长tuple</p><p>使用定长tuple时实现比较简单，但是存在一些问题</p><ol><li>页的大小可能不是块的整数倍，由此导致可能会有某条tuple的一部分在一个页中，另一个部分在另一个页中</li><li>在该结构中删除一条tuple会比较困难，因为会产生空隙</li></ol><p><strong>如何解决</strong></p><ol><li><p>确保tuple只存在于一个块中，所以在一个块中只分配他能够完整容纳的最多的数目</p></li><li><p>将删除tuple后面的每个tuple都向前移一位，但这样效率十分低下</p><p>或者直接将最后一条tuple移动到被删除tuple所在的空间</p></li></ol><p>为了找到空闲的tuple空间，可以使用free list来进行查找，在文件的开头可以分配一定数量的字节，称为<strong>文件头</strong>，其tuple了下一个内容被删除的第一条tuple的地址，以此类推</p><p><img src="4.png" alt="4"></p></li></ul><p>​            如果采用free list, 插入或者删除就十分方便</p><ul><li><p>变长tuple</p><p>由于数据库中的varchar，所以经常会导致数据库中变长tuple的产生，对于变长tuple的使用，通常存在两个问题</p><ol><li>如何表示单条tuple，使得这条tuple能够被轻松地提取，即使这些属性是变长的</li><li>如何在一个块中存储变长的tuple，使得一个块中的tuple能够被轻松提取</li></ol><p><strong>如何解决</strong></p><ol><li><p>在tuple的首部加上header，tuple变长属性的内容</p><p>初始部分通常会包含(偏移量, 长度)对，偏移量指定了该属性在tuple中的位置，长度指定了该属性的长度</p><p>一条tuple总可能还含有<strong>空位图</strong>，用于表示哪些属性是空值，综上所述，一个tuple可能如下所示</p><p><img src="5.png" alt="5"></p></li><li><p>使用**分槽的页结构(slotted-page structure)**可以解决这个问题</p><p>在该结构中，每个page的首部有一个header, tuple了</p><ul><li>一个以每条tuple的位置以及大小为元素组成的数组slot array</li><li>slot array最后一个元素的位置</li></ul><p>该结构看起来像这样</p><p><img src="6.png" alt="6"></p><ul><li><p>tuple的插入</p><p>当插入tuple时，slot array自后向前增长，tuple自后向前增长</p><p><img src="7.png" alt="7"></p></li><li><p>tuple的删除</p><p>当从中间删除tuple3的时候，tuple之间就会产生内部碎片，此时有两种应对方案，不同的数据库厂商所采取的措施也不同</p><ol><li><p>将被删除tuple之前的所有tulple都向后移一位，同时修改header中的相关数据</p><p><img src="8.png" alt="8"></p></li><li><p>直接将原来的位置留空，不改变tuple的位置</p><p>此时如果再插入一个数据，有的厂商是将数据插入空出来的位置，有的则是正常地在首部插入</p></li></ol></li></ul></li></ol></li></ul><h4 id="多表聚簇"><a href="#多表聚簇" class="headerlink" title="多表聚簇"></a>多表聚簇</h4><p>​      可以将多个表中的tuple放在同一个page中，这样做在执行某些查询时可以加快查询的速度</p><p><img src="9.png" alt="9"></p><p>如两个表进行连接时，如果这两个表中的tuple位于同一个page,那么就可以减少磁盘I/O的次数，但这样会导致一些其他的问题，如执行<code>select *</code>时原来表中聚集在一起的tuple分散在了不同的page中，查询效率反而会降低</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概念:码</title>
    <link href="/2022/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E7%A0%81/"/>
    <url>/2022/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>码, 即key, 用于区分给定关系中的不同元组</p><p>下面对码的概念进行介绍</p><ul><li><p>超码(super key)</p><p><strong>超码</strong>是一个或多个属性的集合，将这些属性组合在一起可以唯一的标识一个元组</p></li><li><p>候选码(candidate key)</p><p>候选码是超码的子集，因为超码中可能会包含一些不必要的元素，去掉这些元素后，也能够唯一地标识出某个元组，如果一个超码去掉任何一个元素之后就不能够唯一标识出元组，那么该超码就被成为<strong>候选码</strong></p></li><li><p>主码(primary key)</p><p>候选码可能会有多个，假设一个关系中{ID}和{name, dept_name}都能够唯一标识出元组，那么他们都可以被作为候选码，将被数据库设计者选中而作为实际候选码的候选码称为<strong>主码</strong></p></li><li><p>外码约束</p><ul><li><p>一个例子</p><p>假定有如下两个关系</p></li></ul><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p>​        <em>instructor</em>关系中包含<em>dept_name</em>属性，<em>department</em>关系中包含主码<em>dept_name</em>，如果<em>instructor</em>关系中某个元组的<em>dept_name</em>        并不出现在<em>department</em>关系中，那么这是没有意义的</p><p>​        为了使两个关系之间的联系具有意义，所以需要对它们进行<strong>外码约束</strong></p><ul><li><p>概念</p><p><strong>假定有两个关系r1, r2, r1中的某个属性集为A, r2中主码为B, 在任何数据库实例中，如果r1中的某个元组对A的取值也必须是r2中某个元组对B的取值，那么这两个关系满足从r1关系的A属性集到r2关系的主码B的外码约束</strong></p></li><li><p>A属性被称为从r1引用r2的<strong>外码(foreign key)</strong>,r1被称为该外码约束的<strong>引用关系</strong>，r2被称为该外码约束的<strong>被引用关系</strong></p></li></ul></li><li><p>引用完整性约束</p><p>在外码约束中，被引用关系属性集必须是主码，引用完整性约束则放松了该条件，即被引用属性可以是任意一个指定属性，但是该约束在当今数据库系统中使用的不多</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU15445]:AdvancedSQL</title>
    <link href="/2021/12/16/CMU15445-AdvancedSQL/"/>
    <url>/2021/12/16/CMU15445-AdvancedSQL/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><p>当在sql语句中使用聚集函数时，如果列中同时出现了非聚合函数值，那么他们必须同时出现在<code>GROUP BY</code>子句中</p><p><img src="1.png" alt="1"></p><h4 id="嵌套查询-NESTED-QUERIES"><a href="#嵌套查询-NESTED-QUERIES" class="headerlink" title="嵌套查询(NESTED QUERIES)"></a>嵌套查询(NESTED QUERIES)</h4><p>嵌套查询形如这样</p><p><img src="2.png" alt="2"></p><ul><li><p>效率</p><p>这种查询通常效率很低，因为嵌套查询有点像C++中的双重循环</p></li><li><p>声明问题</p><p>与高级语言一样，内部查询可以使用外部查询的声明，但是外部查询看不见内部查询的声明</p><p><img src="3.png"></p></li><li><p>使用各种关键字或内置函数来辅助嵌套查询</p><p><img src="4.png" alt="4"></p></li></ul><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><p>窗口函数，也称OLAP(Online Anallytical Precessing),可以对数据库数据进行实时分析</p><ul><li>基本语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;<br>order by &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure><pre><code>窗口函数有两种:</code></pre><ol><li>专用的窗口函数,如rank(), row_num()等</li><li>普通聚合函数</li></ol><p>注:<strong>窗口函数只能使用在select子句中,因为它是对where子句或者GROUP BY子句返回的tuple进行处理</strong></p><ul><li><p>例子</p><p><img src="5.png" alt="5"></p><p>对这张表使用如下sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select *,<br>   rank() over (partition by 班级<br>                 order by 成绩 desc) as ranking<br>from 班级表<br></code></pre></td></tr></table></figure><p>得到的结果如下</p><p><img src="6.png" alt="6"></p><p>最终得到的结果根据partition by子句的班级字段进行分组，组内按照成绩进行排序，然后使用rank()进行排序</p><p>注意到该功能与GROUP BY子句功能十分相近，但是还是有些差别，下面是对GROUP BY班级的结果</p><p><img src="7.png" alt="7"></p><p>显然，<strong>GROUP BY 子句会减少原表的行数，而窗口函数不会</strong></p><p>注：专用窗口函数的()可以不加参数</p></li></ul><h4 id="通用表表达式-common-table-expression"><a href="#通用表表达式-common-table-expression" class="headerlink" title="通用表表达式(common table expression)"></a>通用表表达式(common table expression)</h4><p>  common table expression是一种临时表，它使用with命令，甚至可以执行递归查询</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH<br>  cte1 AS (SELECT a, b FROM table1),<br>  cte2 AS (SELECT c, d FROM table2)<br>SELECT b, d FROM cte1 JOIN cte2<br>WHERE cte1.a= cte2.c;<br></code></pre></td></tr></table></figure><p>  在上面的例子中创建了两张表，cte1,cte2，表名放在AS关键字之前</p><ul><li><p>使用WITH + RECURSIVE关键字执行递归查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WITH RECURSIVE qn AS<br>   ( SELECT 1 AS a<br>     UNION ALL               /*UNION 关键字的作用是连接两行*/           <br>     SELECT 1+a FROM qn WHERE a&lt;10<br>   )<br>SELECT *FROM qn;<br></code></pre></td></tr></table></figure><p>最终得到的结果应该是这样</p><p><img src="8.png" alt="8"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="/2021/12/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/"/>
    <url>/2021/12/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/</url>
    
    <content type="html"><![CDATA[<p>终于,我搭建了我的第一个blog</p><p>身为一个准程序员，我竟然到现在才拥有一个自己的blog，想想确实有一些惭愧</p><p>搭建该blog主要是用于记录平时的学习笔记, 可能…还有些乱七八糟的, 总之, 我的blog在此开坑( •̀ ω •́ )✧</p>]]></content>
    
    
    
    <tags>
      
      <tag>开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
