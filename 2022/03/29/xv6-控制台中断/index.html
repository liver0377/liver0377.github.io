

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="控制台Console是与用户进行交互的硬件设备，它接受用户的输入（如键盘输入），将其传递给内核和用户程序，进行相应的处理，然后再输出结果给用户（如输出到屏幕上） 首先，简单地看总体流程：  用户将会通过键盘键入一连串字符，通过连接到RISC-V上的UART串行端口（UART Serial-port）传输，控制台驱动程序将会顺利地接收这些输入  接控制台驱动程序处理其中的一些特殊字符（如BackSp">
<meta property="og:type" content="article">
<meta property="og:title" content="[xv6]:控制台中断">
<meta property="og:url" content="http://example.com/2022/03/29/xv6-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%AD/index.html">
<meta property="og:site_name" content="liver0377">
<meta property="og:description" content="控制台Console是与用户进行交互的硬件设备，它接受用户的输入（如键盘输入），将其传递给内核和用户程序，进行相应的处理，然后再输出结果给用户（如输出到屏幕上） 首先，简单地看总体流程：  用户将会通过键盘键入一连串字符，通过连接到RISC-V上的UART串行端口（UART Serial-port）传输，控制台驱动程序将会顺利地接收这些输入  接控制台驱动程序处理其中的一些特殊字符（如BackSp">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-29T03:07:28.000Z">
<meta property="article:modified_time" content="2022-03-29T03:07:55.915Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary_large_image">
  
  <title>[xv6]:控制台中断 - liver0377</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"PntrlLKLdq8SGWnNk0fAj3MA-gzGzoHsz","app_key":"0TlODH05v37nL1cmzGGbhzdw","server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>纸条屋</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="[xv6]:控制台中断">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-29 11:07" pubdate>
        2022年3月29日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.3k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      23 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">[xv6]:控制台中断</h1>
            
            <div class="markdown-body">
              <p><strong>控制台Console</strong>是与用户进行交互的硬件设备，它接受用户的输入（如键盘输入），将其传递给内核和用户程序，进行相应的处理，然后再输出结果给用户（如输出到屏幕上）</p>
<p>首先，简单地看总体流程：</p>
<ul>
<li><p>用户将会通过<strong>键盘</strong>键入一连串字符，通过连接到RISC-V上的<strong>UART串行端口</strong>（<strong>UART Serial-port</strong>）传输，<strong>控制台</strong>驱动程序将会顺利地接收这些输入</p>
</li>
<li><p>接控制台驱动程序处理其中的一些特殊字符（如BackSpace和Ctrl等），并不断累积这些输入字符，直到达到完整的一行（一般用户键入Enter表示一行的结束)</p>
</li>
<li><p><strong>用户进程</strong>，例如<strong>shell</strong>，就会使用read从控制台中读取这些一行行的输入，然后由shell来具体处理它们</p>
</li>
</ul>
<p>内核可以访问经<strong>内存映射</strong>的<strong>UART控制寄存器</strong>。RISC-V硬件将UART设备连接到事先约定好的物理地址上，对这些固定物理地址的读或写指令，相当于直接于硬件设备进行交互，而不是与RAM交互</p>
<p>UART经内存映射到从物理地址0x10000000开始的部分上，它有一小部分控制寄存器，每个<strong>1B</strong>大小， 当处理设备中断时需要使用到这些寄存器</p>
<ul>
<li><p>kernel/uart.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the UART control registers are memory-mapped</span><br><span class="hljs-comment">// at address UART0. this macro returns the</span><br><span class="hljs-comment">// address of one of the registers.</span><br><span class="hljs-comment">// 用于寻址, 采用的基址 + 偏移量的方式</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg))</span><br><br><span class="hljs-comment">// the UART control registers.</span><br><span class="hljs-comment">// some have different meanings for</span><br><span class="hljs-comment">// read vs write.</span><br><span class="hljs-comment">// see http://byterunner.com/16550.html</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RHR 0                 <span class="hljs-comment">// receive holding register (for input bytes)</span></span><br>                              <span class="hljs-comment">// 保持着UART接受的输入，等待着内核将其内容取走, 与read()相关</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THR 0                 <span class="hljs-comment">// transmit holding register (for output bytes)</span></span><br>                              <span class="hljs-comment">// 保持着内核的输入，等待着UART将其发送, 与write()相关</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER 1                 <span class="hljs-comment">// interrupt enable register</span></span><br>                              <span class="hljs-comment">// 中断控制寄存器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER_TX_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IER_RX_ENABLE (1&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR 2                 <span class="hljs-comment">// FIFO control register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="hljs-comment">// clear the content of the two FIFOs</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISR 2                 <span class="hljs-comment">// interrupt status register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR 3                 <span class="hljs-comment">// line control register</span></span><br>                              <span class="hljs-comment">// 指定异步数据的传输格式: 字节长度, 停止字节</span><br>                              <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="hljs-comment">// special mode to set baud rate</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR 5                 <span class="hljs-comment">// line status register</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="hljs-comment">// input is waiting to be read from RHR</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="hljs-comment">// THR can accept another character to send</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-控制台读取用户输入流程"><a href="#1-控制台读取用户输入流程" class="headerlink" title="1. 控制台读取用户输入流程"></a>1. 控制台读取用户输入流程</h3><p>先给出整个流程，然后给出具体细节描述:</p>
<ul>
<li><p>用户使用<code>read()</code>系统调用从控制台读取输入，控制台等待用户输入, 此时会产生<code>consoleread()</code>进程</p>
</li>
<li><p>用户键盘输入一个字符</p>
</li>
<li><p><code>xv6</code>接收到中断，陷入<code>trap</code></p>
</li>
<li><p><code>trap handler</code>发现是外部设备中断，设备是<code>UART</code>，调用<code>uartintr()</code></p>
</li>
<li><p>发现<code>RHR</code>中有字符可读，调用<code>consoleintr()</code></p>
</li>
<li><p>将输入字符缓冲到<code>cons.buf</code>中，如果读到’\n’或’ctrl+D’，说明用户输入满足一行，就唤醒<code>consoleread()</code></p>
</li>
<li><p>读出一整行的用户输入，拷贝到用户空间中</p>
</li>
</ul>
<p><strong>键入字符后陷入trap</strong></p>
<p>用户键入字符后，<code>UART</code>硬件向RISCV抛出一个终端, 激活<code>usertrap()</code>, <code>usertrap()</code>对中断类型进行检查，调用<code>devintr()</code>判断是否为硬件中断</p>
<ul>
<li><p>kernel/trap.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">devintr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 scause = r_scause();<br><br>  <span class="hljs-keyword">if</span>((scause &amp; <span class="hljs-number">0x8000000000000000</span>L) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>)&#123;<br>    <span class="hljs-comment">// this is a supervisor external interrupt, via PLIC.</span><br><br>    <span class="hljs-comment">// irq indicates which device interrupted.</span><br>    <span class="hljs-comment">// 从PLC硬件单元中询问哪个硬件设备中断了</span><br>    <span class="hljs-keyword">int</span> irq = plic_claim();<br><br>    <span class="hljs-keyword">if</span>(irq == UART0_IRQ)<br>      <span class="hljs-comment">// uart设备中断</span><br>      uartintr();<br><span class="hljs-comment">// 后面的可以忽略...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>发现为uart中断，调用uartintr()</strong></p>
<ul>
<li><p>kernel/uart.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uartintr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// read and process incoming characters.</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">// 从RHR控制寄存器中读取一个字符</span><br>    <span class="hljs-keyword">int</span> c = uartgetc();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    consoleintr(c);<br>  &#125;<br><br>  <span class="hljs-comment">// send buffered characters.</span><br>  acquire(&amp;uart_tx_lock);<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>uartintr()</code>内部会使用<code>uartgetc()</code>来从<code>RHR</code>控制寄存器中获取用户键入的字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">uartgetc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(ReadReg(LSR) &amp; <span class="hljs-number">0x01</span>)&#123;<br>    <span class="hljs-comment">// input data is ready.</span><br>    <span class="hljs-keyword">return</span> ReadReg(RHR);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，已经确定了中断类型，会调用<code>consoleintr()</code>进行控制台相关处理</p>
</li>
</ul>
<p><strong>调用consoleintr()</strong></p>
<p>关于console, xv6使用了一个<code>cons</code>对象来对其进行维护</p>
<ul>
<li><p>kernel/console.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <br>  <span class="hljs-comment">// input</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INPUT_BUF 128</span><br>  <span class="hljs-keyword">char</span> buf[INPUT_BUF];     <span class="hljs-comment">// console缓冲区</span><br>  uint r;  <span class="hljs-comment">// Read index   </span><br>  uint w;  <span class="hljs-comment">// Write index</span><br>  uint e;  <span class="hljs-comment">// Edit index   // 这里的索引可能会超过缓冲区大小，后面使用了取余操作</span><br>&#125; cons;<br></code></pre></td></tr></table></figure></li>
<li><p>kernel/console.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//! @param c 用户键入的字符</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">consoleintr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-comment">// ctrl + P, ctrl + U, ctrl + H</span><br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span></span><br><span class="hljs-function">    <span class="hljs-title">procdump</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span></span><br><span class="hljs-function">    <span class="hljs-title">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="hljs-params"><span class="hljs-function">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span></span><br><span class="hljs-function">  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;:</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(cons.e != cons.w)</span></span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认情况下会回显字符</span><br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;<br>      <br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br><br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        <span class="hljs-comment">// 用户不断键入字符，直到用户输入换行符或者ctrl + d时</span><br>        <span class="hljs-comment">// 才会唤醒之前睡在cons.r的consoleread()进程</span><br>        cons.w = cons.e;<br>        <span class="hljs-comment">// </span><br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  release(&amp;cons.lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，默认情况下会对用户键入的字符进行回显，同时将其保存到<code>cons</code>对象的缓冲区中</p>
<p>如果用户输入了一些特殊字符(如ctrl + p等)，那么就做特殊处理</p>
<p>当用户键入<code>\n</code>回车符或者<code>ctrl + d</code>文件结束符时，就立即<strong>唤醒之前处于sleep</strong>状态并且睡在<code>cons.r</code>的<code>consoleread()</code>进程</p>
<blockquote>
<p>consoleread()进程在用户发起read()操作时就会产生， 这些进程并没有阻塞，而是使用了<code>schedule()</code>让出了CPU</p>
</blockquote>
</li>
</ul>
<p><strong>consoleread()进程读取控制台缓冲区内容到用户空间</strong></p>
<ul>
<li><p>kernel/console.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*! @brief 将console缓冲区的内容拷贝到sdt </span><br><span class="hljs-comment"> *! @param user_dst 用于判断dst是用户地址还是内核地址</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">consoleread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> user_dst, uint64 dst, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint target;<br>  <span class="hljs-keyword">int</span> c;<br>  <span class="hljs-keyword">char</span> cbuf;<br><br>  target = n;<br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// wait until interrupt handler has put some</span><br>    <span class="hljs-comment">// input into cons.buffer.</span><br>    <span class="hljs-comment">// 当console的read index与console 的write index相等</span><br>    <span class="hljs-comment">// 有两种情况: </span><br>    <span class="hljs-comment">// 1. 缓冲区没有字符可读</span><br>    <span class="hljs-comment">// 2. 缓冲区已经读完，但是该行仍未结束</span><br>    <span class="hljs-keyword">while</span>(cons.r == cons.w)&#123;<br>      <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>        release(&amp;cons.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      <span class="hljs-comment">// 睡眠</span><br>      <span class="hljs-comment">// 这里并不会发生阻塞，而是进程的重新调度</span><br>      sleep(&amp;cons.r, &amp;cons.lock);<br>    &#125;<br><br>    <span class="hljs-comment">// 一次性读取一个字符 </span><br>    c = cons.buf[cons.r++ % INPUT_BUF];<br><br>    <span class="hljs-keyword">if</span>(c == C(<span class="hljs-string">&#x27;D&#x27;</span>))&#123;  <span class="hljs-comment">// end-of-file(十进制为4), 当键入ctrl + D时就会触发</span><br>      <span class="hljs-keyword">if</span>(n &lt; target)&#123;<br>        <span class="hljs-comment">// Save ^D for next time, to make sure</span><br>        <span class="hljs-comment">// caller gets a 0-byte result.</span><br>        <span class="hljs-comment">// 读取到了文件结束符, 但是没有达到target</span><br>        cons.r--;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the input byte to the user-space buffer.</span><br>    cbuf = c;<br>    <span class="hljs-comment">// 注意此时进程处于内核态</span><br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br><br>    dst++;<br>    --n;<br><br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>      <span class="hljs-comment">// a whole line has arrived, return to</span><br>      <span class="hljs-comment">// the user-level read().</span><br>      <span class="hljs-comment">// 行尾符, 此时整个read()操作结束</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> target - n;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-将用户数据发送到控制台流程"><a href="#2-将用户数据发送到控制台流程" class="headerlink" title="2. 将用户数据发送到控制台流程"></a>2. 将用户数据发送到控制台流程</h3><p>在发送过程中需要使用到的两个比较重要的寄存器:</p>
<ul>
<li><p><code>THR</code>: 如果用户想要将字符发送到控制台，就必须将字符写入到该寄存器当中，随后，会由硬件自动读取该寄存器中的值</p>
<p>​          如果THR寄存器中的值被硬件读出，就代表该字符真正的被控制台读取了，同时将会自动触发<strong>transmit complete 中断</strong>, 陷入         </p>
<p>​          trap</p>
</li>
<li><p><code>LSR</code>: 利用其中的第6个bit可以用来判断<code>THR</code>寄存器内部是否为空</p>
</li>
</ul>
<p>xv6同样也为发送过程维护了一个缓冲区：</p>
<ul>
<li><p>kernel/uart.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the transmit output buffer.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">uart_tx_lock</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UART_TX_BUF_SIZE 32</span><br><span class="hljs-keyword">char</span> uart_tx_buf[UART_TX_BUF_SIZE];<br><span class="hljs-keyword">int</span> uart_tx_w; <span class="hljs-comment">// write next to uart_tx_buf[uart_tx_w++]</span><br><span class="hljs-keyword">int</span> uart_tx_r; <span class="hljs-comment">// read next from uart_tx_buf[uar_tx_r++]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>简要流程:</p>
<ul>
<li><p>用户使用<code>write()</code>系统调用, 最终将导向到UART驱动程序的<code>top half</code>, 结果为调用<code>uarputc()</code></p>
</li>
<li><p><code>uartputc()</code>尝试将用户提供的字符写入到<code>uart_tx_buf</code>缓冲区</p>
<p>如果缓冲区满的话，将会<code>sleep</code></p>
<p>否则，调用<code>uartstart()</code></p>
</li>
<li><p><code>uartstart()</code>会尝试将缓冲区的字符写入到<code>THR</code>寄存器中</p>
<p>如果<code>THR</code>寄存器此时为空，则表明可以写入</p>
<p>否则直接返回</p>
</li>
<li><p>位于<code>THR</code>寄存器中的值被控制台读出，触发<code>transmit complete</code>中断，陷入<code>trap</code></p>
</li>
<li><p>在<code>devintr()</code>中发现中断为<code>uart</code>设备中断，调用<code>uartintr()</code></p>
</li>
<li><p><code>uartintr()</code>中经过判断发现是<code>transmit complete</code>中断，调用<code>uartstart()</code>， 陷入循环</p>
</li>
</ul>
<blockquote>
<p>可以看出uartputc()会尝试将用户提供的字符一次性全部写入缓冲区，然后再由<code>uartstart()</code>一次中断写入一个字符到控制台</p>
</blockquote>
<p>在这里就不给出代码分析了，但重要的一点是, 上面的整个过程都是<strong>异步</strong>的， <code>uartstart()</code>在发现<code>THR</code>寄存器非空会直接返回,</p>
<p><code>uartputc()</code>发现缓冲区满会进行<code>sleep</code>, 让出CPU</p>
<p>在xv6中还提供了一个<code>uartputc_sync()</code>, 是<code>uartputc()</code>的同步版本，采用了轮询方式(poiling), 用于用户希望快速发出内容的情况</p>
<ul>
<li><p>kernel/uart.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uartputc_sync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  push_off();<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br><br>  <span class="hljs-comment">// wait for Transmit Holding Empty to be set in LSR.</span><br>  <span class="hljs-comment">// 一直阻塞直到THR中的内容发出</span><br>  <span class="hljs-comment">// 然后马上将待发送字符写入THR中</span><br>  <br>  <span class="hljs-keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)<br>    ;<br>  WriteReg(THR, c);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里没有使用到发送缓冲区，而是直接尝试将内容写入到THR中, 如果<code>THR</code>非空的话就会陷入阻塞</p>
</li>
</ul>
<blockquote>
<p>uart,  键盘,  显示器 ?</p>
<p>uart连接了两个键盘以及显示器(Console)两个设备，当通过键盘键入字符时，会将字符发送到uart的相关控制寄存器，然后寄存器的值会被显示器读取显示在屏幕上</p>
</blockquote>
<h3 id="3-uart相关并发"><a href="#3-uart相关并发" class="headerlink" title="3. uart相关并发"></a>3. uart相关并发</h3><p>在xv6中，<strong>设备与CPU(进程)是并发运行的</strong>, 一个简单的理解就是<code>UART</code>在向<code>Console</code>发送字符时, <code>Shell</code>可能正同时向Console的缓冲区写入字符, 这被称为<strong>producer-consumer并行</strong></p>
<p>通过代码可以看出，<code>UART</code>的输入以及输出缓冲区都是<strong>全局</strong>的，所有的CPU都会访问相同的输入输出缓冲区，因此在代码中使用了锁来保护共享的数据结构</p>
<p>**Top 与 Bottom **</p>
<p>通常情况下，大多数的设备驱动程序，都可以看成一个分上下部分的结构：顶部<strong>top half</strong>运行在内核空间中，通常由某一个进程的内核线程来运行，而底部<strong>bottom half</strong>则在中断产生时执行，大体上就是<code>Interrupt handler</code></p>
<p>当内核希望与设备进行一些交互时，请求read、write等系统调用，驱动程序的<code>top half</code>就会被调用，<code>top half</code>会根据相应请求，让设备开始执行一些具体的操作（例如从磁盘上读一块）；在相关操作完成后，设备就会产生中断，因此驱动程序的<code>bottom half</code>开始执行，它会查看设备完成的是什么工作，在适当的时候唤醒等待该工作的进程，同时让设备开始做新的工作</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/xv6/">xv6</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/29/xv6-%E8%B0%83%E5%BA%A6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[xv6]:调度</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/29/xv6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                        <span class="hidden-mobile">[xv6]:内存管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
